@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1998 Free Software Foundation, Inc. 
@c See the file elisp.texi for copying conditions.
@setfilename ../info/strings
@node Strings and Characters, Lists, Numbers, Top
@comment  node-name,  next,  previous,  up
@c @chapter Strings and Characters
@chapter 文字列と文字
@c @cindex strings
@c @cindex character arrays
@c @cindex characters
@c @cindex bytes
@cindex 文字列
@cindex 文字配列
@cindex 文字
@cindex バイト

@c   A string in Emacs Lisp is an array that contains an ordered sequence
@c of characters.  Strings are used as names of symbols, buffers, and
@c files, to send messages to users, to hold text being copied between
@c buffers, and for many other purposes.  Because strings are so important,
@c Emacs Lisp has many functions expressly for manipulating them.  Emacs
@c Lisp programs use strings more often than individual characters.
Emacs Lispの文字列は文字の順序列を保持している配列です。
文字列は、シンボル、バッファ、ファイルのそれぞれの名前として、
ユーザーへメッセージを送るため、
バッファ間でコピーするテキストを保持するため、
その他さまざまな目的に使われます。
文字列はとても重要なので、
Emacs Lispには文字列を操作する関数が数多くあります。
Emacs Lispのプログラムでは、個々の文字よりも文字列を多用します。

@c   @xref{Strings of Events}, for special considerations for strings of
@c keyboard character events.
キーボード文字イベントを表す文字列に関する特別な配慮については、
@xref{Strings of Events}。

@menu
* Basics: String Basics.      Basic properties of strings and characters.
* Predicates for Strings::    Testing whether an object is a string or char.
* Creating Strings::          Functions to allocate new strings.
* Modifying Strings::         Altering the contents of an existing string.
* Text Comparison::           Comparing characters or strings.
* String Conversion::         Converting characters or strings and vice versa.
* Formatting Strings::        @code{format}: Emacs's analogue of @code{printf}.
* Case Conversion::           Case conversion functions.
* Case Tables::		      Customizing case conversion.
@end menu

@node String Basics
@c @section String and Character Basics
@section 文字列と文字の基本

@c   Strings in Emacs Lisp are arrays that contain an ordered sequence of
@c characters.  Characters are represented in Emacs Lisp as integers;
@c whether an integer is a character or not is determined only by how it is
@c used.  Thus, strings really contain integers.
Emacs Lispの文字列は文字の順序列を保持している配列です。
Emacs Lispでは文字を整数で表現します。
整数が文字であるかどうかは、その使われ方からしか判断できません。
したがって、文字列は、実際には、整数群を保持しているのです。

@c   The length of a string (like any array) is fixed, and cannot be
@c altered once the string exists.  Strings in Lisp are @emph{not}
@c terminated by a distinguished character code.  (By contrast, strings in
@c C are terminated by a character with @sc{ASCII} code 0.)
（任意の配列と同様に）文字列の長さは固定されていて、
文字列をいったん作成すると変更できません。
Lispの文字列は特別な文字コードで終端されるのでは@emph{ありません}。
（対照的に、C言語の文字列は@sc{ASCII}コード0で終端される。）

@c   Since strings are arrays, and therefore sequences as well, you can
@c operate on them with the general array and sequence functions.
@c (@xref{Sequences Arrays Vectors}.)  For example, you can access or
@c change individual characters in a string using the functions @code{aref}
@c and @code{aset} (@pxref{Array Functions}).
文字列は配列ですからシーケンスでもあり、
一般の配列関数やシーケンス関数で文字列を操作できます。
（@pxref{Sequences Arrays Vectors}。）
たとえば、関数@code{aref}と@code{aset}（@pxref{Array Functions}）を
用いて、文字列内の個々の文字を参照したり変更できます。

@c   There are two text representations for non-@sc{ASCII} characters in
@c Emacs strings (and in buffers): unibyte and multibyte (@pxref{Text
@c Representations}).  @sc{ASCII} characters always occupy one byte in a
@c string; in fact, there is no real difference between the two
@c representation for a string which is all @sc{ASCII}.  For most Lisp
@c programming, you don't need to be concerned with these two
@c representations.
Emacs文字列（およびバッファ）内の非@sc{ASCII}文字のテキスト表現は
2種類あります。
ユニバイトとマルチバイトです（@pxref{Text Representations}）。
@sc{ASCII}文字は、文字列内ではつねに1バイトを占めます。
実際、すべてが@sc{ASCII}文字である文字列では、2つの表現に違いはありません。
ほとんどのLispプログラムでは、
読者はこれらの2つの表現を考慮する必要はないでしょう。

@c   Sometimes key sequences are represented as strings.  When a string is
@c a key sequence, string elements in the range 128 to 255 represent meta
@c characters (which are extremely large integers) rather than character
@c codes in the range 128 to 255.
キー列を文字列として表現することがあります。
文字列がキー列を表す場合、128から255の範囲にある文字列の要素は、
その範囲の文字コードとしてではなく、
（非常に大きな整数になる）メタ文字を表現します。

@c   Strings cannot hold characters that have the hyper, super or alt
@c modifiers; they can hold @sc{ASCII} control characters, but no other
@c control characters.  They do not distinguish case in @sc{ASCII} control
@c characters.  If you want to store such characters in a sequence, such as
@c a key sequence, you must use a vector instead of a string.
@c @xref{Character Type}, for more information about representation of meta
@c and other modifiers for keyboard input characters.
文字列は、ハイパー、スーパー、アルトの修飾子を持つ文字を保持できません。
文字列は@sc{ASCII}コントロール文字を保持できますが、
それ以外のコントロール文字を保持できません。
文字列では、@sc{ASCII}コントロール文字の大文字小文字を区別できません。
キー列などのそのような文字をシーケンスに収めるには、
文字列のかわりにベクトルを使う必要があります。
キーボード入力文字に対するメタなどの修飾子の表現については、
@xref{Character Type}。

@c   Strings are useful for holding regular expressions.  You can also
@c match regular expressions against strings (@pxref{Regexp Search}).  The
@c functions @code{match-string} (@pxref{Simple Match Data}) and
@c @code{replace-match} (@pxref{Replacing Match}) are useful for
@c decomposing and modifying strings based on regular expression matching.
文字列は正規表現を保持するのにも便利です。
文字列に対して正規表現の一致を取ることもできます（@pxref{Regexp Search}）。
関数@code{match-string}（@pxref{Simple Match Data}）と
@code{replace-match}（@pxref{Replacing Match}）は、
正規表現の一致に基づいて文字列を分解したり変更するのに便利です。

@c   Like a buffer, a string can contain text properties for the characters
@c in it, as well as the characters themselves.  @xref{Text Properties}.
@c All the Lisp primitives that copy text from strings to buffers or other
@c strings also copy the properties of the characters being copied.
バッファと同様に、文字列は、
文字そのものに加えて文字列内の文字に対するテキスト属性を保持できます。
@xref{Text Properties}。
文字列からバッファや他の文字列へテキストをコピーするすべてのLisp基本関数は、
コピーする文字の属性もコピーします。

@c   @xref{Text}, for information about functions that display strings or
@c copy them into buffers.  @xref{Character Type}, and @ref{String Type},
@c for information about the syntax of characters and strings.
@c @xref{Non-ASCII Characters}, for functions to convert between text
@c representations and encode and decode character codes.
文字列を表示したりバッファへコピーする関数については、@xref{Text}。
文字と文字列の構文については、@ref{Character Type}と@xref{String Type}。
テキスト表現を変換したり、文字コードを符号化／復号化する関数については、
@xref{Non-ASCII Characters}。

@node Predicates for Strings
@c @section The Predicates for Strings
@section 文字列向けの述語

@c For more information about general sequence and array predicates,
@c see @ref{Sequences Arrays Vectors}, and @ref{Arrays}.
一般のシーケンスや配列に対する述語について詳しくは、
@ref{Sequences Arrays Vectors}と@xref{Arrays}。

@defun stringp object
@c This function returns @code{t} if @var{object} is a string, @code{nil}
@c otherwise.
この関数は、@var{object}が文字列ならば@code{t}を返し、
さもなければ@code{nil}を返す。
@end defun

@defun char-or-string-p object
@c This function returns @code{t} if @var{object} is a string or a
@c character (i.e., an integer), @code{nil} otherwise.
この関数は、@var{object}が文字列か文字（つまり、整数）ならば
@code{t}を返し、さもなければ@code{nil}を返す。
@end defun

@node Creating Strings
@c @section Creating Strings
@section 文字列の作成

@c   The following functions create strings, either from scratch, or by
@c putting strings together, or by taking them apart.
以下の関数は、新たに文字列を作成したり、
文字列を連結したり分解して文字列を作成します。

@defun make-string count character
@c This function returns a string made up of @var{count} repetitions of
@c @var{character}.  If @var{count} is negative, an error is signaled.
この関数は、文字@var{character}を@var{count}回繰り返して作成した文字列を返す。
@var{count}が負であるとエラーを通知する。

@example
(make-string 5 ?x)
     @result{} "xxxxx"
(make-string 0 ?x)
     @result{} ""
@end example

@c   Other functions to compare with this one include @code{char-to-string}
@c (@pxref{String Conversion}), @code{make-vector} (@pxref{Vectors}), and
@c @code{make-list} (@pxref{Building Lists}).
この関数に対比するものに、
@code{char-to-string}（@pxref{String Conversion}）、
@code{make-vector}（@pxref{Vectors}）、
@code{make-list}（@pxref{Building Lists}）などがある。
@end defun

@defun string &rest characters
@tindex string
@c This returns a string containing the characters @var{characters}.
これは、複数個の文字群@var{characters}が入った文字列を返す。

@example
(string ?a ?b ?c)
     @result{} "abc"
@end example
@end defun

@defun substring string start &optional end
@c This function returns a new string which consists of those characters
@c from @var{string} in the range from (and including) the character at the
@c index @var{start} up to (but excluding) the character at the index
@c @var{end}.  The first character is at index zero.
この関数は、@var{string}の@var{start}から
@var{end}（の直前）までの範囲にある文字から成る新たな文字列を返す。
先頭の文字を0で添字付けする。

@example
@group
(substring "abcdefg" 0 3)
     @result{} "abc"
@end group
@end example

@noindent
@c Here the index for @samp{a} is 0, the index for @samp{b} is 1, and the
@c index for @samp{c} is 2.  Thus, three letters, @samp{abc}, are copied
@c from the string @code{"abcdefg"}.  The index 3 marks the character
@c position up to which the substring is copied.  The character whose index
@c is 3 is actually the fourth character in the string.
ここで、@samp{a}の添字は0、@samp{b}の添字は1、@samp{c}の添字は2である。
したがって、文字列@code{"abcdefg"}から3文字@samp{abc}をコピーする。
添字3はコピーする部分文字列の境界の文字位置を表す。
添字が3である文字は、実際には文字列内の4番目の文字である。

@c A negative number counts from the end of the string, so that @minus{}1
@c signifies the index of the last character of the string.  For example: 
負の数は文字列の末尾から数える。
したがって、@minus{}1は文字列の最後の文字の添字である。
たとえば、

@example
@group
(substring "abcdefg" -3 -1)
     @result{} "ef"
@end group
@end example

@noindent
@c In this example, the index for @samp{e} is @minus{}3, the index for
@c @samp{f} is @minus{}2, and the index for @samp{g} is @minus{}1.
@c Therefore, @samp{e} and @samp{f} are included, and @samp{g} is excluded.
この例では、@samp{e}の添字は@minus{}3、@samp{f}の添字は@minus{}2、
@samp{g}の添字は@minus{}1である。
したがって、@samp{e}と@samp{f}を含むが@samp{g}は含まない。

@c When @code{nil} is used as an index, it stands for the length of the
@c string.  Thus,
添字に@code{nil}を使うと、文字列の長さを意味する。
したがって、つぎのようになる。

@example
@group
(substring "abcdefg" -3 nil)
     @result{} "efg"
@end group
@end example

@c Omitting the argument @var{end} is equivalent to specifying @code{nil}.
@c It follows that @code{(substring @var{string} 0)} returns a copy of all
@c of @var{string}.
引数@var{end}を省略することは、@code{nil}を指定することと等価である。
そのため、@code{(substring @var{string} 0)}は、
@var{string}全体をコピーしたものを返す。

@example
@group
(substring "abcdefg" 0)
     @result{} "abcdefg"
@end group
@end example

@noindent
@c But we recommend @code{copy-sequence} for this purpose (@pxref{Sequence
@c Functions}).
しかし、このような目的には@code{copy-sequence}を勧める
（@pxref{Sequence Functions}）。

@c If the characters copied from @var{string} have text properties, the
@c properties are copied into the new string also.  @xref{Text Properties}.
@var{string}からコピーした文字にテキスト属性があれば、
新たな文字列にもそのテキスト属性をコピーする。
@pxref{Text Properties}。

@c @code{substring} also allows vectors for the first argument.
@c For example:
@code{substring}は第1引数としてベクトルも受け付ける。
たとえば、つぎのとおり。

@example
(substring [a b (c) "d"] 1 3)
     @result{} [b (c)]
@end example

@c A @code{wrong-type-argument} error is signaled if either @var{start} or
@c @var{end} is not an integer or @code{nil}.  An @code{args-out-of-range}
@c error is signaled if @var{start} indicates a character following
@c @var{end}, or if either integer is out of range for @var{string}.
@var{start}や@var{end}が整数でも@code{nil}でもないと、
エラー@code{wrong-type-argument}を通知する。
@var{start}が@var{end}よりうしろの文字を指していたり、
いずれかの整数が@var{string}の範囲外であると
エラー@code{args-out-of-range}を通知する。

@c Contrast this function with @code{buffer-substring} (@pxref{Buffer
@c Contents}), which returns a string containing a portion of the text in
@c the current buffer.  The beginning of a string is at index 0, but the
@c beginning of a buffer is at index 1.
この関数と対照的なのが@code{buffer-substring}
（@pxref{Buffer Contents}）であり、
カレントバッファ内のテキストの一部を収めた文字列を返す。
文字列の先頭は0で添字付けするが、バッファの先頭は1で添字付けする。
@end defun

@defun concat &rest sequences
@c @cindex copying strings
@c @cindex concatenating strings
@cindex 文字列のコピー
@cindex コピー、文字列
@cindex 文字列の連結
@cindex 連結、文字列
@c This function returns a new string consisting of the characters in the
@c arguments passed to it (along with their text properties, if any).  The
@c arguments may be strings, lists of numbers, or vectors of numbers; they
@c are not themselves changed.  If @code{concat} receives no arguments, it
@c returns an empty string.
この関数は、渡した引数の文字から成る
（テキスト属性があればそれも含めて）新たな文字列を返す。
引数は、文字列、数のリスト、数のベクトルである。
引数自身は変更しない。
@code{concat}に引数を指定しないと空文字列を返す。

@example
(concat "abc" "-def")
     @result{} "abc-def"
(concat "abc" (list 120 121) [122])
     @result{} "abcxyz"
@c ;; @r{@code{nil} is an empty sequence.}
;; @r{@code{nil}は空シーケンス}
(concat "abc" nil "-def")
     @result{} "abc-def"
(concat "The " "quick brown " "fox.")
     @result{} "The quick brown fox."
(concat)
     @result{} ""
@end example

@noindent
@c The @code{concat} function always constructs a new string that is
@c not @code{eq} to any existing string.
関数@code{concat}は、
既存の文字列と@code{eq}ではない新たな文字列をつねに作り出す。

@c When an argument is an integer (not a sequence of integers), it is
@c converted to a string of digits making up the decimal printed
@c representation of the integer.  @strong{Don't use this feature; we plan
@c to eliminate it.  If you already use this feature, change your programs
@c now!}  The proper way to convert an integer to a decimal number in this
@c way is with @code{format} (@pxref{Formatting Strings}) or
@c @code{number-to-string} (@pxref{String Conversion}).
引数が（整数のシーケンスではなく）整数であると、
その整数の表示表現を構成する文字列に変換する。
@strong{この機能を使わないでほしい。
削除する予定である。
読者がこの機能を使っていたら、今すぐプログラムを直すこと！}@code{ }
整数をこのような10進数に変換する正しい方法は、
@code{format}（@pxref{Formatting Strings}）や
@code{number-to-string}（@pxref{String Conversion}）を使うことである。

@example
@group
(concat 137)
     @result{} "137"
(concat 54 321)
     @result{} "54321"
@end group
@end example

@c For information about other concatenation functions, see the
@c description of @code{mapconcat} in @ref{Mapping Functions},
@c @code{vconcat} in @ref{Vectors}, and @code{append} in @ref{Building
@c Lists}.
他の連結関数については、
@ref{Mapping Functions}の@code{mapconcat}、
@ref{Vectors}の@code{vconcat}、
@ref{Building Lists}の@code{append}を参照。
@end defun

@defun split-string string separators
@tindex split-string
@c Split @var{string} into substrings in between matches for the regular
@c expression @var{separators}.  Each match for @var{separators} defines a
@c splitting point; the substrings between the splitting points are made
@c into a list, which is the value.  If @var{separators} is @code{nil} (or
@c omitted), the default is @code{"[ \f\t\n\r\v]+"}.
@var{string}を正規表現@var{separators}の一致箇所で区切って
部分文字列に分解する。
@var{separators}に一致するそれぞれの部分が分割箇所を定義する。
分割箇所のあいだにある部分文字列をリストにまとめ、これを値とする。
@var{separators}が@code{nil}である（つまり、省略する）と、
デフォルトは@code{"[ \f\t\n\r\v]+"}である。

@c For example,
たとえば、つぎのようになる。

@example
(split-string "Soup is good food" "o")
@result{} ("S" "up is g" "" "d f" "" "d")
(split-string "Soup is good food" "o+")
@result{} ("S" "up is g" "d f" "d")
@end example

@c When there is a match adjacent to the beginning or end of the string,
@c this does not cause a null string to appear at the beginning or end
@c of the list:
文字列の先頭や末尾で一致した場合には、
リストの先頭や末尾に空文字列は現れない。

@example
(split-string "out to moo" "o+")
@result{} ("ut t" " m")
@end example

@c Empty matches do count, when not adjacent to another match:
空の一致箇所は、それらが連続していない限り分割点になる。

@example
(split-string "Soup is good food" "o*")
@result{}("S" "u" "p" " " "i" "s" " " "g" "d" " " "f" "d")
(split-string "Nice doggy!" "")
@result{}("N" "i" "c" "e" " " "d" "o" "g" "g" "y" "!")
@end example
@end defun

@node Modifying Strings
@c @section Modifying Strings
@section 文字列の変更

@c   The most basic way to alter the contents of an existing string is with
@c @code{aset} (@pxref{Array Functions}).  @code{(aset @var{string}
@c @var{idx} @var{char})} stores @var{char} into @var{string} at index
@c @var{idx}.  Each character occupies one or more bytes, and if @var{char}
@c needs a different number of bytes from the character already present at
@c that index, @code{aset} signals an error.
既存の文字列の内容を変更するもっとも基本的な方法は、
@code{aset}（@pxref{Array Functions}）を使うことです。
@code{(aset @var{string} @var{idx} @var{char})}は、
@var{string}の添字@var{idx}位置に@var{char}を格納します。
各文字は1バイト以上を占めます。
@var{char}が必要とするバイト数が指定した添字位置の文字が占めるバイト数と
異なる場合には、@code{aset}はエラーを通知します。

@c   A more powerful function is @code{store-substring}:
より強力な関数は@code{store-substring}です。

@defun store-substring string idx obj
@tindex store-substring
@c This function alters part of the contents of the string @var{string}, by
@c storing @var{obj} starting at index @var{idx}.  The argument @var{obj}
@c may be either a character or a (smaller) string.
この関数は、文字列@var{string}の添字@var{idx}位置から始まる部分に@var{obj}を
格納することで、文字列@var{string}の内容の一部分を変更する。
引数@var{obj}は文字であるか（より小さな）文字列。

@c Since it is impossible to change the length of an existing string, it is
@c an error if @var{obj} doesn't fit within @var{string}'s actual length,
@c of if any new character requires a different number of bytes from the
@c character currently present at that point in @var{string}.
既存の文字列の長さを変更することは不可能なので、
新たな文字に必要なバイト数が@var{string}の当該箇所の文字のバイト数と
異なるなどして、
@var{obj}が@var{string}の実際の長さに収まらないときにはエラーである。
@end defun

@need 2000
@node Text Comparison
@c @section Comparison of Characters and Strings
@section 文字と文字列の比較
@c @cindex string equality
@cindex 文字列の同値性
@cindex 同値性、文字列

@defun char-equal character1 character2
@c This function returns @code{t} if the arguments represent the same
@c character, @code{nil} otherwise.  This function ignores differences
@c in case if @code{case-fold-search} is non-@code{nil}.
この関数は、引数が同じ文字を表していれば@code{t}を返し、
さもなければ@code{nil}を返す。
@code{case-fold-search}が@code{nil}以外であると、
この関数は大文字小文字の違いを区別しない。

@example
(char-equal ?x ?x)
     @result{} t
(let ((case-fold-search nil))
  (char-equal ?x ?X))
     @result{} nil
@end example
@end defun

@defun string= string1 string2
@c This function returns @code{t} if the characters of the two strings
@c match exactly; case is significant.
この関数は、2つの文字列の各文字が正確に一致すれば@code{t}を返す。
大文字小文字を区別する。

@example
(string= "abc" "abc")
     @result{} t
(string= "abc" "ABC")
     @result{} nil
(string= "ab" "ABC")
     @result{} nil
@end example

@c The function @code{string=} ignores the text properties of the two
@c strings.  When @code{equal} (@pxref{Equality Predicates}) compares two
@c strings, it uses @code{string=}.
関数@code{string=}は2つの文字列のテキスト属性を無視する。
@code{equal}（@pxref{Equality Predicates}）が2つの文字列を比較する際には、
@code{string=}を使う。

@c If the strings contain non-@sc{ASCII} characters, and one is unibyte
@c while the other is multibyte, then they cannot be equal.  @xref{Text
@c Representations}.
文字列に非@sc{ASCII}文字が含まれ、
一方がユニバイトであり他方がマルチバイトである場合、
それらが等しいことはない。
@pxref{Text Representations}。
@end defun

@defun string-equal string1 string2
@c @code{string-equal} is another name for @code{string=}.
@code{string-equal}は@code{string=}の別名。
@end defun

@c @cindex lexical comparison
@cindex 辞書式順の比較
@cindex 比較、辞書式順
@defun string< string1 string2
@c @c (findex string< causes problems for permuted index!!)
@c This function compares two strings a character at a time.  First it
@c scans both the strings at once to find the first pair of corresponding
@c characters that do not match.  If the lesser character of those two is
@c the character from @var{string1}, then @var{string1} is less, and this
@c function returns @code{t}.  If the lesser character is the one from
@c @var{string2}, then @var{string1} is greater, and this function returns
@c @code{nil}.  If the two strings match entirely, the value is @code{nil}.
この関数は2つの文字列を1文字ずつ比較する。
まず、文字列を走査し、対応する文字同士の対で一致しないものを探す。
そのような対の文字の小さいほうが@var{string1}の文字であるならば、
@var{string1}が小さく、この関数は@code{t}を返す。
文字の小さいほうが@var{string2}の文字であるならば、
@var{string1}が大きく、この関数は@code{nil}を返す。
2つの文字列が完全に一致する場合、値は@code{nil}である。

@c Pairs of characters are compared according to their character codes.
@c Keep in mind that lower case letters have higher numeric values in the
@c @sc{ASCII} character set than their upper case counterparts; digits and
@c many punctuation characters have a lower numeric value than upper case
@c letters.  An @sc{ASCII} character is less than any non-@sc{ASCII}
@c character; a unibyte non-@sc{ASCII} character is always less than any
@c multibyte non-@sc{ASCII} character (@pxref{Text Representations}).
文字の対は、それらの文字コードで比較する。
@sc{ASCII}文字集合では、小文字は大文字より大きな数値であり、
数字文字や多くの句読点文字は大文字より小さな数値であることに注意。
@sc{ASCII}文字はどんな非@sc{ASCII}文字よりも小さい。
ユニバイト非@sc{ASCII}文字はマルチバイト非@sc{ASCII}文字よりもつねに小さい。
（@pxref{Text Representations}）。

@example
@group
(string< "abc" "abd")
     @result{} t
(string< "abd" "abc")
     @result{} nil
(string< "123" "abc")
     @result{} t
@end group
@end example

@c When the strings have different lengths, and they match up to the
@c length of @var{string1}, then the result is @code{t}.  If they match up
@c to the length of @var{string2}, the result is @code{nil}.  A string of
@c no characters is less than any other string.
文字列の長さが異なり@var{string1}の長さまで一致する場合、
結果は@code{t}である。
@var{string2}の長さまで一致する場合、結果は@code{nil}である。
空文字列は他のどんな文字列よりも小さい。

@example
@group
(string< "" "abc")
     @result{} t
(string< "ab" "abc")
     @result{} t
(string< "abc" "")
     @result{} nil
(string< "abc" "ab")
     @result{} nil
(string< "" "")
     @result{} nil 
@end group
@end example
@end defun

@defun string-lessp string1 string2
@c @code{string-lessp} is another name for @code{string<}.
@code{string-lessp}は@code{string<}の別名。
@end defun

@defun compare-strings string1 start1 end1 string2 start2 end2 &optional ignore-case
@tindex compare-strings
@c This function compares a specified part of @var{string1} with a
@c specified part of @var{string2}.  The specified part of @var{string1}
@c runs from index @var{start1} up to index @var{end1} (default, the end of
@c the string).  The specified part of @var{string2} runs from index
@c @var{start2} up to index @var{end2} (default, the end of the string).
この関数は、@var{string1}の指定部分と@var{string2}の指定部分を比較する。
@var{string1}の指定部分は、
添字@var{start1}位置から始まり添字@var{end1}位置までである
（デフォルトは文字列の末尾）。
@var{string2}の指定部分は、
添字@var{start2}位置から始まり添字@var{end2}位置までである
（デフォルトは文字列の末尾）。

@c The strings are both converted to multibyte for the comparison
@c (@pxref{Text Representations}) so that a unibyte string can be equal to
@c a multibyte string.  If @var{ignore-case} is non-@code{nil}, then case
@c is ignored, so that upper case letters can be equal to lower case letters.
どちらの文字列も比較のためにマルチバイトに変換するので
（@pxref{Text Representations}）、
ユニバイト文字列とマルチバイトが等しくなる場合もある。
@var{ignore-case}が@code{nil}でなければ、大文字小文字を区別しないので、
大文字は小文字に等しくなる

@c If the specified portions of the two strings match, the value is
@c @code{t}.  Otherwise, the value is an integer which indicates how many
@c leading characters agree, and which string is less.  Its absolute value
@c is one plus the number of characters that agree at the beginning of the
@c two strings.  The sign is negative if @var{string1} (or its specified
@c portion) is less.
2つの文字列の指定部分が一致すれば、値は@code{t}。
さもなければ、値は何文字目までが一致してどちらの文字列が小さいかを示す。
その絶対値は、2つの文字列の始めから一致した文字の個数に1を加えたもの。
@var{string1}（の指定部分）が小さいならば符号は負になる。
@end defun

@defun assoc-ignore-case key alist
@tindex assoc-ignore-case
@c This function works like @code{assoc}, except that @var{key} must be a
@c string, and comparison is done using @code{compare-strings}.
@c Case differences are ignored in this comparison.
この関数は、@code{assoc}と同様に動作するが、
@var{key}は文字列である必要があり、
@code{compare-strings}を用いて比較する点が異なる。
大文字小文字を区別しないで比較する。
@end defun

@defun assoc-ignore-representation key alist
@tindex assoc-ignore-representation
@c This function works like @code{assoc}, except that @var{key} must be a
@c string, and comparison is done using @code{compare-strings}.
@c Case differences are significant.
この関数は、@code{assoc}と同様に動作するが、
@var{key}は文字列である必要があり、
@code{compare-strings}を用いて比較する点が異なる。
大文字小文字を区別して比較する。
@end defun

@c   See also @code{compare-buffer-substrings} in @ref{Comparing Text}, for
@c a way to compare text in buffers.  The function @code{string-match},
@c which matches a regular expression against a string, can be used
@c for a kind of string comparison; see @ref{Regexp Search}.
バッファ内のテキストを比較する
@ref{Comparing Text}の@code{compare-buffer-substrings}も参照してください。
文字列に対して正規表現の一致を取る関数@code{string-match}は、
ある種の文字列比較に使えます。
@xref{Regexp Search}。

@node String Conversion
@comment  node-name,  next,  previous,  up
@c @section Conversion of Characters and Strings
@section 文字と文字列の変換
@c @cindex conversion of strings
@cindex 文字と文字列の変換
@cindex 変換、文字と文字列

@c   This section describes functions for conversions between characters,
@c strings and integers.  @code{format} and @code{prin1-to-string}
@c (@pxref{Output Functions}) can also convert Lisp objects into strings.
@c @code{read-from-string} (@pxref{Input Functions}) can ``convert'' a
@c string representation of a Lisp object into an object.  The functions
@c @code{string-make-multibyte} and @code{string-make-unibyte} convert the
@c text representation of a string (@pxref{Converting Representations}).
本節では、文字や文字列と整数のあいだの変換関数について説明します。
@code{format}と@code{prin1-to-string}（@pxref{Output Functions}）は、
Lispオブジェクトを文字列に変換するために使えます。
@code{read-from-string}（@pxref{Input Functions}）は、
Lispオブジェクトの文字列表現をオブジェクトに『変換』できます。
関数@code{string-make-multibyte}と@code{string-make-unibyte}は、
文字列のテキスト表現を変換します（@pxref{Converting Representations}）。

@c   @xref{Documentation}, for functions that produce textual descriptions
@c of text characters and general input events
@c (@code{single-key-description} and @code{text-char-description}).  These
@c functions are used primarily for making help messages.
テキスト文字と一般の入力イベントのテキスト表現を生成する関数
（@code{single-key-description}と@code{text-char-description}）については、
@xref{Documentation}。
これらの関数は、主に、ヘルプメッセージの作成に使います。

@defun char-to-string character
@c @cindex character to string
@cindex 文字から文字列へ
@c This function returns a new string containing one character,
@c @var{character}.  This function is semi-obsolete because the function
@c @code{string} is more general.  @xref{Creating Strings}.
この関数は、1つの文字@var{character}だけを含む新たな文字列を返す。
関数@code{string}のほうがより汎用であるので、
この関数はほぼ廃れている。
@pxref{Creating Strings}。
@end defun

@defun string-to-char string
@c @cindex string to character
@cindex 文字列から文字へ
@c   This function returns the first character in @var{string}.  If the
@c string is empty, the function returns 0.  The value is also 0 when the
@c first character of @var{string} is the null character, @sc{ASCII} code
@c 0.
この関数は、@var{string}の先頭文字を返す。
文字列が空であると関数は0を返す。
文字列@var{string}の先頭文字が、@sc{ASCII}コードが0のナル文字であるときも、
値は0である。

@example
(string-to-char "ABC")
     @result{} 65
(string-to-char "xyz")
     @result{} 120
(string-to-char "")
     @result{} 0
(string-to-char "\000")
     @result{} 0
@end example

@c This function may be eliminated in the future if it does not seem useful
@c enough to retain.
この関数は、存続させるほど有用でなければ、将来、取り除くかもしれない。
@end defun

@defun number-to-string number
@c @cindex integer to string
@c @cindex integer to decimal
@cindex 整数から文字列へ
@cindex 整数の10進表記
@c This function returns a string consisting of the printed
@c representation of @var{number}, which may be an integer or a floating
@c point number.  The value starts with a sign if the argument is
@c negative.
この関数は、@var{number}の表示表現である文字列を返す。
@var{number}は整数か浮動小数点数。
引数が負であれば値の文字列は符号で始まる。

@example
(number-to-string 256)
     @result{} "256"
(number-to-string -23)
     @result{} "-23"
(number-to-string -23.5)
     @result{} "-23.5"
@end example

@c @cindex int-to-string
@c = タイポ？
@findex int-to-string
@c @code{int-to-string} is a semi-obsolete alias for this function.
@code{int-to-string}は、この関数のほぼ廃れている別名。

@c See also the function @code{format} in @ref{Formatting Strings}.
@ref{Formatting Strings}の@code{format}も参照。
@end defun

@defun string-to-number string &optional base
@c @cindex string to number
@cindex 文字列から数へ
@c This function returns the numeric value of the characters in
@c @var{string}.  If @var{base} is non-@code{nil}, integers are converted
@c in that base.  If @var{base} is @code{nil}, then base ten is used.
@c Floating point conversion always uses base ten; we have not implemented
@c other radices for floating point numbers, because that would be much
@c more work and does not seem useful.
この関数は、@var{string}内の文字群が表す数値を返す。
@var{base}が@code{nil}以外ならば、これを基数として整数に変換する。
@var{base}が@code{nil}ならば10を基数とする。
浮動小数点数の変換はつねに10を基数とする。
浮動小数点数に対しては別の基数を実装していない。
作業量も多くそのわりには有用とも思えないからである。

@c The parsing skips spaces and tabs at the beginning of @var{string}, then
@c reads as much of @var{string} as it can interpret as a number.  (On some
@c systems it ignores other whitespace at the beginning, not just spaces
@c and tabs.)  If the first character after the ignored whitespace is not a
@c digit or a plus or minus sign, this function returns 0.
解析するとき、@var{string}の先頭にある空白やタブは無視し、
数と解釈できる限りを@var{string}から読み取る。
（先頭の空白やタブ以外の他の白文字を無視するシステムもある。）
無視した白文字のあとの最初の文字が、数字文字、プラス記号、
マイナス記号でなければ、この関数は0を返す。

@example
(string-to-number "256")
     @result{} 256
(string-to-number "25 is a perfect square.")
     @result{} 25
(string-to-number "X256")
     @result{} 0
(string-to-number "-4.5")
     @result{} -4.5
@end example

@findex string-to-int
@c @code{string-to-int} is an obsolete alias for this function.
@code{string-to-int}はこの関数の廃れた別名。
@end defun

@c   Here are some other functions that can convert to or from a string:
文字列へ／から変換するその他の関数を以下にあげておきます。

@table @code
@item concat
@c @code{concat} can convert a vector or a list into a string.
@c @xref{Creating Strings}.
@code{concat}は、ベクトルやリストを文字列へ変換する。
@pxref{Creating Strings}。

@item vconcat
@c @code{vconcat} can convert a string into a vector.  @xref{Vector
@c Functions}.
@code{vconcat}は、文字列をベクトルへ変換する。
@pxref{Vector Functions}。

@item append
@c @code{append} can convert a string into a list.  @xref{Building Lists}.
@code{append}は、文字列をリストへ変換する。
@pxref{Building Lists}。
@end table

@node Formatting Strings
@comment  node-name,  next,  previous,  up
@c @section Formatting Strings
@section 文字列の書式付け
@c @cindex formatting strings
@c @cindex strings, formatting them
@cindex 文字列の書式付け
@cindex 書式付け、文字列

@c   @dfn{Formatting} means constructing a string by substitution of
@c computed values at various places in a constant string.  This string
@c controls how the other values are printed as well as where they appear;
@c it is called a @dfn{format string}.
@dfn{書式付け}（formatting）とは、
定数文字列内のさまざま部分を計算値で置き換えた文字列を作ることです。
この文字列は、文字列自体に加えて、
他の値をどのように表示するかも制御します。
この文字列を@dfn{書式付け文字列}（format string）と呼びます。

@c   Formatting is often useful for computing messages to be displayed.  In
@c fact, the functions @code{message} and @code{error} provide the same
@c formatting feature described here; they differ from @code{format} only
@c in how they use the result of formatting.
書式付けは、表示するメッセージを計算する場合に便利です。
実際、関数@code{message}と関数@code{error}には、
ここで説明するのと同じ書式付け機能があります。
それらと@code{format}との違いは、
書式付けした結果をどのように利用するかです。

@defun format string &rest objects
@c This function returns a new string that is made by copying
@c @var{string} and then replacing any format specification 
@c in the copy with encodings of the corresponding @var{objects}.  The
@c arguments @var{objects} are the computed values to be formatted.
この関数は、@var{string}をコピーし、
コピー内の書式付け指定を対応する@var{objects}の表現で置き換えた
新たな文字列を返す。
引数@var{objects}は書式付けすべき計算値である。
@end defun

@c @cindex @samp{%} in format
@c @cindex format specification
@cindex @samp{%}、書式付け
@cindex 書式付け指定
@c   A format specification is a sequence of characters beginning with a
@c @samp{%}.  Thus, if there is a @samp{%d} in @var{string}, the
@c @code{format} function replaces it with the printed representation of
@c one of the values to be formatted (one of the arguments @var{objects}).
@c For example:
書式付け指定は@samp{%}で始まる文字の列です。
したがって、@var{string}内に@samp{%d}があると、
関数@code{format}はそれを書式付けすべき値の1つ
（引数@var{objects}の1つ）の表示表現で置き換えます。
たとえば、つぎのとおりです。

@example
@group
(format "The value of fill-column is %d." fill-column)
     @result{} "The value of fill-column is 72."
@end group
@end example

@c   If @var{string} contains more than one format specification, the
@c format specifications correspond with successive values from
@c @var{objects}.  Thus, the first format specification in @var{string}
@c uses the first such value, the second format specification uses the
@c second such value, and so on.  Any extra format specifications (those
@c for which there are no corresponding values) cause unpredictable
@c behavior.  Any extra values to be formatted are ignored.
@var{string}に2個以上の書式付け指定がある場合、
書式付け指定は@var{objects}の後続の値に対応します。
つまり、@var{string}の最初の書式付け指定は最初の値を使い、
2番目の書式付け指定は2番目の値を使い、といった具合です。
（値が対応しない）余計な書式付け指定は、
予測不可能なふるまいを引き起こします。
余計な値は無視します。

@c   Certain format specifications require values of particular types.  If
@c you supply a value that doesn't fit the requirements, an error is
@c signaled.
特定の書式付け指定は、特定の型の値を必要とします。
要求に適合しない値を読者が指定するとエラーを通知します。

@c   Here is a table of valid format specifications:
有効な書式付け指定をつぎに示します。

@table @samp
@item %s
@c Replace the specification with the printed representation of the object,
@c made without quoting (that is, using @code{princ}, not
@c @code{prin1}---@pxref{Output Functions}).  Thus, strings are represented
@c by their contents alone, with no @samp{"} characters, and symbols appear
@c without @samp{\} characters.
書式付け指定をオブジェクトのクォートしない
（つまり、@code{prin1}ではなく@code{princ}を用いる。@pxref{Output Functions}）
表示表現で置き換える。
したがって、文字列は@samp{"}文字なしでその内容を表示し、
シンボルは@samp{\}文字なしで表示する。

@c If there is no corresponding object, the empty string is used.
対応するオブジェクトがなければ空文字列を使う。

@item %S
@c Replace the specification with the printed representation of the object,
@c made with quoting (that is, using @code{prin1}---@pxref{Output
@c Functions}).  Thus, strings are enclosed in @samp{"} characters, and
@c @samp{\} characters appear where necessary before special characters.
書式付け指定をオブジェクトのクォートした
（つまり、@code{prin1}を用いる。@pxref{Output Functions}）
表示表現で置き換える。
したがって、文字列は@samp{"}文字で囲んで表示し、
シンボルは特別な文字のまえには@samp{\}文字を付けて表示する。

@c If there is no corresponding object, the empty string is used.
対応するオブジェクトがなければ空文字列を使う。

@item %o
@c @cindex integer to octal
@cindex 整数の8進表記
@c Replace the specification with the base-eight representation of an
@c integer.
書式付け指定を整数の基数8の表示表現で置き換える。

@item %d
@c Replace the specification with the base-ten representation of an
@c integer.
書式付け指定を整数の基数10の表示表現で置き換える。

@item %x
@c @cindex integer to hexadecimal
@cindex 整数の16進表記
@c Replace the specification with the base-sixteen representation of an
@c integer.
書式付け指定を整数の基数16の表示表現で置き換える。

@item %c
@c Replace the specification with the character which is the value given.
書式付け指定を指定値の文字で置き換える。

@item %e
@c Replace the specification with the exponential notation for a floating
@c point number.
書式付け指定を浮動小数点数の指数表記で置き換える。

@item %f
@c Replace the specification with the decimal-point notation for a floating
@c point number.
書式付け指定を浮動小数点数の小数点表記で置き換える。

@item %g
@c Replace the specification with notation for a floating point number,
@c using either exponential notation or decimal-point notation, whichever
@c is shorter.
書式付け指定を浮動小数点数の指数表記か小数点表記のどちらか短いほうで
置き換える。

@item %%
@c A single @samp{%} is placed in the string.  This format specification is
@c unusual in that it does not use a value.  For example, @code{(format "%%
@c %d" 30)} returns @code{"% 30"}.
文字列に1個の@samp{%}を入れる。
この書式付け指定は、値を使わない点で特別である。
たとえば、@code{(format "%% %d" 30)}は@code{"% 30"}を返す。
@end table

@c   Any other format character results in an @samp{Invalid format
@c operation} error.
上記以外の書式付け文字は、エラー@samp{Invalid format operation}になります。

@c   Here are several examples:
例をいくつか示します。

@example
@group
(format "The name of this buffer is %s." (buffer-name))
     @result{} "The name of this buffer is strings.texi."

(format "The buffer object prints as %s." (current-buffer))
     @result{} "The buffer object prints as strings.texi."

(format "The octal value of %d is %o, 
         and the hex value is %x." 18 18 18)
     @result{} "The octal value of 18 is 22, 
         and the hex value is 12."
@end group
@end example

@c @cindex numeric prefix
@c @cindex field width
@c @cindex padding
@cindex 数前置子
@cindex フィールド幅
@cindex パディング
@c   All the specification characters allow an optional numeric prefix
@c between the @samp{%} and the character.  The optional numeric prefix
@c defines the minimum width for the object.  If the printed representation
@c of the object contains fewer characters than this, then it is padded.
@c The padding is on the left if the prefix is positive (or starts with
@c zero) and on the right if the prefix is negative.  The padding character
@c is normally a space, but if the numeric prefix starts with a zero, zeros
@c are used for padding.  Here are some examples of padding:
すべての書式付け文字には、@samp{%}とその文字のあいだに、
数前置子を指定できます。
省略可能な数前置子はオブジェクトの最小幅を指定します。
オブジェクトの表示表現がこの幅より小さい場合、パディングします。
数前置子が正ならば（あるいはゼロで始まれば）左側にパディングし、
数前置子が負ならば右側にパディングします。
パディング文字は、通常、空白ですが、
数前置子がゼロで始まれば、ゼロでパディングします。
パディングの例を示します。

@example
(format "%06d is padded on the left with zeros" 123)
     @result{} "000123 is padded on the left with zeros"

(format "%-6d is padded on the right" 123)
     @result{} "123    is padded on the right"
@end example

@c   @code{format} never truncates an object's printed representation, no
@c matter what width you specify.  Thus, you can use a numeric prefix to
@c specify a minimum spacing between columns with no risk of losing
@c information.
@code{format}は、どんな幅を指定しても、
オブジェクトの表示表現を切り詰めることはありません。
つまり、情報を失うことなく、数前置子を使って最小の桁幅を指定できます。

@c   In the following three examples, @samp{%7s} specifies a minimum width
@c of 7.  In the first case, the string inserted in place of @samp{%7s} has
@c only 3 letters, so 4 blank spaces are inserted for padding.  In the
@c second case, the string @code{"specification"} is 13 letters wide but is
@c not truncated.  In the third case, the padding is on the right.
つぎの3つの例において、@samp{%7s}は最小幅7を指定します。
最初の例では、@samp{%7s}に置き換わる文字列は3文字ですから、
パディングとして空白4個を挿入します。
2番目の例では、文字列@code{"specification"}は13文字幅ですが切り詰めません。
3番目の例では、右側にパディングします。

@smallexample 
@group
(format "The word `%7s' actually has %d letters in it."
        "foo" (length "foo"))
     @result{} "The word `    foo' actually has 3 letters in it."  
@end group

@group
(format "The word `%7s' actually has %d letters in it."
        "specification" (length "specification")) 
     @result{} "The word `specification' actually has 13 letters in it."  
@end group

@group
(format "The word `%-7s' actually has %d letters in it."
        "foo" (length "foo"))
     @result{} "The word `foo    ' actually has 3 letters in it."  
@end group
@end smallexample

@node Case Conversion
@comment node-name, next, previous, up 
@c @section Case Conversion in Lisp
@section Lispの大文字小文字変換
@c @cindex upper case 
@c @cindex lower case 
@c @cindex character case 
@c @cindex case conversion in Lisp
@cindex 大文字
@cindex 小文字
@cindex 大文字小文字
@cindex Lispの大文字小文字変換

@c   The character case functions change the case of single characters or
@c of the contents of strings.  The functions normally convert only
@c alphabetic characters (the letters @samp{A} through @samp{Z} and
@c @samp{a} through @samp{z}, as well as non-ASCII letters); other
@c characters are not altered.  (You can specify a different case
@c conversion mapping by specifying a case table---@pxref{Case Tables}.)
大文字小文字変換関数は、1文字や文字列内の大文字小文字を変更します。
関数は、通常、アルファベット文字
（非ASCII文字のアルファベットに加えて、
@samp{A}から@samp{Z}と@samp{a}から@samp{z}）だけを変換します。
それ以外の文字は変わりません。
（大文字小文字テーブルを指定して異なる大文字小文字変換を指定できる。
@pxref{Case Tables}）

@c   These functions do not modify the strings that are passed to them as
@c arguments.
これらの関数は、引数として渡した文字列は変更しません。

@c   The examples below use the characters @samp{X} and @samp{x} which have
@c @sc{ASCII} codes 88 and 120 respectively.
以下の例では、文字@samp{X}と@samp{x}を使います。
@sc{ASCII}コードは、それぞれ、88と120です。

@defun downcase string-or-char
@c This function converts a character or a string to lower case.
この関数は、文字や文字列を小文字に変換する。

@c When the argument to @code{downcase} is a string, the function creates
@c and returns a new string in which each letter in the argument that is
@c upper case is converted to lower case.  When the argument to
@c @code{downcase} is a character, @code{downcase} returns the
@c corresponding lower case character.  This value is an integer.  If the
@c original character is lower case, or is not a letter, then the value
@c equals the original character.
@code{downcase}の引数が文字列であると、
この関数は、引数の各文字の大文字を小文字に変換した新たな文字列を作成する。
@code{downcase}の引数が文字であると、
@code{downcase}は対応する小文字を返す。
この値は整数である。
もとの文字が小文字であったりアルファベット文字でなければ、
値はもとの文字に等しい。

@example
(downcase "The cat in the hat")
     @result{} "the cat in the hat"

(downcase ?X)
     @result{} 120
@end example
@end defun

@defun upcase string-or-char
@c This function converts a character or a string to upper case.
この関数は、文字や文字列を大文字に変換する。

@c When the argument to @code{upcase} is a string, the function creates
@c and returns a new string in which each letter in the argument that is
@c lower case is converted to upper case.
@code{upcase}の引数が文字列であると、
この関数は、引数の各文字の小文字を大文字に変換した新たな文字列を作成する。

@c When the argument to @code{upcase} is a character, @code{upcase}
@c returns the corresponding upper case character.  This value is an integer.
@c If the original character is upper case, or is not a letter, then the
@c value equals the original character.
@code{upcase}の引数が文字であると、
@code{upcase}は対応する大文字を返す。
この値は整数である。
もとの文字が大文字であったりアルファベット文字でなければ、
値はもとの文字に等しい。

@example
(upcase "The cat in the hat")
     @result{} "THE CAT IN THE HAT"

(upcase ?x)
     @result{} 88
@end example
@end defun

@defun capitalize string-or-char
@c @cindex capitalization
@cindex キャピタライズ（先頭文字だけを大文字にする）
@c This function capitalizes strings or characters.  If
@c @var{string-or-char} is a string, the function creates and returns a new
@c string, whose contents are a copy of @var{string-or-char} in which each
@c word has been capitalized.  This means that the first character of each
@c word is converted to upper case, and the rest are converted to lower
@c case.
この関数は、文字列や文字をキャピタライズ（先頭文字だけを大文字に）する。
@var{string-or-char}が文字列ならば、
この関数は、@var{string-or-char}のコピーの各単語をキャピタライズしたものを
内容とする新たな文字列を作成して返す。
つまり、各単語の先頭文字だけを大文字にして残りを小文字にする。

@c The definition of a word is any sequence of consecutive characters that
@c are assigned to the word constituent syntax class in the current syntax
@c table (@xref{Syntax Class Table}).
単語の定義は、現在の構文テーブル（@xref{Syntax Class Table}）において
単語構成文字に分類された文字が連続した列である。

@c When the argument to @code{capitalize} is a character, @code{capitalize}
@c has the same result as @code{upcase}.
@code{capitalize}の引数が文字の場合には、
@code{capitalize}は@code{upcase}の結果と同じである。

@example
(capitalize "The cat in the hat")
     @result{} "The Cat In The Hat"

(capitalize "THE 77TH-HATTED CAT")
     @result{} "The 77th-Hatted Cat"

@group
(capitalize ?x)
     @result{} 88
@end group
@end example
@end defun

@defun upcase-initials string
@c This function capitalizes the initials of the words in @var{string}.
@c without altering any letters other than the initials.  It returns a new
@c string whose contents are a copy of @var{string}, in which each word has
@c been converted to upper case.
この関数は、@var{string}内の単語の先頭文字だけを大文字にし、
先頭文字以外の文字は変更しない。
この関数は、@var{string}のコピーの各単語の先頭文字を大文字に変換したものを
内容とする新たな文字列を返す。

@c The definition of a word is any sequence of consecutive characters that
@c are assigned to the word constituent syntax class in the current syntax
@c table (@xref{Syntax Class Table}).
単語の定義は、現在の構文テーブル（@xref{Syntax Class Table}）において
単語構成文字に分類された文字が連続した列である。

@example
@group
(upcase-initials "The CAT in the hAt")
     @result{} "The CAT In The HAt"
@end group
@end example
@end defun

@c   @xref{Text Comparison}, for functions that compare strings; some of
@c them ignore case differences, or can optionally ignore case differences.
文字列を比較する関数については、@xref{Text Comparison}。
これらは、大文字小文字を区別しないものもあれば、
場合によって大文字小文字を区別しないものもある。

@node Case Tables
@c @section The Case Table
@section 大文字小文字テーブル

@c   You can customize case conversion by installing a special @dfn{case
@c table}.  A case table specifies the mapping between upper case and lower
@c case letters.  It affects both the case conversion functions for Lisp
@c objects (see the previous section) and those that apply to text in the
@c buffer (@pxref{Case Changes}).  Each buffer has a case table; there is
@c also a standard case table which is used to initialize the case table
@c of new buffers.
特別な@dfn{大文字小文字テーブル}（case table）をインストールすれば、
大文字小文字変換をカスタマイズできます。
大文字小文字テーブルは、大文字と小文字の対応関係を指定します。
このテーブルは、Lispオブジェクトの大文字小文字変換関数（前節参照）と
バッファ内のテキストに作用する大文字小文字変換関数（@pxref{Case Changes}）の
両方に影響します。
各バッファごとに大文字小文字テーブルがあります。
新たなバッファの大文字小文字テーブルを初期化するために使う
標準の大文字小文字テーブルもあります。

@c   A case table is a char-table (@pxref{Char-Tables}) whose subtype is
@c @code{case-table}.  This char-table maps each character into the
@c corresponding lower case character.  It has three extra slots, which
@c hold related tables:
大文字小文字テーブルは、サブタイプが@code{case-table}である
文字テーブル（@pxref{Char-Tables}）です。
この文字テーブルは、各文字を対応する小文字に対応付けます。
これには3つの追加スロットがあり、関連するテーブルを保持します。

@table @var
@item upcase
@c The upcase table maps each character into the corresponding upper
@c case character.
upcase（大文字）テーブルは、各文字を対応する大文字に対応付ける。
@item canonicalize
@c The canonicalize table maps all of a set of case-related characters
@c into a particular member of that set.
canonicalize（正則）テーブルは大文字小文字に関連する1組の文字群を
その文字群の特定のメンバに対応付ける。
@item equivalences
@c The equivalences table maps each one of a set of case-related characters
@c into the next character in that set.
equivalences（同値）テーブルは、大文字小文字に関連する1組の文字群の各要素を
その文字群内のつぎの文字に対応付ける。
@end table

@c   In simple cases, all you need to specify is the mapping to lower-case;
@c the three related tables will be calculated automatically from that one.
単純な場合、必要なことは、小文字への対応付けを指定するだけです。
関連する3つのテーブルはこの対応付けから自動的に計算されます。

@c   For some languages, upper and lower case letters are not in one-to-one
@c correspondence.  There may be two different lower case letters with the
@c same upper case equivalent.  In these cases, you need to specify the
@c maps for both lower case and upper case.
言語によっては、大文字と小文字の対応関係が1対1でないことがあります。
2つの異なる小文字が同じ大文字に対応することがあります。
このような場合、大文字から小文字への対応付けと、
小文字から大文字への対応付けの両方を指定する必要があります。

@c   The extra table @var{canonicalize} maps each character to a canonical
@c equivalent; any two characters that are related by case-conversion have
@c the same canonical equivalent character.  For example, since @samp{a}
@c and @samp{A} are related by case-conversion, they should have the same
@c canonical equivalent character (which should be either @samp{a} for both
@c of them, or @samp{A} for both of them).
追加のテーブル@var{canonicalize}（正則）は、各文字を正則文字に対応付けます。
2つの任意の文字が大文字小文字変換で関連付けられている場合、
その2つの文字は同一の正則文字を持ちます。
たとえば、@samp{a}と@samp{A}は、大文字小文字変換で関連付けられているので、
これらは同一の正則文字を持つはずです
（両方の文字に対して@samp{a}であるか、両方の文字に対して@samp{A}である）。

@c   The extra table @var{equivalences} is a map that cyclicly permutes
@c each equivalence class (of characters with the same canonical
@c equivalent).  (For ordinary @sc{ASCII}, this would map @samp{a} into
@c @samp{A} and @samp{A} into @samp{a}, and likewise for each set of
@c equivalent characters.)
追加のテーブル@var{equivalences}（同値）は、
同じ正則クラス（同一の正則文字を持つ文字群）の文字を巡回して対応付けます。
（普通の@sc{ASCII}では、@samp{a}を@samp{A}に対応付け、
@samp{A}を@samp{a}に対応付ける。
各正則クラスについても同様。）

@c   When you construct a case table, you can provide @code{nil} for
@c @var{canonicalize}; then Emacs fills in this slot from the lower case
@c and upper case mappings.  You can also provide @code{nil} for
@c @var{equivalences}; then Emacs fills in this slot from
@c @var{canonicalize}.  In a case table that is actually in use, those
@c components are non-@code{nil}.  Do not try to specify @var{equivalences}
@c without also specifying @var{canonicalize}.
大文字小文字テーブルを作成するときには、
@var{canonicalize}（正則）には@code{nil}を指定できます。
そうすると、Emacsはこのスロットを小文字と大文字の対応付けから埋めます。
@var{equivalences}（同値）にも@code{nil}を指定できます。
そうすると、Emacsはこのスロットを@var{canonicalize}（正則）から埋めます。
実際に使用している大文字小文字テーブルでは、
これらの要素は@code{nil}以外です。
@var{canonicalize}（正則）を指定せずに
@var{equivalences}（同値）を指定しないでください、

@c   Here are the functions for working with case tables:
つぎに、大文字小文字テーブルを操作する関数を示します。

@defun case-table-p object
@c This predicate returns non-@code{nil} if @var{object} is a valid case
@c table.
この述語は、@var{object}が正しい
大文字小文字テーブルならば@code{nil}以外を返す。
@end defun

@defun set-standard-case-table table
@c This function makes @var{table} the standard case table, so that it will
@c be used in any buffers created subsequently.
この関数は、@var{table}を標準の大文字小文字テーブルとし、
これ以降に作成する任意のバッファに使用できるようにする。
@end defun

@defun standard-case-table
@c This returns the standard case table.
これは、標準の大文字小文字テーブルを返す。
@end defun

@defun current-case-table
@c This function returns the current buffer's case table.
この関数は、カレントバッファの大文字小文字テーブルを返す。
@end defun

@defun set-case-table table
@c This sets the current buffer's case table to @var{table}.
これは、カレントバッファの大文字小文字テーブルを@var{table}とする。
@end defun

@c   The following three functions are convenient subroutines for packages
@c that define non-@sc{ASCII} character sets.  They modify the specified
@c case table @var{case-table}; they also modify the standard syntax table.
@c @xref{Syntax Tables}.  Normally you would use these functions to change
@c the standard case table.
以下の3つ関数は、非@sc{ASCII}文字集合を定義するパッケージ向けの
便利なサブルーティンです。
これらは、指定した大文字小文字テーブル@var{case-table}を変更します。
さらに、標準の構文テーブルも変更します。
@xref{Syntax Tables}。
普通、標準の大文字小文字テーブルを変更するためにこれらの関数を使います。

@defun set-case-syntax-pair uc lc case-table
@c This function specifies a pair of corresponding letters, one upper case
@c and one lower case.
この関数は対応する大文字と小文字を指定する。
@end defun

@defun set-case-syntax-delims l r case-table
@c This function makes characters @var{l} and @var{r} a matching pair of
@c case-invariant delimiters.
この関数は、文字@var{l}と@var{r}を
大文字小文字不変区切りの対応する対にする。
@end defun

@defun set-case-syntax char syntax case-table
@c This function makes @var{char} case-invariant, with syntax
@c @var{syntax}.
この関数は、@var{char}を構文@var{syntax}の大文字小文字不変にする。
@end defun

@c @deffn Command describe-buffer-case-table
@deffn コマンド describe-buffer-case-table
@c This command displays a description of the contents of the current
@c buffer's case table.
このコマンドは、カレントバッファの大文字小文字テーブルの内容を記述する。
@end deffn
