@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2015 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Searching and Matching
@chapter 探索と一致
@cindex 探索

GNU Emacsにはバッファから指定したテキストを探す方法が2つあります。
文字列そのものを正確に探索するのと正規表現の探索です。
正規表現の探索のあとでは、
正規表現全体やそのさまざまな部分に一致したテキストを表す
@dfn{マッチデータ}（match data）を調べることができます。

@menu
* String Search::         Search for an exact match.
* Searching and Case::    Case-independent or case-significant searching.
* Regular Expressions::   Describing classes of strings.
* Regexp Search::         Searching for a match for a regexp.
* POSIX Regexps::         Searching POSIX-style for the longest match.
* Match Data::            Finding out which part of the text matched,
                            after a string or regexp search.
* Search and Replace::    Commands that loop, searching and replacing.
* Standard Regexps::      Useful regexps for finding sentences, pages,...
@end menu

@samp{skip-chars@dots{}}などの関数もある種の探索を行います。
@xref{Skipping Characters}。
To search for changes in character
properties, see @ref{Property Search}.

@node String Search
@section 文字列の探索
@cindex 文字列探索

これらは、バッファ内のテキストを探索するための基本関数です。
これらはプログラムで使うことを意図していますが、
対話的に呼び出すこともできます。
その場合、探索文字列を問い合わせてきますが、
@var{limit}と@var{noerror}は@code{nil}に、@var{repeat}は1に設定されます。

これらの探索関数は、バッファがマルチバイトであると
探索文字列をマルチバイトに変換します。
バッファがユニバイトであると探索文字列をユニバイトに変換します。
@xref{Text Representations}。

@deffn Command search-forward string &optional limit noerror repeat
この関数は、ポイントから前方へ向けて文字列@var{string}に
ちょうど一致するものを探す。
それに成功すれば、ポイントをみつけた出現箇所の末尾に移動し、
ポイントの新たな値を返す。
一致がみつからなければ、戻り値と副作用は@var{noerror}に依存する（下記参照）。

つぎの例では、ポイントは始めは行頭にある。
そして@code{(search-forward "fox")}は@samp{fox}の最後の文字のうしろに
ポイントを移動する。

@example
@group
---------- Buffer: foo ----------
@point{}The quick brown fox jumped over the lazy dog.
---------- Buffer: foo ----------
@end group

@group
(search-forward "fox")
     @result{} 20

---------- Buffer: foo ----------
The quick brown fox@point{} jumped over the lazy dog.
---------- Buffer: foo ----------
@end group
@end example

引数@var{limit}は探索の上限を指定する。
（カレントバッファ内の位置であること。）
その位置を越える箇所での一致は受け入れない。
@var{limit}を省略したり@code{nil}であると、
デフォルトは、バッファの参照可能部分の末尾である。

@kindex search-failed
探索に失敗した場合の動作は、@var{noerror}の値に依存する。
@var{noerror}が@code{nil}ならば、
エラー@code{search-failed}を通知する。
@var{noerror}が@code{t}であると、
@code{search-forward}は@code{nil}を返しなにもしない。
@var{noerror}が@code{nil}でも@code{t}でもないと、
@code{search-forward}はポイントを上限位置へ移動して@code{nil}を返す。
@c I see no prospect of this ever changing, and frankly the current
@c behavior seems better, so there seems no need to mention this.
@ignore
（この場合にもポイントの新たな値を返すほうが一貫性があるが、
値@code{nil}に依存しているプログラムがある。）
@end ignore

The argument @var{noerror} only affects valid searches which fail to
find a match.  Invalid arguments cause errors regardless of
@var{noerror}.

@var{repeat}が正の整数@var{n}ならば、
@var{n}回、探索を繰り返す（一致箇所の末尾を新たな探索の開始位置とする）。
連続してこれらの探索に成功すると関数は成功し、
ポイントを移動してその新たな値を返す。
さもなければ探索は失敗である。
Otherwise the search fails, with results depending on the
value of @var{noerror}, as described above.  If @var{repeat} is a
negative number -@var{n}, it serves as a repeat count of @var{n} for a
search in the opposite (backward) direction.
@end deffn

@deffn Command search-backward string &optional limit noerror repeat
この関数は、ポイントから後方へ向けて@var{string}を探索する。
@code{search-forward}と同様であるが、後方へ向けて探索し
一致箇所の先頭にポイントを置く点が異なる。
@end deffn

@deffn Command word-search-forward string &optional limit noerror repeat
この関数は、ポイントから前方へ向けて@var{string}に一致する『単語』を探索する。
一致をみつけると、一致箇所の末尾にポイントを設定し
ポイントの新たな値を返す。

単語の一致では、@var{string}を単語の列とみなし、
それらを区切る句読点は無視する。
バッファ内の同じ単語の列を探す。
バッファ内の各単語は別々になっている必要があるが
（単語@samp{ball}を探索すると単語@samp{balls}には一致しない）、
句読点や空白の詳細は無視される
（@samp{ball
boy}を探索すると@samp{ball.  Boy!}に一致する）。

つぎの例では、ポイントは始めはバッファの先頭にある。
探索するとポイントは@samp{y}と@samp{!}のあいだに移動する。

@example
@group
---------- Buffer: foo ----------
@point{}He said "Please!  Find
the ball boy!"
---------- Buffer: foo ----------
@end group

@group
(word-search-forward "Please find the ball, boy.")
     @result{} 35

---------- Buffer: foo ----------
He said "Please!  Find
the ball boy@point{}!"
---------- Buffer: foo ----------
@end group
@end example

@var{limit}が@code{nil}以外（カレントバッファ内の位置）であると、
それは探索の上限を指定する。
みつかった一致箇所はその位置を越えてはならない。

@var{noerror}が@code{nil}であると、
探索に失敗すると@code{word-search-forward}はエラーを通知する。
@var{noerror}が@code{t}であると、
エラーを通知するかわりに@code{nil}を返す。
@var{noerror}が@code{nil}でも@code{t}でもないと、
ポイントを@var{limit}（あるいはバッファの末尾）へ移動して@code{nil}を返す。

@var{repeat}が@code{nil}以外であると、
その回数だけ探索を繰り返す。
ポイントは最後の一致箇所の末尾へ置かれる。

@findex word-search-regexp
Internally, @code{word-search-forward} and related functions use the
function @code{word-search-regexp} to convert @var{string} to a
regular expression that ignores punctuation.
@end deffn

@deffn Command word-search-forward-lax string &optional limit noerror repeat
This command is identical to @code{word-search-forward}, except that
the beginning or the end of @var{string} need not match a word
boundary, unless @var{string} begins or ends in whitespace.
For instance, searching for @samp{ball boy} matches @samp{ball boyee},
but does not match @samp{balls boy}.
@end deffn

@deffn Command word-search-backward string &optional limit noerror repeat
This function searches backward from point for a word match to
@var{string}.
この関数は@code{word-search-forward}と同様であるが、
後方へ向けて探索し、通常は一致箇所の先頭にポイントを置く点が異なる。
@end deffn

@deffn Command word-search-backward-lax string &optional limit noerror repeat
This command is identical to @code{word-search-backward}, except that
the beginning or the end of @var{string} need not match a word
boundary, unless @var{string} begins or ends in whitespace.
@end deffn

@node Searching and Case
@section 探索と大文字小文字
@cindex 探索と大文字小文字

デフォルトでは、Emacsの探索は探索対象テキストの大文字小文字を区別しません。
@samp{FOO}を探す指定を行うと、
@samp{Foo}や@samp{foo}にも一致するとみなします。
これは、正規表現にも適用されます。
したがって、@samp{[aB]}は、@samp{a}や@samp{A}や@samp{b}や@samp{B}に一致します。

この機能を望まないときには、
変数@code{case-fold-search}に@code{nil}を設定します。
すると、すべての文字は大文字小文字を保ってそのとおりに一致します。
これはバッファローカルな変数ですから、
変数を変更してもカレントバッファだけに影響します。（@xref{Intro to
Buffer-Local}.）
Alternatively, you may change the default value.
In Lisp code, you will more typically use @code{let} to bind
@code{case-fold-search} to the desired value.

ユーザーレベルのインクリメンタルサーチ機能では、
大文字小文字の区別は異なった扱い方をします。
小英文字を与えるとその大文字にも一致しますが、
大英文字を与えると大文字のみに一致します。
しかし、これはLispコードで使用している探索関数には
まったく関係ありません。
@xref{Incremental Search,,, emacs,
The GNU Emacs Manual}.

@defopt case-fold-search
このバッファローカルな変数は、
大文字小文字を区別して探索するかどうかを決定する。
変数が@code{nil}であると大文字小文字を区別する。
さもなければ大文字小文字を区別しない。
@end defopt

@defopt case-replace
この変数は、置換関数が大文字小文字を保存するかどうかを決定する。
変数が@code{nil}であると、置換テキストをそのまま使うことを意味する。
@code{nil}以外の値であると、置換対象のテキストに応じて
置換テキストの大文字小文字を変換することを意味する。

この変数が実際に効果を発揮するのは関数@code{replace-match}においてである。
@xref{Replacing Match}。
@end defopt

@node Regular Expressions
@section 正規表現
@cindex 正規表現
@cindex regexp（正規表現）

@dfn{正規表現}（regular expression、略して@dfn{regexp}）は、
文字列の（無限の可能性もある）集合を表すパターンです。
正規表現への一致を探すことは、非常に強力な操作です。
本節では、正規表現の書き方を説明します。
続く節では、それらを探索する方法を説明します。

@findex re-builder
@cindex regular expressions, developing
  For interactive development of regular expressions, you
can use the @kbd{M-x re-builder} command.  It provides a convenient
interface for creating regular expressions, by giving immediate visual
feedback in a separate buffer.  As you edit the regexp, all its
matches in the target buffer are highlighted.  Each parenthesized
sub-expression of the regexp is shown in a distinct face, which makes
it easier to verify even very complex regexps.

@menu
* Syntax of Regexps::       Rules for writing regular expressions.
* Regexp Example::          Illustrates regular expression syntax.
* Regexp Functions::        Functions for operating on regular expressions.
@end menu

@node Syntax of Regexps
@subsection 正規表現の構文
@cindex regexp syntax
@cindex syntax of regular expressions

正規表現では、数個の文字が特別な構成であり、残りは@dfn{普通}です。
普通の文字は、その文字だけに一致する単純な正規表現です。
特別な文字は、@samp{.}、@samp{*}、@samp{+}、
@samp{?}、@samp{[}、@samp{^}、@samp{$}、@samp{\}であり、
将来新たな文字が定義されることはありません。
The character
@samp{]} is special if it ends a character alternative (see later).
The character @samp{-} is special inside a character alternative.  A
@samp{[:} and balancing @samp{:]} enclose a character class inside a
character alternative.
正規表現に現れるこれら以外の文字は、
まえに@samp{\}がない限り普通の文字です。

たとえば、@samp{f}は特別な文字ではないので普通の文字です。
ですから、@samp{f}は文字列@samp{f}だけに一致する正規表現です。
（これは文字列@samp{fg}にはマッチ@emph{しません}が、
その@emph{一部}にはマッチします。）
同様に、@samp{o}は@samp{o}だけに一致する正規表現です。

任意の2つの正規表現@var{a}と@var{b}を連結できます。
その結果は、@var{a}が文字列の始めの部分に一致し、かつ、
@var{b}がその文字列の残りに一致するときにその文字列に一致する
正規表現になります。

簡単な例として、正規表現 @samp{f}と@samp{o}を連結して
正規表現@samp{fo}を得られます。
これは文字列@samp{fo}だけに一致します。
これは明らかですね。
より強力なことをするには、特別な文字の1つを使う必要があります。
それらの一覧を以下に示します。

@menu
* Regexp Special::      Special characters in regular expressions.
* Char Classes::        Character classes used in regular expressions.
* Regexp Backslash::    Backslash-sequences in regular expressions.
@end menu

@node Regexp Special
@subsubsection Special Characters in Regular Expressions
@cindex regexp, special characters in

  Here is a list of the characters that are special in a regular
expression.

@need 800
@table @asis
@item @samp{.}@: @r{（ピリオド）}
@cindex @samp{.}、正規表現
特別な文字であり、改行以外の任意の1文字に一致する。
連結を使って@samp{a.b}のような正規表現を作れる。
これは、@samp{a}で始まり@samp{b}で終る任意の3文字の文字列に一致する。

@item @samp{*}
@cindex @samp{*}、正規表現
単独では構成要素ではない。
直前の正規表現を可能な限り反復することを意味する後置演算子である。
すなわち、@samp{o*}は（@samp{o}が存在しない場合も含めて）
任意個の@samp{o}に一致する。

@samp{*}はつねに先行する@emph{最小}の正規表現に適用される。
したがって、@samp{fo*}は@samp{fo}を繰り返すのではなく、
@samp{o}を繰り返す。
この正規表現は@samp{f}、@samp{fo}、@samp{foo}などに一致する。

@cindex backtracking and regular expressions
@samp{*}を用いた構成の一致を処理するときには、
ただちに得られる限りの反復回数に展開される。
そうしてから、残りのパターンを処理する。
一致に失敗するとバックトラック（後戻り）が発生して、
@samp{*}を用いた構成の反復回数を減らして
パターンの残りの部分が一致できるようにする。
たとえば、文字列@samp{caaar}に対して
@samp{ca*ar}を一致させることを考えてみる。
始めに、@samp{a*}を3つの@samp{a}すべてに一致させようとする。
しかし、残りのパターンが@samp{ar}なのに@samp{r}しか残っていないため、
この試みは失敗する。
そこで、つぎは@samp{a*}を@samp{a}2つだけに一致させる。
こうすると、残りの正規表現も正しく一致する。

@strong{警告:} 入れ子にした反復演算子がバックトラックのループを指定する場合、
それはとても遅くなる。
たとえば、正規表現@samp{\(x+y*\)*a}を
@samp{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxz}の列に一致させると
最終的に失敗するまで何時間も費してしまう。
Emacsは@samp{x}をグループに分ける各方法を
すべて試してからでないとそれらが一致しないことを結論できないからである。
Even worse, @samp{\(x*\)*} can match the null string in infinitely
many ways, so it causes an infinite loop.
この問題を避けるために、
入れ子になった繰り返しを注意深く調べること。

@item @samp{+}
@cindex @samp{+}、正規表現
@samp{*}に似た後置演算子だが、
直前の正規表現に1回以上一致する必要がある。
たとえば、@samp{ca+r}は、文字列@samp{car}や@samp{caaaar}には一致するが、
文字列@samp{cr}には一致ない。
一方、@samp{ca*r}の場合は、上記の3つすべてに一致する。

@item @samp{?}
@cindex @samp{?}、正規表現
@samp{*}に似た後置演算子だが、
直前の正規表現に1回だけ一致するか、あるいは、1回も一致しない。
たとえば、@samp{ca?r}は、@samp{car}や@samp{cr}に一致するが、
他のものには一致しない。

@item @samp{*?}, @samp{+?}, @samp{??}
@cindex non-greedy repetition characters in regexp
These are ``non-greedy'' variants of the operators @samp{*}, @samp{+}
and @samp{?}.  Where those operators match the largest possible
substring (consistent with matching the entire containing expression),
the non-greedy variants match the smallest possible substring
(consistent with matching the entire containing expression).

For example, the regular expression @samp{c[ad]*a} when applied to the
string @samp{cdaaada} matches the whole string; but the regular
expression @samp{c[ad]*?a}, applied to that same string, matches just
@samp{cda}.  (The smallest possible match here for @samp{[ad]*?} that
permits the whole expression to match is @samp{d}.)

@item @samp{[ @dots{} ]}
@cindex 文字選択（正規表現）
@cindex @samp{[}、正規表現
@cindex @samp{]}、正規表現
@samp{[}で始まり@samp{]}で終る@dfn{文字選択}を表す。
もっとも単純な場合は、
この2つの中括弧のあいだにある文字の1つ1つがこの文字選択に一致する。

したがって、@samp{[ad]}は、@samp{a}1文字か@samp{d}1文字のどちらにも一致する。
@samp{[ad]*}は、@samp{a}と@samp{d}だけから成る
（空の文字列を含む）任意の文字列に一致する。
このことから、@samp{c[ad]*r}は、
@samp{cr}、@samp{car}、@samp{cdr}、@samp{caddaar}などに一致することがわかる。

文字選択には、文字範囲の指定を含めることもでき、
始めの文字と終りの文字のあいだに@samp{-}を書く。
つまり、@samp{[a-z]}はすべての@acronym{ASCII}小英文字に一致する。
範囲指定と個々の文字を自由に織り混ぜてよく、
@samp{[a-z$%.]}のように書ける。
これは、任意の@acronym{ASCII}小英文字、@samp{$}、@samp{%}、ピリオドに一致する。

If @code{case-fold-search} is non-@code{nil}, @samp{[a-z]} also
matches upper-case letters.  Note that a range like @samp{[a-z]} is
not affected by the locale's collation sequence, it always represents
a sequence in @acronym{ASCII} order.
@c This wasn't obvious to me, since, e.g., the grep manual "Character
@c Classes and Bracket Expressions" specifically notes the opposite
@c behavior.  But by experiment Emacs seems unaffected by LC_COLLATE
@c in this regard.

正規表現の普通の特別な文字は、文字選択の内側では特別ではないことに注意。
文字選択の内側では、まったく別の文字の集まり、
@samp{]}、@samp{-}、@samp{^}が特別である。

文字選択に@samp{]}を含めるには、
これを最初の文字として指定する必要がある。
たとえば、@samp{[]a]}は、@samp{]}や@samp{a}に一致する。
@samp{-}を含めるには、@samp{-}を文字選択の最初の文字か
最後の文字として書くか、範囲指定のあとに置く。
したがって、@samp{[]-]}は、@samp{]}と@samp{-}の両方に一致する。
(As explained below, you cannot
use @samp{\]} to include a @samp{]} inside a character alternative,
since @samp{\} is not special there.)

文字選択に@samp{^}を含めるには、これを文字選択の2番目以降に置く。

@c What if it starts with a multibyte and ends with a unibyte?
@c That doesn't seem to match anything...?
If a range starts with a unibyte character @var{c} and ends with a
multibyte character @var{c2}, the range is divided into two parts: one
spans the unibyte characters @samp{@var{c}..?\377}, the other the
multibyte characters @samp{@var{c1}..@var{c2}}, where @var{c1} is the
first character of the charset to which @var{c2} belongs.

A character alternative can also specify named character classes
(@pxref{Char Classes}).  This is a POSIX feature.  For example,
@samp{[[:ascii:]]} matches any @acronym{ASCII} character.
Using a character class is equivalent to mentioning each of the
characters in that class; but the latter is not feasible in practice,
since some classes include thousands of different characters.

@item @samp{[^ @dots{} ]}
@cindex @samp{^}、正規表現
@samp{[^}は@dfn{文字選択の補集合}の始まりを意味し、
指定した文字を除く任意の文字に一致する。
すなわち、@samp{[^a-z0-9A-Z]}は、
英文字と数字文字を@emph{除く}すべての文字に一致する。

@samp{^}は文字選択の先頭になければ文字選択では特別な意味を持たない。
@samp{^}に続く文字は先頭にあるものとして扱われる
（いいかえれば、ここでは@samp{-}や@samp{]}は特別な意味を持たない）。

文字選択の補集合は、一致しない文字として改行を指定しない限り、
改行にも一致する。
この点は、@code{grep}のようなプログラムでの正規表現の扱い方と対照的である。

You can specify named character classes, just like in character
alternatives.  For instance, @samp{[^[:ascii:]]} matches any
non-@acronym{ASCII} character.  @xref{Char Classes}.

@item @samp{^}
@cindex 行頭、正規表現
@samp{^}は空の文字列に一致する特別な文字であり、
一致を取る対象のテキストの行頭のみに一致する。
それ以外では、一致に失敗する。
したがって、@samp{^foo}は、行頭にある@samp{foo}に一致する。

バッファのかわりに文字列と一致を取るときには、
@samp{^}は文字列の先頭や改行文字のうしろに一致する。

For historical compatibility reasons, @samp{^} can be used only at the
beginning of the regular expression, or after @samp{\(}, @samp{\(?:}
or @samp{\|}.

@item @samp{$}
@cindex @samp{$}、正規表現
@cindex 行末、正規表現
@samp{^}と同様だが行末のみに一致する。
したがって、@samp{x+$}は、
行末にある1文字以上の@samp{x}から成る文字列に一致する。

バッファのかわりに文字列と一致を取るときには、
@samp{$}は文字列の末尾や改行文字のまえに一致する。

For historical compatibility reasons, @samp{$} can be used only at the
end of the regular expression, or before @samp{\)} or @samp{\|}.

@item @samp{\}
@cindex @samp{\}、正規表現
2つの機能がある。
（@samp{\}を含む）特別な文字をクォートする（意味を抑える）ことと、
特別な構成を導入することである。

@samp{\}は特別な文字をクォートするので、
@samp{\$}は文字@samp{$}だけに一致する正規表現、
@samp{\[}は文字@samp{[}だけに一致する正規表現、
といった具合になる。

@samp{\}にはLisp文字列の入力構文（@pxref{String Type}）でも
特別な意味があり、@samp{\}でクォートする必要があることに注意してほしい。
たとえば、文字@samp{\}に一致する正規表現は@samp{\\}である。
文字群@samp{\\}を含むLisp文字列を書くには、各@samp{\}をクォートするために
@samp{\}が必要である。
したがって、@samp{\}に一致する正規表現の入力構文は@code{"\\\\"}である。
@end table

@strong{注意：}従来との互換性のために、
特別な文字がそれらの特別な意味をなしえない文脈で使われた場合には、
普通の文字として扱われる。
たとえば、@samp{*foo}では、@samp{*}の対象となる正規表現が直前にないため、
@samp{*}は普通の文字として扱われる。
このようなふるまいに依存することはよいことではない。
特別な文字は書く位置に関係なくクォートするべきである。

As a @samp{\} is not special inside a character alternative, it can
never remove the special meaning of @samp{-} or @samp{]}.  So you
should not quote these characters when they have no special meaning
either.  This would not clarify anything, since backslashes can
legitimately precede these characters where they @emph{have} special
meaning, as in @samp{[^\]} (@code{"[^\\]"} for Lisp string syntax),
which matches any single character except a backslash.

In practice, most @samp{]} that occur in regular expressions close a
character alternative and hence are special.  However, occasionally a
regular expression may try to match a complex pattern of literal
@samp{[} and @samp{]}.  In such situations, it sometimes may be
necessary to carefully parse the regexp from the start to determine
which square brackets enclose a character alternative.  For example,
@samp{[^][]]} consists of the complemented character alternative
@samp{[^][]} (which matches any single character that is not a square
bracket), followed by a literal @samp{]}.

The exact rules are that at the beginning of a regexp, @samp{[} is
special and @samp{]} not.  This lasts until the first unquoted
@samp{[}, after which we are in a character alternative; @samp{[} is
no longer special (except when it starts a character class) but @samp{]}
is special, unless it immediately follows the special @samp{[} or that
@samp{[} followed by a @samp{^}.  This lasts until the next special
@samp{]} that does not end a character class.  This ends the character
alternative and restores the ordinary syntax of regular expressions;
an unquoted @samp{[} is special again and a @samp{]} not.

@node Char Classes
@subsubsection Character Classes
@cindex character classes in regexp

  Here is a table of the classes you can use in a character alternative,
and what they mean:

@table @samp
@item [:ascii:]
This matches any @acronym{ASCII} character (codes 0--127).
@item [:alnum:]
This matches any letter or digit.  For multibyte characters, it
matches characters whose Unicode @samp{general-category} property
(@pxref{Character Properties}) indicates they are alphabetic or
decimal number characters.
@item [:alpha:]
This matches any letter.  For multibyte characters, it matches
characters whose Unicode @samp{general-category} property
(@pxref{Character Properties}) indicates they are alphabetic
characters.
@item [:blank:]
This matches space and tab only.
@item [:cntrl:]
This matches any @acronym{ASCII} control character.
@item [:digit:]
This matches @samp{0} through @samp{9}.  Thus, @samp{[-+[:digit:]]}
matches any digit, as well as @samp{+} and @samp{-}.
@item [:graph:]
This matches graphic characters---everything except whitespace,
@acronym{ASCII} and non-@acronym{ASCII} control characters,
surrogates, and codepoints unassigned by Unicode, as indicated by the
Unicode @samp{general-category} property (@pxref{Character
Properties}).
@item [:lower:]
This matches any lower-case letter, as determined by the current case
table (@pxref{Case Tables}).  If @code{case-fold-search} is
non-@code{nil}, this also matches any upper-case letter.
@item [:multibyte:]
This matches any multibyte character (@pxref{Text Representations}).
@item [:nonascii:]
This matches any non-@acronym{ASCII} character.
@item [:print:]
This matches any printing character---either whitespace, or a graphic
character matched by @samp{[:graph:]}.
@item [:punct:]
This matches any punctuation character.  (At present, for multibyte
characters, it matches anything that has non-word syntax.)
@item [:space:]
This matches any character that has whitespace syntax
(@pxref{Syntax Class Table}).
@item [:unibyte:]
This matches any unibyte character (@pxref{Text Representations}).
@item [:upper:]
This matches any upper-case letter, as determined by the current case
table (@pxref{Case Tables}).  If @code{case-fold-search} is
non-@code{nil}, this also matches any lower-case letter.
@item [:word:]
This matches any character that has word syntax (@pxref{Syntax Class
Table}).
@item [:xdigit:]
This matches the hexadecimal digits: @samp{0} through @samp{9}, @samp{a}
through @samp{f} and @samp{A} through @samp{F}.
@end table

@node Regexp Backslash
@subsubsection Backslash Constructs in Regular Expressions
@cindex backslash in regular expressions

多くの場合、任意の文字を伴う@samp{\}はその文字だけに一致します。
しかし、いくつか例外があって、
@samp{\}で始まる2文字列が特別な意味を持つ場合があります。
（2文字目にくる文字は、
単独で使った場合にはつねに普通の文字として扱われる。）
以下に@samp{\}の構成を示します。

@table @samp
@item \|
@cindex @samp{|}、正規表現
@cindex 正規表現の選択肢
選択肢を指定する。
@samp{\|}をあいだに伴った2つの正規表現@var{a}と@var{b}は、
@var{a}か@var{b}のいずれかに一致する文字列に一致する正規表現となる。

したがって、@samp{foo\|bar}は、@samp{foo}や@samp{bar}に一致するが、
それ以外の文字列には一致しない。

@samp{\|}は、周囲にある適用しうる正規表現の中でも最大のものに適用される。
@samp{\|}によるグループ化を制限するのは、
これを囲む@samp{\( @dots{} \)}によるグループ化だけである。

If you need full backtracking capability to handle multiple uses of
@samp{\|}, use the POSIX regular expression functions (@pxref{POSIX
Regexps}).

@item \@{@var{m}\@}
is a postfix operator that repeats the previous pattern exactly @var{m}
times.  Thus, @samp{x\@{5\@}} matches the string @samp{xxxxx}
and nothing else.  @samp{c[ad]\@{3\@}r} matches string such as
@samp{caaar}, @samp{cdddr}, @samp{cadar}, and so on.

@item \@{@var{m},@var{n}\@}
is a more general postfix operator that specifies repetition with a
minimum of @var{m} repeats and a maximum of @var{n} repeats.  If @var{m}
is omitted, the minimum is 0; if @var{n} is omitted, there is no
maximum.

For example, @samp{c[ad]\@{1,2\@}r} matches the strings @samp{car},
@samp{cdr}, @samp{caar}, @samp{cadr}, @samp{cdar}, and @samp{cddr}, and
nothing else.@*
@samp{\@{0,1\@}} or @samp{\@{,1\@}} is equivalent to @samp{?}.@*
@samp{\@{0,\@}} or @samp{\@{,\@}} is equivalent to @samp{*}.@*
@samp{\@{1,\@}} is equivalent to @samp{+}.

@item \( @dots{} \)
@cindex @samp{(}、正規表現
@cindex @samp{)}、正規表現
@cindex 正規表現のグループ化
以下の3つの目的を果たすグループ化のための構成。

@enumerate
@item
他の操作に使うために一連の選択肢@samp{\|}を括る。
したがって、@samp{\(foo\|bar\)x}は、
@samp{foox}か@samp{barx}のいずれかに一致する。

@item
後置演算子、@samp{*}、@samp{+}、@samp{?}を適用できるように、
複雑な正規表現を括る。
したがって、@samp{ba\(na\)*}は、
@samp{ba}、@samp{bana}、@samp{banana}、@samp{bananana}のように、（0個以上の）任意個の
文字列@samp{na}に一致する。

@item
あとで@samp{\@var{digit}}で参照できるように、一致した部分文字列を記録する。
@end enumerate

最後の使い方は、括弧によるグループ化という考え方から
派生したものではない。
同一の@samp{\( @dots{} \)}構成に与えた2つめの別の機能である。
実用上、これら2つの意味が混同されることはないからである。
この機能をつぎに説明する。

@item \(?: @dots{} \)
@cindex shy groups
@cindex non-capturing group
@cindex unnumbered group
@cindex @samp{(?:} in regexp
is the @dfn{shy group} construct.  A shy group serves the first two
purposes of an ordinary group (controlling the nesting of other
operators), but it does not get a number, so you cannot refer back to
its value with @samp{\@var{digit}}.  Shy groups are particularly
useful for mechanically-constructed regular expressions, because they
can be added automatically without altering the numbering of ordinary,
non-shy groups.

Shy groups are also called @dfn{non-capturing} or @dfn{unnumbered
groups}.

@item \(?@var{num}: @dots{} \)
is the @dfn{explicitly numbered group} construct.  Normal groups get
their number implicitly, based on their position, which can be
inconvenient.  This construct allows you to force a particular group
number.  There is no particular restriction on the numbering,
e.g., you can have several groups with the same number in which case
the last one to match (i.e., the rightmost match) will win.
Implicitly numbered groups always get the smallest integer larger than
the one of any previous group.

@item \@var{digit}
@var{digit}番目に現れた@samp{\( @dots{} \)}に一致したテキストと
同じテキストに一致する。

いいかえれば、
グループ構成の末尾に達すると、
この構成に一致したテキストの始めと終りを記憶する。
そして、正規表現のそれよりうしろでは、
同じテキストという意味で
それがなんであろうと@samp{\}に続けて数字@var{digit}を使える。

1つの正規表現内に現れる最初の9個のグループ構成に一致する文字列には、
正規表現中で開き括弧が現れた順に、1から9までの番号を割り振る。
そのため、@samp{\1}から@samp{\9}で、
対応するグループ構成に一致したテキストを参照できる。

たとえば、@samp{\(.*\)\1}は、改行を含まない文字列で、かつ、
前半と後半が同一である文字列に一致する。
@samp{\(.*\)}は前半部分に一致し、それはどのようなものでもかまわない。
一方、それに続く@samp{\1}は、
前半部分とまったく同じテキストに一致しなければならない。

If a @samp{\( @dots{} \)} construct matches more than once (which can
happen, for instance, if it is followed by @samp{*}), only the last
match is recorded.

If a particular grouping construct in the regular expression was never
matched---for instance, if it appears inside of an alternative that
wasn't used, or inside of a repetition that repeated zero times---then
the corresponding @samp{\@var{digit}} construct never matches
anything.  To use an artificial example, @samp{\(foo\(b*\)\|lose\)\2}
cannot match @samp{lose}: the second alternative inside the larger
group matches it, but then @samp{\2} is undefined and can't match
anything.  But it can match @samp{foobb}, because the first
alternative matches @samp{foob} and @samp{\2} matches @samp{b}.

@item \w
@cindex @samp{\w}、正規表現
任意の単語構成文字に一致する。
エディタの構文テーブルによってこの文字が決まる。
@xref{Syntax Tables}。

@item \W
@cindex @samp{\W}、正規表現
単語構成文字以外の文字に一致する。

@item \s@var{code}
@cindex @samp{\s}、正規表現
構文コードが@var{code}である文字だけに一致する。
ここで、@var{code}は構文コードを表す文字である。
つまり、@samp{w}は単語構成要素を、
@samp{-}は白文字を、@samp{(}は開き括弧を表すといった具合である。
白文字の構文を表すには、@samp{-}か空白のいずれかを使う。
構文コードとそれらを表す文字の一覧については、
@xref{Syntax Class Table}。

@item \S@var{code}
@cindex @samp{\S}、正規表現
構文が@var{code}でない任意の文字に一致する。

@cindex category, regexp search for
@item \c@var{c}
matches any character whose category is @var{c}.  Here @var{c} is a
character that represents a category: thus, @samp{c} for Chinese
characters or @samp{g} for Greek characters in the standard category
table.  You can see the list of all the currently defined categories
with @kbd{M-x describe-categories @key{RET}}.  You can also define
your own categories in addition to the standard ones using the
@code{define-category} function (@pxref{Categories}).

@item \C@var{c}
matches any character whose category is not @var{c}.
@end table

つぎの正規表現は空の文字列に一致します。
つまりこれらは文字を使用しませんが、
これらが一致するかどうか文脈に依存します。
For all, the beginning and end of the accessible portion of
the buffer are treated as if they were the actual beginning and end of
the buffer.

@table @samp
@item \`
@cindex @samp{\`}、正規表現
空の文字列に一致するが、
一致対象であるバッファや文字列の先頭に限る。

@item \'
@cindex @samp{\'}、正規表現
空の文字列に一致するが、
一致対象であるバッファや文字列の末尾に限る。

@item \=
@cindex @samp{\=}、正規表現
空の文字列に一致するが、ポイント位置に限る。
（文字列に対する一致ではこの構文は定義されない。）

@item \b
@cindex @samp{\b}、正規表現
空の文字列に一致するが、単語の先頭や末尾に限る。
したがって、@samp{\bfoo\b}は、単語として独立して現れる@samp{foo}に一致する。
@samp{\bballs?\b}は、単語として独立して現れる
@samp{ball}や@samp{balls}に一致する。

@samp{\b}は、
バッファの先頭や末尾にあるテキストとは無関係に、
バッファの先頭や末尾にも一致する。

@item \B
@cindex @samp{\B}、正規表現
空の文字列に一致するが、単語の先頭や末尾@emph{以外}に限る。

@item \<
@cindex @samp{\<}、正規表現
空の文字列に一致するが、単語の先頭に限る。
@samp{\<}はバッファの先頭にも一致するが、単語構成文字が続く場合に限る。

@item \>
@cindex @samp{\>}、正規表現
空の文字列に一致するが、単語の末尾に限る。
@samp{\>}はバッファの末尾にも一致するが、
単語構成文字で終了している場合に限る。

@item \_<
@cindex @samp{\_<} in regexp
matches the empty string, but only at the beginning of a symbol.  A
symbol is a sequence of one or more word or symbol constituent
characters.  @samp{\_<} matches at the beginning of the buffer (or
string) only if a symbol-constituent character follows.

@item \_>
@cindex @samp{\_>} in regexp
matches the empty string, but only at the end of a symbol.  @samp{\_>}
matches at the end of the buffer (or string) only if the contents end
with a symbol-constituent character.
@end table

@kindex invalid-regexp
任意の文字列が正しい正規表現ではありません。
たとえば、@samp{]}で閉じない文字選択は正しくありませんし、
1つの@samp{\}で終る文字列も正しくありません。
不正な正規表現を探索関数に渡すと、
エラー@code{invalid-regexp}が通知されます。

@node Regexp Example
@subsection 複雑な正規表現の例

ここでは、任意個数の白文字を伴った文末を認識するために
かつてEmacsで使われていた複雑な正規表現について述べます。
(Nowadays Emacs uses a similar but more complex default
regexp constructed by the function @code{sentence-end}.
@xref{Standard Regexps}.)

まず、タブ文字と空白を区別するためにLisp構文の文字列として
正規表現と、その評価した結果を示します。
文字列定数はダブルクォートで始まり終ります。
@samp{\"}は文字列の一部としてのダブルクォート、
@samp{\\}は文字列の一部としてのバックスラッシュ、
@samp{\t}はタブ、@samp{\n}は改行を表します。

@example
@group
"[.?!][]\"')@}]*\\($\\| $\\|\t\\|@ @ \\)[ \t\n]*"
     @result{} "[.?!][]\"')@}]*\\($\\| $\\|  \\|@ @ \\)[
]*"
@end group
@end example

@noindent
この出力では、タブと改行はそれ自身として現れています。

この正規表現には、連続してつぎのような4つの部分が含まれています。

@table @code
@item [.?!]
このパターンの最初の部分は、3つの文字、ピリオド、疑問符、感嘆符の
いずれかに一致する文字選択である。
一致部分はこれらの3つの文字の1つで始まる必要がある。
(This
is one point where the new default regexp used by Emacs differs from
the old.  The new value also allows some non-@acronym{ASCII}
characters that end a sentence without any following whitespace.)

@item []\"')@}]*
パターンの2番目の部分は、ピリオド、疑問符、感嘆符のいずれかに続く、
任意の閉じ括弧やクォーテーションマークの0個以上の繰り返しに一致する。
@code{\"}は、文字列内のダブルクォートを表すLisp構文である。
最後の@samp{*}は、直前の正規表現（この場合は文字選択）を
0回以上繰り返すことを表す。

@item \\($\\|@ $\\|\t\\|@ @ \\)
パターンの3番目の部分は、文末に続く白文字、
つまり、（空白を伴うかもしれない）行末、1つのタブ、2つの空白の
いずれかに一致する。
2つのバックスラッシュは、括弧や縦棒を正規表現の構文にする。
括弧はグループを区切り、縦棒は選択肢を区切る。
ドル記号は行末に一致するために用いている。

@item [ \t\n]*
Finally, the last part of the pattern matches any additional whitespace
beyond the minimum needed to end a sentence.
パターンの最後の部分は、
文末に最低限必要な白文字より余計な白文字に一致する。
@end table

@node Regexp Functions
@subsection Regular Expression Functions

  These functions operate on regular expressions.

@cindex quote special characters in regexp
@defun regexp-quote string
この関数は、@var{string}だけに正確に一致する正規表現の文字列を返す。
Using this regular expression in @code{looking-at} will
succeed only if the next characters in the buffer are @var{string};
using it in a search function will succeed if the text being searched
contains @var{string}.  @xref{Regexp Search}.

これにより、正規表現を必要とする関数を呼び出すときに
この文字列だけに正確に一致できる。

@example
@group
(regexp-quote "^The cat$")
     @result{} "\\^The cat\\$"
@end group
@end example

@code{regexp-quote}の用途の1つは、
正規表現で記述された文脈に正確に一致する文字列を組み合わせることである。
たとえば、つぎは、白文字で囲まれた@var{string}の値で表される文字列を探索する。

@example
@group
(re-search-forward
 (concat "\\s-" (regexp-quote string) "\\s-"))
@end group
@end example
@end defun

@cindex optimize regexp
@defun regexp-opt strings &optional paren
この関数は、文字列@var{strings}のいずれかに一致する
効率よい正規表現を返す。
これは、たとえばフォントロック（font-lock）モード
@footnote{Note that @code{regexp-opt} does not
guarantee that its result is absolutely the most efficient form
possible.  A hand-tuned regular expression can sometimes be slightly
more efficient, but is almost never worth the effort.}
などで、
可能な限り高速な一致や探索を行う必要がある場合に有用である。
@c E.g., see http://debbugs.gnu.org/2816

省略可能な引数@var{paren}が@code{nil}以外であると、
返される正規表現はつねに少なくとも1つの括弧によるグループ構文で囲まれる。
If @var{paren} is @code{words}, then
that construct is additionally surrounded by @samp{\<} and @samp{\>};
alternatively, if @var{paren} is @code{symbols}, then that construct
is additionally surrounded by @samp{\_<} and @samp{\_>}
(@code{symbols} is often appropriate when matching
programming-language keywords and the like).

つぎの@code{regexp-opt}の簡略版定義は、
実際の値に等価な（ただしそれほど効率よくない）正規表現を生成する。

@example
(defun regexp-opt (strings &optional paren)
  (let ((open-paren (if paren "\\(" ""))
        (close-paren (if paren "\\)" "")))
    (concat open-paren
            (mapconcat 'regexp-quote strings "\\|")
            close-paren)))
@end example
@end defun

@defun regexp-opt-depth regexp
この関数は、@var{regexp}内のグループ化構文（括弧で括った式）の
総個数を返す。
This does not include
shy groups (@pxref{Regexp Backslash}).
@end defun

@c Supposedly an internal regexp-opt function, but table.el uses it at least.
@defun regexp-opt-charset chars
This function returns a regular expression matching a character in the
list of characters @var{chars}.

@example
(regexp-opt-charset '(?a ?b ?c ?d ?e))
     @result{} "[a-e]"
@end example
@end defun

@c Internal functions: regexp-opt-group

@node Regexp Search
@section 正規表現の探索
@cindex 正規表現の探索
@cindex regexp searching
@cindex 探索、正規表現

GNU Emacsでは、正規表現（@pxref{Syntax of Regexps}）に一致するつぎの部分を
インクリメンタルにもそうでなくも探せます。
インクリメンタルサーチコマンドについては、
@ref{Regexp Search, , Regular
Expression Search, emacs, The GNU Emacs Manual}を
参照してください。
ここでは、プログラムで有用な探索関数のみについて述べます。
基本的なものは@code{re-search-forward}です。

これらの探索関数は、バッファがマルチバイトであれば
正規表現をマルチバイトに変換します。
バッファがユニバイトであれば、正規表現をユニバイトに変換します。
@xref{Text Representations}。

@deffn Command re-search-forward regexp &optional limit noerror repeat
この関数は、カレントバッファにおいて前方へ向けて
正規表現@var{regexp}に一致するテキストの文字列を探索する。
関数は@var{regexp}に一致しないテキストはすべて飛び越え、
みつけた一致箇所の末尾へポイントを置く。
ポイントの新たな値を返す。

@var{limit}が@code{nil}以外（カレントバッファ内の位置であること）であると、
探索の上限を表す。
その位置を越える箇所での一致は受け入れない。

@var{repeat}を指定してあると（正の数であること）、
その回数だけ探索を繰り返す（一致箇所の末尾を新たな探索の開始位置とする）。
連続してこれらの探索に成功すると関数は成功し、
ポイントを移動してその新たな値を返す。
さもなければ探索は失敗である。
関数@code{re-search-forward}が失敗した場合の動作は、@var{noerror}の値に依存する。

@table @asis
@item @code{nil}
エラー@code{search-failed}を通知する。
@item @code{t}
なにもせずに@code{nil}を返す。
@item anything else
ポイントを@var{limit}（あるいはバッファの末尾）へ
移動して@code{nil}を返す。
@end table

つぎの例では、ポイントは始めは@samp{T}のまえにある。
探索を呼び出すと、ポイントは当該行の末尾
（@samp{hat}の@samp{t}と改行のあいだ）へ移動する。

@example
@group
---------- Buffer: foo ----------
I read "@point{}The cat in the hat
comes back" twice.
---------- Buffer: foo ----------
@end group

@group
(re-search-forward "[a-z]+" nil t 5)
     @result{} 27

---------- Buffer: foo ----------
I read "The cat in the hat@point{}
comes back" twice.
---------- Buffer: foo ----------
@end group
@end example
@end deffn

@deffn Command re-search-backward regexp &optional limit noerror repeat
この関数は、カレントバッファにおいて後方へ向けて
正規表現@var{regexp}に一致するテキストの文字列を探索し、
みつけた一致箇所の先頭へポイントを置く。

この関数は@code{re-search-forward}に類似したものであるが、
単純な鏡像ではない。
@code{re-search-forward}は、一致箇所の先頭が
開始位置に可能な限り近い一致箇所を探す。
@code{re-search-backward}が完全な鏡像であれば、
一致箇所の末尾が可能な限り近い一致箇所を探す。
しかし、実際には、一致箇所の先頭が可能な限り近い一致箇所を探す。
これは、正規表現との一致をとる処理は、
指定開始位置において先頭から末尾へ向けてつねに行われるからである。

@code{re-search-forward}の完全な鏡像には、
正規表現の一致を末尾から先頭へ向けて行う特別な機能が必要である。
それを実装する手間をかけるほどの価値はない。
@end deffn

@defun string-match regexp string &optional start
この関数は、文字列@var{string}において正規表現@var{regexp}に一致した
最初の箇所の添字を返す。
あるいは、一致がなければ@code{nil}を返す。
@var{start}が@code{nil}以外であると、
@var{string}の指定した添字から探索を始める。

たとえばつぎのとおりである。

@example
@group
(string-match
 "quick" "The quick brown fox jumped quickly.")
     @result{} 4
@end group
@group
(string-match
 "quick" "The quick brown fox jumped quickly." 8)
     @result{} 27
@end group
@end example

@noindent
文字列の最初の文字の添字は0であり、
2番目の文字の添字は1であるといった具合になる。

この関数から戻ったあとでは、
一致箇所を越えた最初の文字の添字は@code{(match-end 0)}で得られる。
@xref{Match Data}。

@example
@group
(string-match
 "quick" "The quick brown fox jumped quickly." 8)
     @result{} 27
@end group

@group
(match-end 0)
     @result{} 32
@end group
@end example
@end defun

@defun string-match-p regexp string &optional start
This predicate function does what @code{string-match} does, but it
avoids modifying the match data.
@end defun

@defun looking-at regexp
この関数は、カレントバッファ内のポイントの直後のテキストが
正規表現@var{regexp}に一致するかどうかを調べる。
ここで『直後』とは、開始位置は固定されていて、
ポイントのうしろの最初の文字で始まる場合にのみ探索は成功する。
結果は、一致すれば@code{t}であり、さもなければ@code{nil}である。

この関数はポイントを移動しないが、マッチデータを更新する。@xref{Match Data}。
If you need to test for a match without modifying
the match data, use @code{looking-at-p}, described below.

つぎの例では、ポイントは@samp{T}の直前にある。
ポイントがこれ以外の場所にあると結果は@code{nil}になる。

@example
@group
---------- Buffer: foo ----------
I read "@point{}The cat in the hat
comes back" twice.
---------- Buffer: foo ----------

(looking-at "The cat in the hat$")
     @result{} t
@end group
@end example
@end defun

@defun looking-back regexp &optional limit greedy
This function returns @code{t} if @var{regexp} matches the text
immediately before point (i.e., ending at point), and @code{nil} otherwise.

Because regular expression matching works only going forward, this is
implemented by searching backwards from point for a match that ends at
point.  That can be quite slow if it has to search a long distance.
You can bound the time required by specifying @var{limit}, which says
not to search before @var{limit}.  In this case, the match that is
found must begin at or after @var{limit}.  Here's an example:

@example
@group
---------- Buffer: foo ----------
I read "@point{}The cat in the hat
comes back" twice.
---------- Buffer: foo ----------

(looking-back "read \"" 3)
     @result{} t
(looking-back "read \"" 4)
     @result{} nil
@end group
@end example

If @var{greedy} is non-@code{nil}, this function extends the match
backwards as far as possible, stopping when a single additional
previous character cannot be part of a match for regexp.  When the
match is extended, its starting position is allowed to occur before
@var{limit}.

@c http://debbugs.gnu.org/5689
As a general recommendation, try to avoid using @code{looking-back}
wherever possible, since it is slow.  For this reason, there are no
plans to add a @code{looking-back-p} function.
@end defun

@defun looking-at-p regexp
This predicate function works like @code{looking-at}, but without
updating the match data.
@end defun

@defvar search-spaces-regexp
If this variable is non-@code{nil}, it should be a regular expression
that says how to search for whitespace.  In that case, any group of
spaces in a regular expression being searched for stands for use of
this regular expression.  However, spaces inside of constructs such as
@samp{[@dots{}]} and @samp{*}, @samp{+}, @samp{?} are not affected by
@code{search-spaces-regexp}.

Since this variable affects all regular expression search and match
constructs, you should bind it temporarily for as small as possible
a part of the code.
@end defvar

@node POSIX Regexps
@section POSIXの正規表現探索

@cindex backtracking and POSIX regular expressions
普通の正規表現関数は、@samp{\|}や反復構文を扱うために必要なときには
バックトラックしますが、これを行い続けるのは
@emph{なんらか}の一致をみつけるまでです。
みつけてしまえば、それらは成功してみつけた最初の一致を報告します。

本節では、正規表現の一致に関するPOSIX規格で規定された
完全なバックトラックを行う代替の探索関数について述べます。
それらはすべての可能性を試し尽くしすべての一致箇所を探し終える
までバックトラックを継続してます。
そのため、POSIXで要求されるとおりの最長の一致を報告できるのです。
これは動作がとても遅いですから、最長一致が本当に必要な場合に限って
これらの関数を使ってください。

  The POSIX search and match functions do not properly support the
non-greedy repetition operators (@pxref{Regexp Special, non-greedy}).
This is because POSIX backtracking conflicts with the semantics of
non-greedy repetition.

@deffn Command posix-search-forward regexp &optional limit noerror repeat
これは@code{re-search-forward}と同様であるが、
正規表現の一致に関するPOSIX規格で規定された完全なバックトラックを行う。
@end deffn

@deffn Command posix-search-backward regexp &optional limit noerror repeat
これは@code{re-search-backward}と同様であるが、
正規表現の一致に関するPOSIX規格で規定された完全なバックトラックを行う。
@end deffn

@defun posix-looking-at regexp
これは@code{looking-at}と同様であるが、
正規表現の一致に関するPOSIX規格で規定された完全なバックトラックを行う。
@end defun

@defun posix-string-match regexp string &optional start
これは@code{string-match}と同様であるが、
正規表現の一致に関するPOSIX規格で規定された完全なバックトラックを行う。
@end defun

@node Match Data
@section マッチデータ
@cindex マッチデータ

Emacsは、正規表現の探索中に捜し出したテキスト断片の開始／終了位置を
記録しています。
this is called the @dfn{match data}.
つまり、たとえば、rmailメッセージ内で日付のような複雑なパターンを
探索してから、パターンの制御をもとに一致した一部分を取り出せるのです。

マッチデータは、通常、もっとも最近に行った探索のみを記述するので、
あとで使用したい探索とそのマッチデータを使うあいだに、
不注意に別の探索を行わないように注意してください。
あいだで探索を行う必要がある場合には、その周りで
マッチデータを保存／復元してそれらが上書きされないようにします。

  Notice that all functions are allowed to overwrite the match data
unless they're explicitly documented not to do so.  A consequence is
that functions that are run implicitly in the background
(@pxref{Timers}, and @ref{Idle Timers}) should likely save and restore
the match data explicitly.

@menu
* Replacing Match::       Replacing a substring that was matched.
* Simple Match Data::     Accessing single items of match data,
                            such as where a particular subexpression started.
* Entire Match Data::     Accessing the entire match data at once, as a list.
* Saving Match Data::     Saving and restoring the match data.
@end menu

@node Replacing Match
@subsection 一致したテキストの置換
@cindex replace matched text

この関数は、最後の探索で一致したテキストの一部または全てを置換します。
It works by means of the match data.

@cindex 置換時の大文字小文字
@defun replace-match replacement &optional fixedcase literal string subexp
この関数は、最後の探索で一致したバッファ内（あるいは文字列）の
テキストを置換する。

最後に探索をバッファに対して行った場合には、
@var{string}は省略するか、または@code{nil}を指定し、
また現在のバッファは最後の検索を行ったバッファであること。
そうすると、この関数はテキストを@var{replacement}へ置換することでバッファを編集する。
置換したテキストの末尾にはポイントが置かれる。

文字列で探索した場合には、@var{string}に同じ文字列を渡すこと。
そうすると、この関数は@var{replacement}で置換した新たな文字列を構築し、それを返す。

@var{fixedcase}が@code{nil}以外であると、
@code{replace-match}は置換テキストの大文字小文字は変更しない。
さもなければ、置換テキストの大文字小文字は、
対象テキストの大文字小文字に応じて変換される。
元テキストがすべて大文字であると、置換テキストも大文字に変換される。
元テキストの最初の単語が大文字で始まっていると、
置換テキストの最初の単語も大文字で始める。
元テキストが1単語のみであり、しかも、その単語が大文字1文字であると、
@code{replace-match}はすべてが大文字ではなく大文字で始まるとみなす。

@var{literal}が@code{nil}以外であると、
必要に応じて大文字小文字変換は行うものの
@var{replacement}をそのまま挿入する。
それが@code{nil}（デフォルト）であると、
文字@samp{\}を特別に扱う。
@var{replacement}に@samp{\}が現れるときには、
つぎの列のいずれかであること。

@table @asis
@item @samp{\&}
@cindex @samp{&}、置換
これは置換対象のテキスト全体を表す。

@item @samp{\@var{n}}, where @var{n} is a digit
@cindex @samp{\@var{n}}、置換
これはもとの正規表現内の@var{n}番目の部分式に一致したテキストを表す。
部分式とは、@samp{\(@dots{}\)}で囲んでグループ化した式である。
If the @var{n}th subexpression never
matched, an empty string is substituted.

@item @samp{\\}
@cindex @samp{\}、置換
これは置換テキスト内で1つの@samp{\}を表す。

@item @samp{\?}
This stands for itself (for compatibility with @code{replace-regexp}
and related commands; @pxref{Regexp Replace,,, emacs, The GNU
Emacs Manual}).
@end table

@noindent
Any other character following @samp{\} signals an error.

The substitutions performed by @samp{\&} and @samp{\@var{n}} occur
after case conversion, if any.  Therefore, the strings they substitute
are never case-converted.

@var{subexp}が@code{nil}以外であると、
一致箇所全体ではなく正規表現の@var{subexp}番目の部分式に
一致した箇所のみを置換することを指示する。
たとえば、@samp{foo \(ba*r\)}に一致させたあとで、
@var{subexp}に1を指定して@code{replace-match}を呼び出すと、
@samp{\(ba*r\)}に一致したテキストのみを置換することを意味する。
@end defun

@defun match-substitute-replacement replacement &optional fixedcase literal string subexp
This function returns the text that would be inserted into the buffer
by @code{replace-match}, but without modifying the buffer.  It is
useful if you want to present the user with actual replacement result,
with constructs like @samp{\@var{n}} or @samp{\&} substituted with
matched groups.  Arguments @var{replacement} and optional
@var{fixedcase}, @var{literal}, @var{string} and @var{subexp} have the
same meaning as for @code{replace-match}.
@end defun

@node Simple Match Data
@subsection マッチデータの簡単な参照

本節では、最後の探索や一致操作において
なにに一致したのかを調べるためのマッチデータの使い方を説明します。

一致したテキスト全体や正規表現の括弧で括った特定の部分式に一致した
テキストを調べることができます。
以下の関数の引数@var{count}でどれかを指定します。
@var{count}がゼロであれば、一致全体を調べることになります。
@var{count}が正であれば、望みの部分式を指定します。

正規表現の部分式は、エスケープした括弧@samp{\(@dots{}\)}でグループ化した
式であることに注意してください。
@var{count}番目の部分式は、正規表現全体の先頭から
@samp{\(}の出現を数えてみつけます。
最初の部分式は1、つぎは2、といった具合です。
部分式は正規表現だけにあります。
単純な文字列探索のあとでは、利用可能な情報は一致全体に関するものだけです。

  Every successful search sets the match data.  Therefore, you should
query the match data immediately after searching, before calling any
other function that might perform another search.  Alternatively, you
may save and restore the match data (@pxref{Saving Match Data}) around
the call to functions that could perform another search.  Or use the
functions that explicitly do not modify the match data;
e.g., @code{string-match-p}.

@c This is an old comment and presumably there is no prospect of this
@c changing now.  But still the advice stands.
探索に失敗すると、マッチデータを変更することもしないこともあります。
現在の実装では探索に失敗しても変更しませんが、
将来そうる可能性があります。
Don't try to rely on the value of the match data after a
failing search.

@defun match-string count &optional in-string
この関数は、最後の探索や一致操作で一致したテキストを文字列として返す。
@var{count}がゼロであるとテキスト全体を返す。
@var{count}が正であれば、@var{count}番目の括弧で囲んだ部分式に対応する
部分のみを返す。
@var{count}が範囲を越えていたり、当該部分式に一致するものがない場合には、
値は@code{nil}である。

最後の探索や一致操作を@code{string-match}で文字列に対して行った場合には、
引数@var{in-string}として同じ文字列を渡すこと。
バッファの探索や一致のあとでは、@var{in-string}を省略するか
@code{nil}を渡すこと。
ただし、@code{match-string}を呼び出すときのカレントバッファが
探索を行ったときのバッファであること。
Failure to follow this advice will lead to incorrect results.

The value is @code{nil} if @var{count} is out of range, or for a
subexpression inside a @samp{\|} alternative that wasn't used or a
repetition that repeated zero times.
@end defun

@defun match-string-no-properties count &optional in-string
この関数は@code{match-string}と同様であるが、
結果にはテキスト属性を含まない。
@end defun

@defun match-beginning count
この関数は、最後の正規表現探索やその部分式に一致したテキストの開始位置を返す。

@var{count}がゼロであると、値は一致全体の開始位置である。
さもなければ、@var{count}は正規表現内の部分式を指定し、
関数の値は当該部分式に一致した部分の開始位置である。

一致に利用されなかった選択肢@samp{\|}内の部分式に対しては、
値は@code{nil}である。
@end defun

@defun match-end count
この関数は@code{match-beginning}と同様であるが、
一致箇所の開始位置ではなく終了位置を返す点が異なる。
@end defun

コメントでテキスト内の位置を示しながら
マッチデータの利用例を示します。

@example
@group
(string-match "\\(qu\\)\\(ick\\)"
              "The quick fox jumped quickly.")
              ;0123456789
     @result{} 4
@end group

@group
(match-string 0 "The quick fox jumped quickly.")
     @result{} "quick"
(match-string 1 "The quick fox jumped quickly.")
     @result{} "qu"
(match-string 2 "The quick fox jumped quickly.")
     @result{} "ick"
@end group

@group
(match-beginning 1)       ; @r{一致箇所@samp{qu}の先頭は}
     @result{} 4                 ;   @r{添字4}
@end group

@group
(match-beginning 2)       ; @r{一致箇所@samp{ick}の先頭は}
     @result{} 6                 ;   @r{添字6}
@end group

@group
(match-end 1)             ; @r{一致箇所@samp{qu}の末尾は}
     @result{} 6                 ;   @r{添字6}

(match-end 2)             ; @r{一致箇所@samp{ick}の末尾は}
     @result{} 9                 ;   @r{添字9}
@end group
@end example

別の例も示します。
ポイントは始めは行頭にあります。
探索によって、ポイントは空白と単語@samp{in}のあいだに移動します。
一致箇所全体の先頭はバッファの9番目の文字（@samp{T}）であり、
最初の部分式の一致箇所の先頭は13番目の文字（@samp{c}）です。

@example
@group
(list
  (re-search-forward "The \\(cat \\)")
  (match-beginning 0)
  (match-beginning 1))
    @result{} (17 9 13)
@end group

@group
---------- Buffer: foo ----------
I read "The cat @point{}in the hat comes back" twice.
        ^   ^
        9  13
---------- Buffer: foo ----------
@end group
@end example

@noindent
（この例では、返される添字はバッファ内位置であり、
バッファの最初の文字を1と数える。）

@node Entire Match Data
@subsection マッチデータ全体を参照する

関数@code{match-data}と@code{set-match-data}は、
マッチデータ全体を一度に読んだり書いたりします。

@defun match-data &optional integers reuse reseat
この関数は、最後の探索で一致したテキストに関するすべての情報を収めた
新たに構築したリストを返す。
要素0が式全体に一致した部分の先頭位置であり、
要素1が式全体に一致した部分の終了位置である。
つぎの2つの要素は最初の部分式に一致した部分の先頭／終了位置、
といった具合である。
一般に、要素
@ifnottex
番号 2@var{n}
@end ifnottex
@tex
番号 {\mathsurround=0pt $2n$}
@end tex
は @code{(match-beginning @var{n})}; に対応し、
要素
@ifnottex
番号 2@var{n} + 1
@end ifnottex
@tex
番号 {\mathsurround=0pt $2n+1$}
@end tex
は@code{(match-end @var{n})}に対応する。

通常、すべての要素はマーカか@code{nil}であるが、
@var{integers}が@code{nil}でない場合は、マーカの代わりに整数が使われる。
 (In that case, the buffer itself is appended as an
additional element at the end of the list, to facilitate complete
restoration of the match data.)
最後のマッチが@code{string-match}により文字列で行われた場合は、
マーカは文字列に対して使えないため、常に整数が使われる。

If @var{reuse} is non-@code{nil}, it should be a list.  In that case,
@code{match-data} stores the match data in @var{reuse}.  That is,
@var{reuse} is destructively modified.  @var{reuse} does not need to
have the right length.  If it is not long enough to contain the match
data, it is extended.  If it is too long, the length of @var{reuse}
stays the same, but the elements that were not used are set to
@code{nil}.  The purpose of this feature is to reduce the need for
garbage collection.

If @var{reseat} is non-@code{nil}, all markers on the @var{reuse} list
are reseated to point to nowhere.

探索関数の呼び出しとその探索結果としてのマッチデータを参照するための
@code{match-data}の呼び出しのあいだには、
別の探索があってはならない。

@example
@group
(match-data)
     @result{}  (#<marker at 9 in foo>
          #<marker at 17 in foo>
          #<marker at 13 in foo>
          #<marker at 17 in foo>)
@end group
@end example
@end defun

@defun set-match-data match-list &optional reseat
この関数は、@var{match-list}の要素からマッチデータを設定する。
@var{match-list}は、以前に@code{match-data}の呼び出しで得たリストであること。
(More precisely, anything that has the same format
will work.)

@var{match-list}が存在しないバッファを指していても、エラーにはならない。
無意味な情報をマッチデータに設定するが、害にはならない。

If @var{reseat} is non-@code{nil}, all markers on the @var{match-list} list
are reseated to point to nowhere.

@c TODO Make it properly obsolete.
@findex store-match-data
@code{store-match-data}はほぼ廃れている@code{set-match-data}の別名である。
@end defun

@node Saving Match Data
@subsection マッチデータの保存と復元

探索を行う可能性がある関数を呼び出す場合、
あとで使うためにそれ以前の探索によるマッチデータを保存したいときには、
当該関数の呼び出しの周りでマッチデータを保存し復元する必要があります。
つぎの例は、マッチデータを保存し損なった場合に生じる問題点を
示しています。

@example
@group
(re-search-forward "The \\(cat \\)")
     @result{} 48
(foo)                   ; @r{@code{foo} does more searching.}
(match-end 0)
     @result{} 61              ; @r{Unexpected result---not 48!}
@end group
@end example

マッチデータの保存と復元は@code{save-match-data}で行えます。

@defmac save-match-data body@dots{}
このマクロは、周りのマッチデータを保存し、
@var{body}を実行して、マッチデータを復元する。
The return value is the value of the last form in
@var{body}.
@end defmac

スペシャルフォーム@code{save-match-data}の効果をまねるために
@code{match-data}とともに@code{set-match-data}を使うこともできます。
つぎのようにします。

@example
@group
(let ((data (match-data)))
  (unwind-protect
      @dots{}   ; @r{もとのマッチデータを変更しても大丈夫}
    (set-match-data data)))
@end group
@end example

プロセスフィルタ関数（@pxref{Filter Functions}）や
プロセスの番兵（@pxref{Sentinels}）を実行するときには、
Emacsは自動的にマッチデータを保存し復元します。

@ignore
  Here is a function which restores the match data provided the buffer
associated with it still exists.

@smallexample
@group
(defun restore-match-data (data)
@c It is incorrect to split the first line of a doc string.
@c If there's a problem here, it should be solved in some other way.
  "Restore the match data DATA unless the buffer is missing."
  (catch 'foo
    (let ((d data))
@end group
      (while d
        (and (car d)
             (null (marker-buffer (car d)))
@group
             ;; @file{match-data} @r{buffer is deleted.}
             (throw 'foo nil))
        (setq d (cdr d)))
      (set-match-data data))))
@end group
@end smallexample
@end ignore

@node Search and Replace
@section 探索と置換
@cindex replacement after search
@cindex searching and replacing

  If you want to find all matches for a regexp in part of the buffer,
and replace them, the best way is to write an explicit loop using
@code{re-search-forward} and @code{replace-match}, like this:

@example
(while (re-search-forward "foo[ \t]+bar" nil t)
  (replace-match "foobar"))
@end example

@noindent
@xref{Replacing Match,, Replacing the Text that Matched}, for a
description of @code{replace-match}.

  However, replacing matches in a string is more complex, especially
if you want to do it efficiently.  So Emacs provides a function to do
this.

@defun replace-regexp-in-string regexp rep string &optional fixedcase literal subexp start
This function copies @var{string} and searches it for matches for
@var{regexp}, and replaces them with @var{rep}.  It returns the
modified copy.  If @var{start} is non-@code{nil}, the search for
matches starts at that index in @var{string}, so matches starting
before that index are not changed.

This function uses @code{replace-match} to do the replacement, and it
passes the optional arguments @var{fixedcase}, @var{literal} and
@var{subexp} along to @code{replace-match}.

Instead of a string, @var{rep} can be a function.  In that case,
@code{replace-regexp-in-string} calls @var{rep} for each match,
passing the text of the match as its sole argument.  It collects the
value @var{rep} returns and passes that to @code{replace-match} as the
replacement string.  The match data at this point are the result
of matching @var{regexp} against a substring of @var{string}.
@end defun

  If you want to write a command along the lines of @code{query-replace},
you can use @code{perform-replace} to do the work.

@defun perform-replace from-string replacements query-flag regexp-flag delimited-flag &optional repeat-count map start end
この関数は、@code{query-replace}と関連するコマンドの中身である。
@var{start}と@var{end}の間のテキストの
@var{from-string}の出現を探しだし、
それらの一部やすべてを置き換える。
If @var{start} is @code{nil} (or omitted), point is used
instead, and the end of the buffer's accessible portion is used for
@var{end}.

@var{query-flag}が@code{nil}であると、すべての出現を置換する。
さもなければ、1つ1つユーザーにどうするかを問い合わせる。

@var{regexp-flag}が@code{nil}以外であると、
@var{from-string}を正規表現として扱う。
さもなければ、その字面とおりに一致する。
@var{delimited-flag}が@code{nil}以外であると、
単語区切りで囲まれたもののみを対象にする。

引数@var{replacements}は、出現を置き換えるものを指定する。
それが文字列であれば、その文字列を使う。
文字列のリストでもよく、要素を巡回して使う。

If @var{replacements} is a cons cell, @w{@code{(@var{function}
. @var{data})}}, this means to call @var{function} after each match to
get the replacement text.  This function is called with two arguments:
@var{data}, and the number of replacements already made.

@var{repeat-count}が@code{nil}以外であれば、整数であること。
これは、@var{replacements}のリスト内の各文字列を
つぎに進めるまえに何回使用するかを指定する。

If @var{from-string} contains upper-case letters, then
@code{perform-replace} binds @code{case-fold-search} to @code{nil}, and
it uses the @var{replacements} without altering their case.

通常、キーマップ@code{query-replace-map}で、
可能なユーザーの応答を定義する。
引数@var{map}が@code{nil}以外であれば、
@code{query-replace-map}のかわりに使うキーマップである。

This function uses one of two functions to search for the next
occurrence of @var{from-string}.  These functions are specified by the
values of two variables: @code{replace-re-search-function} and
@code{replace-search-function}.  The former is called when the
argument @var{regexp-flag} is non-@code{nil}, the latter when it is
@code{nil}.
@end defun

@defvar query-replace-map
この変数は、@code{y-or-n-p}や@code{map-y-or-n-p}に加えて、
@code{perform-replace}に対する
正しいユーザー応答を定義する特別なキーマップを保持する。
2つの意味で普通のものではない。

@itemize @bullet
@item
『キーバインディング』はコマンドではなく、
このキーマップを用いる関数にのみ意味がある単なるシンボルである。

@item
プレフィックスキーは扱えない。
各キーバインディングは単一イベントのキー列である必要がある。
これは、関数では入力を得るために@code{read-key-sequence}を使わずに、
『自前』でイベントを読み取り探索するからである。
@end itemize
@end defvar

@code{query-replace-map}向けの意味のある『バインディング』をつぎに示します。
@code{query-replace}と関連するものだけに意味のあるものもあります。

@table @code
@item act
当該動作を行う、いいかえれば『yes』。

@item skip
この問いに対する動作は行わない、いいかえれば『no』。

@item exit
この問いには『no』で答え、
残りの応答も『no』と仮定して一連の問いを止める。

@item exit-prefix
Like @code{exit}, but add the key that was pressed to
@code{unread-command-events} (@pxref{Event Input Misc}).

@item act-and-exit
この問いには『yes』で答え、
残りの応答は『no』と仮定して一連の問いを止める。

@item act-and-show
この問いには『yes』で答えるが、結果を表示する。
つぎの問いへは進まない。

@item automatic
この問いと以降の一連の問いに『yes』で答え、
これ以降ユーザーに問い合わせない。

@item backup
問いに答えたまえの箇所へ戻る。

@item edit
この問いに対処するために、通常の動作のかわりに再帰編集に入る。

@item edit-replacement
Edit the replacement for this question in the minibuffer.

@item delete-and-edit
対象のテキストを削除してから、
それを置き換えるために再帰編集に入る。

@item recenter
@itemx scroll-up
@itemx scroll-down
@itemx scroll-other-window
@itemx scroll-other-window-down
ウィンドウの中央に位置決めして再表示してから、
同じ問いを問い直す。
Only @code{y-or-n-p} and related functions use this
answer.

@item quit
ただちに中断する。
@code{y-or-n-p}と関連する関数でのみ、この応答を用いる。

@item help
ヘルプを表示してから、再度問い直す。
@end table

@defvar multi-query-replace-map
This variable holds a keymap that extends @code{query-replace-map} by
providing additional keybindings that are useful in multi-buffer
replacements.  The additional ``bindings'' are:

@table @code
@item automatic-all
Answer this question and all subsequent questions in the series with
``yes'', without further user interaction, for all remaining buffers.

@item exit-current
Answer this question ``no'', and give up on the entire series of
questions for the current buffer.  Continue to the next buffer in the
sequence.
@end table
@end defvar

@defvar replace-search-function
This variable specifies a function that @code{perform-replace} calls
to search for the next string to replace.  Its default value is
@code{search-forward}.  Any other value should name a function of 3
arguments: the first 3 arguments of @code{search-forward}
(@pxref{String Search}).
@end defvar

@defvar replace-re-search-function
This variable specifies a function that @code{perform-replace} calls
to search for the next regexp to replace.  Its default value is
@code{re-search-forward}.  Any other value should name a function of 3
arguments: the first 3 arguments of @code{re-search-forward}
(@pxref{Regexp Search}).
@end defvar

@node Standard Regexps
@section 編集に用いられる標準的な正規表現
@cindex 編集に用いられる標準的な正規表現
@cindex 標準的な正規表現

本節では、編集上の特定目的に用いられる正規表現を保持している
変数について述べます。

@defopt page-delimiter
これは、ページを区切る行頭を記述した正規表現である。
デフォルト値は、@code{"^\014"}（つまり、@code{"^^L"}すなわち@code{"^\C-l"}）
である。
これはページ送り文字で始まる行に一致する。
@end defopt

つぎの2つの正規表現は、つねに行の先頭から一致が
始まると仮定しては@emph{いけません}。
一致の開始位置を固定する@samp{^}を使うべきではありません。
ほとんどの場合、段落コマンドは行の先頭でのみ一致を検査しますから、
@samp{^}は不必要であることを意味します。
幅0以外の左端余白があると、段落コマンドは左端余白のうしろからの一致を
受け入れます。
そのような場合、@samp{^}は誤りです。
しかし、左端余白をけっして使わないモードならば、
@samp{^}は無害です。

@defopt paragraph-separate
これは、段落を区切る行の始まりを認識するための正規表現である。
（これを変更したら、@code{paragraph-start}も変更すること。）
デフォルト値は@w{@code{"[@ \t\f]*$"}}であり、
（左端余白に続く）空白やタブやページ送りだけから成る行に一致する。
@end defopt

@defopt paragraph-start
これは、段落を始める行@emph{や}区切る行の始まりを認識するための正規表現である。
デフォルト値は@w{@code{"\f\\|[ \t]*$"}}であり、
（左端余白に続く）空白やタブやページ送りだけから成る行に一致する。
@end defopt

@defopt sentence-end
これは、@code{nil}でない場合は、文末（空白を含む）を記述する正規表現である。
（これに関わらず、段落の区切りも文末である。）

If the value is @code{nil}, as it is by default, then the function
@code{sentence-end} constructs the regexp.  That is why you
should always call the function @code{sentence-end} to obtain the
regexp to be used to recognize the end of a sentence.
@end defopt

@defun sentence-end
This function returns the value of the variable @code{sentence-end},
if non-@code{nil}.  Otherwise it returns a default value based on the
values of the variables @code{sentence-end-double-space}
(@pxref{Definition of sentence-end-double-space}),
@code{sentence-end-without-period}, and
@code{sentence-end-without-space}.
@end defun
