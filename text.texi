@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1998 Free Software Foundation, Inc. 
@c See the file elisp.texi for copying conditions.
@setfilename ../info/text
@node Text, Non-ASCII Characters, Markers, Top
@c @chapter Text
@chapter テキスト
@c @cindex text
@cindex テキスト

@c   This chapter describes the functions that deal with the text in a
@c buffer.  Most examine, insert, or delete text in the current buffer,
@c often in the vicinity of point.  Many are interactive.  All the
@c functions that change the text provide for undoing the changes
@c (@pxref{Undo}).
本章では、バッファ内のテキストを扱う関数について述べます。
それらのほとんどは、カレントバッファ内のテキストを
調べたり挿入したり削除しますが、しばしばポイント付近で行います。
多くは対話的に使えます。
テキストを変更するすべての関数は、変更を取り消せます（@pxref{Undo}）。

@c   Many text-related functions operate on a region of text defined by two
@c buffer positions passed in arguments named @var{start} and @var{end}.
@c These arguments should be either markers (@pxref{Markers}) or numeric
@c character positions (@pxref{Positions}).  The order of these arguments
@c does not matter; it is all right for @var{start} to be the end of the
@c region and @var{end} the beginning.  For example, @code{(delete-region 1
@c 10)} and @code{(delete-region 10 1)} are equivalent.  An
@c @code{args-out-of-range} error is signaled if either @var{start} or
@c @var{end} is outside the accessible portion of the buffer.  In an
@c interactive call, point and the mark are used for these arguments.
テキスト関連の多くの関数は、@var{start}と@var{end}という名前の引数で渡された
2つのバッファ内位置で定義されるテキストの領域に作用します。
これらの引数は、マーカ（@pxref{Markers}）であるか
文字の位置を表す数値（@pxref{Positions}）である必要があります。
これらの引数の順番は関係なく、@var{start}が領域の終了位置で
@var{end}が開始位置であってもまったく問題ありません。
たとえば、@code{(delete-region 1 10)}と@code{(delete-region 10 1)}は同値です。
@var{start}や@var{end}がバッファの参照可能部分の外側にあると
エラー@code{args-out-of-range}を通知します。
対話的な呼び出しでは、ポイントとマークをこれらの引数として使います。

@c @cindex buffer contents
@cindex バッファの内容
@c   Throughout this chapter, ``text'' refers to the characters in the
@c buffer, together with their properties (when relevant).
本章では、バッファ内の文字を（関係あるときには）
それらのテキスト属性を含めて『テキスト』と呼びます。

@menu
* Near Point::       Examining text in the vicinity of point.
* Buffer Contents::  Examining text in a general fashion.
* Comparing Text::   Comparing substrings of buffers.
* Insertion::        Adding new text to a buffer.
* Commands for Insertion::  User-level commands to insert text.
* Deletion::         Removing text from a buffer.
* User-Level Deletion::     User-level commands to delete text.
* The Kill Ring::    Where removed text sometimes is saved for later use.
* Undo::             Undoing changes to the text of a buffer.
* Maintaining Undo:: How to enable and disable undo information.
			How to control how much information is kept.
* Filling::          Functions for explicit filling.
* Margins::          How to specify margins for filling commands.
* Adaptive Fill::    Adaptive Fill mode chooses a fill prefix from context.
* Auto Filling::     How auto-fill mode is implemented to break lines.
* Sorting::          Functions for sorting parts of the buffer.
* Columns::          Computing horizontal positions, and using them.
* Indentation::      Functions to insert or adjust indentation.
* Case Changes::     Case conversion of parts of the buffer.
* Text Properties::  Assigning Lisp property lists to text characters.
* Substitution::     Replacing a given character wherever it appears.
* Transposition::    Swapping two portions of a buffer.
* Registers::        How registers are implemented.  Accessing the text or
                       position stored in a register.
* Change Hooks::     Supplying functions to be run when text is changed.
@end menu

@node Near Point
@c @section Examining Text Near Point
@section ポイント付近のテキストを調べる

@c   Many functions are provided to look at the characters around point.
@c Several simple functions are described here.  See also @code{looking-at}
@c in @ref{Regexp Search}.
多くの関数は、ポイント付近の文字を調べるためのものです。
ここでは、数個の単純な関数について述べます。
@ref{Regexp Search}の@code{looking-at}も参照してください。

@defun char-after &optional position
@c This function returns the character in the current buffer at (i.e.,
@c immediately after) position @var{position}.  If @var{position} is out of
@c range for this purpose, either before the beginning of the buffer, or at
@c or beyond the end, then the value is @code{nil}.  The default for
@c @var{position} is point.
この関数は、カレントバッファ内の位置@var{position}にある
（つまり直後の）文字を返す。
@var{position}がバッファの先頭のまえや末尾のうしろにあるなどして
この目的に適した範囲の外側にあると、値は@code{nil}である。
@var{position}のデフォルトはポイントである。

@c In the following example, assume that the first character in the
@c buffer is @samp{@@}:
つぎの例では、バッファの最初の文字は@samp{@@}であると仮定する。

@example
@group
(char-to-string (char-after 1))
     @result{} "@@"
@end group
@end example
@end defun

@defun char-before &optional position
@c This function returns the character in the current buffer immediately
@c before position @var{position}.  If @var{position} is out of range for
@c this purpose, either before the beginning of the buffer, or at or beyond
@c the end, then the value is @code{nil}.  The default for
@c @var{position} is point.
この関数は、カレントバッファ内の位置@var{position}のまえにある文字を返す。
@var{position}がバッファの先頭のまえや末尾のうしろにあるなどして
この目的に適した範囲の外側にあると、値は@code{nil}である。
@var{position}のデフォルトはポイントである。
@end defun

@defun following-char
@c This function returns the character following point in the current
@c buffer.  This is similar to @code{(char-after (point))}.  However, if
@c point is at the end of the buffer, then @code{following-char} returns 0.
この関数は、カレントバッファのポイントのうしろにある文字を返す。
これは@code{(char-after (point))}と同様である。
しかし、ポイントがバッファの末尾にあると、
@code{following-char}は0を返す。

@c Remember that point is always between characters, and the terminal
@c cursor normally appears over the character following point.  Therefore,
@c the character returned by @code{following-char} is the character the
@c cursor is over.
ポイントはつねに文字のあいだにあり、
端末のカーソルはポイントの直後の文字に重ねて表示されることに注意してほしい。
したがって、@code{following-char}が返す文字は、
カーソルが重なっている文字である。

@c In this example, point is between the @samp{a} and the @samp{c}.
つぎの例では、ポイントは@samp{a}と@samp{c}のあいだにある。

@example
@group
---------- Buffer: foo ----------
Gentlemen may cry ``Pea@point{}ce! Peace!,''
but there is no peace.
---------- Buffer: foo ----------
@end group

@group
(char-to-string (preceding-char))
     @result{} "a"
(char-to-string (following-char))
     @result{} "c"
@end group
@end example
@end defun

@defun preceding-char
@c This function returns the character preceding point in the current
@c buffer.  See above, under @code{following-char}, for an example.  If
@c point is at the beginning of the buffer, @code{preceding-char} returns
@c 0.
この関数は、カレントバッファのポイントのまえの文字を返す。
例については上記の@code{following-char}を参照。
ポイントがバッファの先頭にあると、@code{preceding-char}は0を返す。
@end defun

@defun bobp
@c This function returns @code{t} if point is at the beginning of the
@c buffer.  If narrowing is in effect, this means the beginning of the
@c accessible portion of the text.  See also @code{point-min} in
@c @ref{Point}.
この関数は、ポイントがバッファの先頭にあると@code{t}を返す。
ナロイングしていると、これはバッファの参照可能部分の先頭を意味する。
@ref{Point}の@code{point-min}も参照。
@end defun

@defun eobp
@c This function returns @code{t} if point is at the end of the buffer.
@c If narrowing is in effect, this means the end of accessible portion of
@c the text.  See also @code{point-max} in @xref{Point}.
この関数は、ポイントがバッファの末尾にあると@code{t}を返す。
ナロイングしていると、これはバッファの参照可能部分の末尾を意味する。
@ref{Point}の@code{point-max}も参照。
@end defun

@defun bolp
@c This function returns @code{t} if point is at the beginning of a line.
@c @xref{Text Lines}.  The beginning of the buffer (or of its accessible
@c portion) always counts as the beginning of a line.
この関数は、ポイントが行頭にあると@code{t}を返す。
@pxref{Text Lines}。
バッファ（あるいはその参照可能部分）の先頭は、
つねに行頭とみなす。
@end defun

@defun eolp
@c This function returns @code{t} if point is at the end of a line.  The
@c end of the buffer (or of its accessible portion) is always considered
@c the end of a line.
この関数は、ポイントが行末にあると@code{t}を返す。
@pxref{Text Lines}。
バッファ（あるいはその参照可能部分）の末尾は、
つねに行末とみなす。
@end defun

@node Buffer Contents
@c @section Examining Buffer Contents
@section バッファの内容を調べる

@c   This section describes two functions that allow a Lisp program to
@c convert any portion of the text in the buffer into a string.
本節では、Lispプログラムでバッファ内の任意の部分のテキストを文字列に変換する
ための2つの関数について述べます。

@defun buffer-substring start end
@c This function returns a string containing a copy of the text of the
@c region defined by positions @var{start} and @var{end} in the current
@c buffer.  If the arguments are not positions in the accessible portion of
@c the buffer, @code{buffer-substring} signals an @code{args-out-of-range}
@c error.
この関数は、カレントバッファの@var{start}と@var{end}の位置で定義される
領域のテキストのコピーを含んだ文字列を返す。
引数がバッファの参照可能部分の内側の位置でないと、
@code{buffer-substring}はエラー@code{args-out-of-range}を通知する。

@c It is not necessary for @var{start} to be less than @var{end}; the
@c arguments can be given in either order.  But most often the smaller
@c argument is written first.
@var{start}が@var{end}より小さい必要はなく、引数の順番はどちらでもよい。
しかし、ほとんどの場合、小さい引数を先に書く。

@c If the text being copied has any text properties, these are copied into
@c the string along with the characters they belong to.  @xref{Text
@c Properties}.  However, overlays (@pxref{Overlays}) in the buffer and
@c their properties are ignored, not copied.
コピーされるテキストにテキスト属性がある場合、
テキスト属性もそれが属する文字とともに文字列へコピーされる。
@pxref{Text Properties}。
しかし、バッファのオーバレイ（@pxref{Overlays}）とそれらの属性は
無視されコピーされない。

@example
@group
---------- Buffer: foo ----------
This is the contents of buffer foo

---------- Buffer: foo ----------
@end group

@group
(buffer-substring 1 10)
@result{} "This is t"
@end group
@group
(buffer-substring (point-max) 10)
@result{} "he contents of buffer foo
"
@end group
@end example
@end defun

@defun buffer-substring-no-properties start end
@c This is like @code{buffer-substring}, except that it does not copy text
@c properties, just the characters themselves.  @xref{Text Properties}.
この関数は@code{buffer-substring}と同様であるが、
テキスト属性をコピーせずに文字だけをコピーする点が異なる。
@pxref{Text Properties}。
@end defun

@defun buffer-string
@c This function returns the contents of the entire accessible portion of
@c the current buffer as a string.  It is equivalent to
この関数は、カレントバッファの参照可能部分全体の内容を文字列として返す。
これは、つぎと等価である。

@example
(buffer-substring (point-min) (point-max))
@end example

@example
@group
---------- Buffer: foo ----------
This is the contents of buffer foo

---------- Buffer: foo ----------

(buffer-string)
     @result{} "This is the contents of buffer foo
"
@end group
@end example
@end defun

@defun thing-at-point thing
@c Return the @var{thing} around or next to point, as a string.
ポイントの周りやそのうしろにある@var{thing}を文字列として返す。

@c The argument @var{thing} is a symbol which specifies a kind of syntactic
@c entity.  Possibilities include @code{symbol}, @code{list}, @code{sexp},
@c @code{defun}, @code{filename}, @code{url}, @code{word}, @code{sentence},
@c @code{whitespace}, @code{line}, @code{page}, and others.
引数@var{thing}は、構文上の要素の種類を指定するシンボルである。
可能な値は、@code{symbol}、@code{list}、@code{sexp}、
@code{defun}、@code{filename}、@code{url}、@code{word}、@code{sentence}、
@code{whitespace}、@code{line}、@code{page}などである。

@example
---------- Buffer: foo ----------
Gentlemen may cry ``Pea@point{}ce! Peace!,''
but there is no peace.
---------- Buffer: foo ----------

(thing-at-point 'word)
     @result{} "Peace"
(thing-at-point 'line)
     @result{} "Gentlemen may cry ``Peace! Peace!,''\n"
(thing-at-point 'whitespace)
     @result{} nil
@end example
@end defun

@node Comparing Text
@c @section Comparing Text
@section テキストの比較
@c @cindex comparing buffer text
@cindex バッファテキストの比較

@c   This function lets you compare portions of the text in a buffer, without
@c copying them into strings first.
この関数により、バッファ内のテキストの部分同士を
文字列にコピーせずに比較できます。

@defun compare-buffer-substrings buffer1 start1 end1 buffer2 start2 end2
@c This function lets you compare two substrings of the same buffer or two
@c different buffers.  The first three arguments specify one substring,
@c giving a buffer and two positions within the buffer.  The last three
@c arguments specify the other substring in the same way.  You can use
@c @code{nil} for @var{buffer1}, @var{buffer2}, or both to stand for the
@c current buffer.
この関数は、同一バッファ内の2つの部分文字列、あるいは、
異なる2つのバッファの部分文字列を比較する。
始めの3つの引数は、バッファとそのバッファ内の2つの位置を与え、
1つの部分文字列を指定する。
残りの3つの引数も同様にして別の部分文字列を指定する。
カレントバッファを表すために、
@var{buffer1}と@var{buffer2}のいずれか、あるいは、
両方に@code{nil}を指定できる。

@c The value is negative if the first substring is less, positive if the
@c first is greater, and zero if they are equal.  The absolute value of
@c the result is one plus the index of the first differing characters
@c within the substrings.
始めの文字列のほうが小さければ値は負であり、
始めのほうが大きければ値は正であり、等しければ0である。
結果の絶対値は、部分文字列の中で最初に異なる文字の添字足す1である。

@c This function ignores case when comparing characters
@c if @code{case-fold-search} is non-@code{nil}.  It always ignores
@c text properties.
この関数は、@code{case-fold-search}が@code{nil}以外であると、
文字の比較では大文字小文字を区別しない。
テキスト属性はつねに無視する。

@c Suppose the current buffer contains the text @samp{foobarbar
@c haha!rara!}; then in this example the two substrings are @samp{rbar }
@c and @samp{rara!}.  The value is 2 because the first substring is greater
@c at the second character.
カレントバッファにはテキスト@samp{foobarbar haha!rara!}があるとする。
すると、この例の2つの部分文字列は@samp{rbar }と@samp{rara!}である。
2番目の文字で最初の文字列のほうが大きいので、結果は2である。

@example
(compare-buffer-substring nil 6 11 nil 16 21)
     @result{} 2
@end example
@end defun

@node Insertion
@c @section Inserting Text
@section テキストの挿入
@c @cindex insertion of text
@c @cindex text insertion
@cindex テキストの挿入
@cindex 挿入、テキスト

@c @cindex insertion before point
@c @cindex before point, insertion
@cindex ポイントのまえへ挿入
@cindex 挿入、ポイントのまえ
@c   @dfn{Insertion} means adding new text to a buffer.  The inserted text
@c goes at point---between the character before point and the character
@c after point.  Some insertion functions leave point before the inserted
@c text, while other functions leave it after.  We call the former
@c insertion @dfn{after point} and the latter insertion @dfn{before point}.
@dfn{挿入}（insertion）とは、バッファに新たなテキストを追加することです。
挿入されたテキストはポイント位置に、つまり、
ポイントのまえの文字とポイントのあとの文字のあいだに入ります。
挿入されたテキストのまえにポイントを留める関数もあれば、
そのうしろに留める関数もあります。
前者を@dfn{ポイントのうしろへ}挿入と呼び、
後者を@dfn{ポイントのまえへ}挿入と呼びます。

@c   Insertion relocates markers that point at positions after the
@c insertion point, so that they stay with the surrounding text
@c (@pxref{Markers}).  When a marker points at the place of insertion,
@c insertion may or may not relocate the marker, depending on the marker's
@c insertion type (@pxref{Marker Insertion Types}).  Certain special
@c functions such as @code{insert-before-markers} relocate all such markers
@c to point after the inserted text, regardless of the markers' insertion
@c type.
挿入により、挿入箇所よりうしろの位置を指すマーカは再配置されて
同じ周りの文字に留まります（@pxref{Markers}）。
マーカが挿入箇所を指している場合には、
マーカの挿入型（@pxref{Marker Insertion Types}）に依存して、
挿入するとマーカが再配置されたりされなかったりします。
@code{insert-before-markers}などの特定の特殊な関数は、
マーカの挿入型に関わらず、
挿入されたテキストのうしろを指すように
そのようなすべてのマーカを再配置します。

@c   Insertion functions signal an error if the current buffer is
@c read-only.
カレントバッファが読み出し専用であると、挿入関数はエラーを通知します。

@c   These functions copy text characters from strings and buffers along
@c with their properties.  The inserted characters have exactly the same
@c properties as the characters they were copied from.  By contrast,
@c characters specified as separate arguments, not part of a string or
@c buffer, inherit their text properties from the neighboring text.
これらの関数は、テキストの文字群をそれらの属性とともに
文字列からバッファへコピーします。
挿入された文字群は、コピーされるまえとまったく同じ属性を持ちます。
対照的に、文字列やバッファの一部ではない孤立した引数として
指定された文字群は、周りのテキストからテキスト属性を継承します。

@c   The insertion functions convert text from unibyte to multibyte in
@c order to insert in a multibyte buffer, and vice versa---if the text
@c comes from a string or from a buffer.  However, they do not convert
@c unibyte character codes 128 through 255 to multibyte characters, not
@c even if the current buffer is a multibyte buffer.  @xref{Converting
@c Representations}.
挿入関数は、文字列由来やバッファ由来のテキストの場合には、
マルチバイトバッファへ挿入するために
ユニバイトからマルチバイトへテキストを変換し、逆向きの変換も行います。
しかし、カレントバッファがたとえマルチバイトバッファであっても、
128から255のユニバイト文字コードはマルチバイト文字には変換しません。
@xref{Converting Representations}。

@defun insert &rest args
@c This function inserts the strings and/or characters @var{args} into the
@c current buffer, at point, moving point forward.  In other words, it
@c inserts the text before point.  An error is signaled unless all
@c @var{args} are either strings or characters.  The value is @code{nil}.
この関数は、文字列や文字群@var{args}をカレントバッファのポイント位置に挿入し、
ポイントを先へ進める。
いいかえれば、ポイントのまえにテキストを挿入する。
@var{args}が文字列でも文字でもないと、エラーを通知する。
値は@code{nil}である。
@end defun

@defun insert-before-markers &rest args
@c This function inserts the strings and/or characters @var{args} into the
@c current buffer, at point, moving point forward.  An error is signaled
@c unless all @var{args} are either strings or characters.  The value is
@c @code{nil}.
この関数は、文字列や文字群@var{args}をカレントバッファのポイント位置に挿入し、
ポイントを先へ進める。
@var{args}が文字列でも文字でもないと、エラーを通知する。
値は@code{nil}である。

@c This function is unlike the other insertion functions in that it
@c relocates markers initially pointing at the insertion point, to point
@c after the inserted text.  If an overlay begins the insertion point, the
@c inserted text falls outside the overlay; if a nonempty overlay ends at
@c the insertion point, the inserted text falls inside that overlay.
挿入箇所を指していたマーカを挿入されたテキストのうしろを指すように再配置
する点で、この関数は他の挿入関数と異なる。
挿入箇所でオーバレイが始まるときには、
挿入されたテキストはオーバレイの範囲外に出る。
空でないオーバレイが挿入箇所で終るときには、
挿入されたテキストはオーバレイの範囲内に入る。
@end defun

@defun insert-char character &optional count inherit
@c This function inserts @var{count} instances of @var{character} into the
@c current buffer before point.  The argument @var{count} should be a
@c number (@code{nil} means 1), and @var{character} must be a character.
@c The value is @code{nil}.
この関数は、カレントバッファのポイントのまえに
文字@var{character}を@var{count}個挿入する。
引数@var{count}は数（@code{nil}は1を意味する）であり、
@var{character}は文字であること。
値は@code{nil}である。

@c This function does not convert unibyte character codes 128 through 255
@c to multibyte characters, not even if the current buffer is a multibyte
@c buffer.  @xref{Converting Representations}.
この関数は、カレントバッファがたとえマルチバイトバッファであっても、
128から255のユニバイト文字コードはマルチバイト文字には変換しない。
@pxref{Converting Representations}。

@c If @var{inherit} is non-@code{nil}, then the inserted characters inherit
@c sticky text properties from the two characters before and after the
@c insertion point.  @xref{Sticky Properties}.
@var{inherit}が@code{nil}以外であると、挿入された文字は、
挿入箇所の前後の2つの文字からスティッキテキスト属性を継承する。
@end defun

@defun insert-buffer-substring from-buffer-or-name &optional start end
@c This function inserts a portion of buffer @var{from-buffer-or-name}
@c (which must already exist) into the current buffer before point.  The
@c text inserted is the region from @var{start} and @var{end}.  (These
@c arguments default to the beginning and end of the accessible portion of
@c that buffer.)  This function returns @code{nil}.
この関数は、バッファ@var{from-buffer-or-name}（既存であること）の部分を
カレントバッファのポイントのまえへ挿入する。
挿入されるテキストは@var{start}から@var{end}までの領域である。
（これらの引数のデフォルトは、当該バッファの参照可能部分の先頭と末尾である。）
この関数は@code{nil}を返す。

@c In this example, the form is executed with buffer @samp{bar} as the
@c current buffer.  We assume that buffer @samp{bar} is initially empty.
この例では、バッファ@samp{bar}をカレントバッファとしてフォームを実行する。
バッファ@samp{bar}は最初は空であると仮定する。

@example
@group
---------- Buffer: foo ----------
We hold these truths to be self-evident, that all
---------- Buffer: foo ----------
@end group

@group
(insert-buffer-substring "foo" 1 20)
     @result{} nil

---------- Buffer: bar ----------
We hold these truth@point{}
---------- Buffer: bar ----------
@end group
@end example
@end defun

@c   @xref{Sticky Properties}, for other insertion functions that inherit
@c text properties from the nearby text in addition to inserting it.
@c Whitespace inserted by indentation functions also inherits text
@c properties.
挿入に加えて周りのテキストからテキスト属性を継承する他の関数については、
@xref{Sticky Properties}。
字下げ関数が挿入した白文字もテキスト属性を継承します。

@node Commands for Insertion
@c @section User-Level Insertion Commands
@section ユーザーレベルの挿入コマンド

@c   This section describes higher-level commands for inserting text,
@c commands intended primarily for the user but useful also in Lisp
@c programs.
本節では、テキストを挿入する上位レベルのコマンドについて述べます。
これらはLispプログラムでも有用ですが主にユーザー向けのコマンドです。

@c @deffn Command insert-buffer from-buffer-or-name
@deffn コマンド insert-buffer from-buffer-or-name
@c This command inserts the entire contents of @var{from-buffer-or-name}
@c (which must exist) into the current buffer after point.  It leaves
@c the mark after the inserted text.  The value is @code{nil}.
このコマンドは、@var{from-buffer-or-name}（既存であること）の全内容を
カレントバッファのポイントのうしろに挿入する。
挿入されたテキストのうしろにマークを置く。
値は@code{nil}である。
@end deffn

@c @deffn Command self-insert-command count
@deffn コマンド self-insert-command count
@c @cindex character insertion
@c @cindex self-insertion
@cindex 文字の挿入
@cindex 自己挿入
@c This command inserts the last character typed; it does so @var{count}
@c times, before point, and returns @code{nil}.  Most printing characters
@c are bound to this command.  In routine use, @code{self-insert-command}
@c is the most frequently called function in Emacs, but programs rarely use
@c it except to install it on a keymap.
このコマンドは、最後に打たれた文字を挿入する。
ポイントのまえに@var{count}回挿入して@code{nil}を返す。
ほとんどの印字文字はこのコマンドにバインドされている。
普通の状況では、@code{self-insert-command}は
Emacsにおいてもっとも頻繁に呼び出される関数であるが、
プログラムではキーマップに登録する以外にはほとんど使わない。

@c In an interactive call, @var{count} is the numeric prefix argument.
対話的に呼ばれると、@var{count}は数値前置引数である。

@c This command calls @code{auto-fill-function} whenever that is
@c non-@code{nil} and the character inserted is a space or a newline
@c (@pxref{Auto Filling}).
このコマンドは、挿入した文字が空白や改行であると、
@code{auto-fill-function}が@code{nil}以外であると
@code{auto-fill-function}を呼び出す
（@pxref{Auto Filling}）。

@c @c Cross refs reworded to prevent overfull hbox.  --rjc 15mar92
@c This command performs abbrev expansion if Abbrev mode is enabled and
@c the inserted character does not have word-constituent
@c syntax. (@xref{Abbrevs}, and @ref{Syntax Class Table}.)
このコマンドは、略語（abbrev）モードがオンであり、かつ、
挿入した文字が単語構成構文でないと、略語展開を行う。
（@ref{Abbrevs}と@pxref{Syntax Class Table}。）

@c This is also responsible for calling @code{blink-paren-function} when
@c the inserted character has close parenthesis syntax (@pxref{Blinking}).
挿入した文字が閉じ括弧構文であるときに
@code{blink-paren-function}を呼び出す責任も持つ
（@pxref{Blinking}）。
@end deffn

@c @deffn Command newline &optional number-of-newlines 
@deffn コマンド newline &optional number-of-newlines 
@c This command inserts newlines into the current buffer before point.
@c If @var{number-of-newlines} is supplied, that many newline characters
@c are inserted.
このコマンドは、カレントバッファのポイントのまえに改行を挿入する。
@var{number-of-newlines}を指定すると、その個数だけ改行文字を挿入する。

@c @cindex newline and Auto Fill mode
@cindex 改行と自動詰め込み（auto-fill）モード
@c This function calls @code{auto-fill-function} if the current column
@c number is greater than the value of @code{fill-column} and
@c @var{number-of-newlines} is @code{nil}.  Typically what
@c @code{auto-fill-function} does is insert a newline; thus, the overall
@c result in this case is to insert two newlines at different places: one
@c at point, and another earlier in the line.  @code{newline} does not
@c auto-fill if @var{number-of-newlines} is non-@code{nil}.
この関数は、現在のコラム番号が@code{fill-column}の値よりも大きく
@var{number-of-newlines}が@code{nil}であると
@code{auto-fill-function}を呼び出す。
@code{auto-fill-function}の典型的な仕事は改行を挿入することである。
ここでの全体としての効果は、改行を2つの異なる位置、つまり、
ポイント位置と行のまえの箇所に挿入することである。
@code{newline}は、@var{number-of-newlines}が@code{nil}以外であると
自動詰め込みを行わない。

@c This command indents to the left margin if that is not zero.
@c @xref{Margins}.
このコマンドは、左端の余白が0以外であるとその分だけ字下げする。
@pxref{Margins}。

@c The value returned is @code{nil}.  In an interactive call, @var{count}
@c is the numeric prefix argument.
戻り値は@code{nil}である。
対話的に呼ばれると、@var{count}は数値前置引数である。
@end deffn

@c @deffn Command split-line
@deffn コマンド split-line
@c This command splits the current line, moving the portion of the line
@c after point down vertically so that it is on the next line directly
@c below where it was before.  Whitespace is inserted as needed at the
@c beginning of the lower line, using the @code{indent-to} function.
@c @code{split-line} returns the position of point.
このコマンドは、行のポイントのうしろの部分を垂直に降ろして
変更前の真下に行を移動することで現在行を分割する。
関数@code{indent-to}を用いて、降ろした行の先頭に必要に応じて白文字を挿入する。

@c Programs hardly ever use this function.
プログラムではまったくこの関数を使わない。
@end deffn

@defvar overwrite-mode
@c This variable controls whether overwrite mode is in effect.  The value
@c should be @code{overwrite-mode-textual}, @code{overwrite-mode-binary},
@c or @code{nil}.  @code{overwrite-mode-textual} specifies textual
@c overwrite mode (treats newlines and tabs specially), and
@c @code{overwrite-mode-binary} specifies binary overwrite mode (treats
@c newlines and tabs like any other characters).
この変数は、上書き（overwrite）モードがオンかどうかを制御する。
この値は、@code{overwrite-mode-textual}、@code{overwrite-mode-binary}、
@code{nil}のいずれかであること。
@code{overwrite-mode-textual}は、テキストの上書きモード
（改行とタブを特別に扱う）を指定し、
@code{overwrite-mode-binary}は、バイナリの上書きモード
（改行やタブも他の文字と同様に扱う）を指定する。
@end defvar

@node Deletion
@c @section Deleting Text
@section テキストの削除

@c @cindex deletion vs killing
@cindex 削除とキル
@c   Deletion means removing part of the text in a buffer, without saving
@c it in the kill ring (@pxref{The Kill Ring}).  Deleted text can't be
@c yanked, but can be reinserted using the undo mechanism (@pxref{Undo}).
@c Some deletion functions do save text in the kill ring in some special
@c cases.
削除とは、バッファ内のテキストのある部分をキルリング
（@pxref{The Kill Ring}）に保存せずに取りさることです。
削除したテキストはヤンクはできませんが、
アンドゥ機構（@pxref{Undo}）を使って再度挿入できます。
特別な場合にはキルリングにテキストを保存する削除関数もあります。

@c   All of the deletion functions operate on the current buffer, and all
@c return a value of @code{nil}.
すべての削除関数はカレントバッファに作用し、@code{nil}の値を返します。

@c @deffn Command erase-buffer
@deffn コマンド erase-buffer
@c This function deletes the entire text of the current buffer, leaving it
@c empty.  If the buffer is read-only, it signals a @code{buffer-read-only}
@c error.  Otherwise, it deletes the text without asking for any
@c confirmation.  It returns @code{nil}.
この関数は、カレントバッファから全テキストを削除して空にする。
バッファが読み出し専用であると、エラー@code{buffer-read-only}を通知する。
さもなければ、いっさい確認を取らずにテキストを削除する。
@code{nil}を返す。

@c Normally, deleting a large amount of text from a buffer inhibits further
@c auto-saving of that buffer ``because it has shrunk''.  However,
@c @code{erase-buffer} does not do this, the idea being that the future
@c text is not really related to the former text, and its size should not
@c be compared with that of the former text.
バッファから多量のテキストを削除すると、通常、
『バッファが縮小した』としてそのバッファの自動保存を禁止する。
しかし、@code{erase-buffer}はこうしない。
これまでのテキストと将来のテキストには関連がなく、
これまでのテキストのサイズと比較すべきでないと考えるからである。
@end deffn

@c @deffn Command delete-region start end
@deffn コマンド delete-region start end
@c This command deletes the text in the current buffer in the region
@c defined by @var{start} and @var{end}.  The value is @code{nil}.  If
@c point was inside the deleted region, its value afterward is @var{start}.
@c Otherwise, point relocates with the surrounding text, as markers do.
このコマンドは、@var{start}と@var{end}で定義されるカレントバッファの
テキストを削除する。
戻り値は@code{nil}である。
削除された領域の内側にポイントがあると、
その値は削除後には@var{start}になる。
さもなければ、マーカと同様にポイントは
周りのテキストに留まるように再配置される。
@end deffn

@c @deffn Command delete-char count &optional killp
@deffn コマンド delete-char count &optional killp
@c This command deletes @var{count} characters directly after point, or
@c before point if @var{count} is negative.  If @var{killp} is
@c non-@code{nil}, then it saves the deleted characters in the kill ring.
このコマンドは、ポイントの直後の、あるいは、
@var{count}が負であるとポイントの直前の@var{count}個の文字を削除する。
@var{killp}が@code{nil}以外であると、
削除した文字をキルリングに保存する。

@c In an interactive call, @var{count} is the numeric prefix argument, and
@c @var{killp} is the unprocessed prefix argument.  Therefore, if a prefix
@c argument is supplied, the text is saved in the kill ring.  If no prefix
@c argument is supplied, then one character is deleted, but not saved in
@c the kill ring.
対話的に呼ばれると、@var{count}は数値前置引数であり、
@var{killp}は未処理の前置引数である。
つまり、前置引数を指定すると、テキストをキルリングに保存する。
前置引数を指定しないと1文字だけを削除するが、
キルリングには保存しない。

@c The value returned is always @code{nil}.
戻り値はつねに@code{nil}である。
@end deffn

@c @deffn Command delete-backward-char count &optional killp
@deffn コマンド delete-backward-char count &optional killp
@c @cindex delete previous char
@cindex 直前の文字を削除
@c This command deletes @var{count} characters directly before point, or
@c after point if @var{count} is negative.  If @var{killp} is
@c non-@code{nil}, then it saves the deleted characters in the kill ring.
このコマンドは、ポイントの直前の、あるいは、
@var{count}が負であるとポイントの直後の@var{count}個の文字を削除する。
@var{killp}が@code{nil}以外であると、
削除した文字をキルリングに保存する。

@c In an interactive call, @var{count} is the numeric prefix argument, and
@c @var{killp} is the unprocessed prefix argument.  Therefore, if a prefix
@c argument is supplied, the text is saved in the kill ring.  If no prefix
@c argument is supplied, then one character is deleted, but not saved in
@c the kill ring.
対話的に呼ばれると、@var{count}は数値前置引数であり、
@var{killp}は未処理の前置引数である。
つまり、前置引数を指定すると、テキストをキルリングに保存する。
前置引数を指定しないと1文字だけを削除するが、
キルリングには保存しない。

@c The value returned is always @code{nil}.
戻り値はつねに@code{nil}である。
@end deffn

@c @deffn Command backward-delete-char-untabify count &optional killp
@deffn コマンド backward-delete-char-untabify count &optional killp
@c @cindex tab deletion
@cindex タブの削除
@c This command deletes @var{count} characters backward, changing tabs
@c into spaces.  When the next character to be deleted is a tab, it is
@c first replaced with the proper number of spaces to preserve alignment
@c and then one of those spaces is deleted instead of the tab.  If
@c @var{killp} is non-@code{nil}, then the command saves the deleted
@c characters in the kill ring.
このコマンドは、タブを空白にかえながら後向きに@var{count}個の文字を削除する。
つぎに削除する文字がタブであると、まずタブを配置を保つだけの等価な個数の
空白に置換してから、タブのかわりにそれらの空白を削除する。
@var{killp}が@code{nil}以外であると、このコマンドは
削除した文字をキルリングに保存する。

@c Conversion of tabs to spaces happens only if @var{count} is positive.
@c If it is negative, exactly @minus{}@var{count} characters after point
@c are deleted.
@var{count}が正である場合に限って、タブを空白に変換する。
@var{count}が負であると、ポイントのうしろのちょうど
@minus{}@var{count}個の文字を削除する。

@c In an interactive call, @var{count} is the numeric prefix argument, and
@c @var{killp} is the unprocessed prefix argument.  Therefore, if a prefix
@c argument is supplied, the text is saved in the kill ring.  If no prefix
@c argument is supplied, then one character is deleted, but not saved in
@c the kill ring.
対話的に呼ばれると、@var{count}は数値前置引数であり、
@var{killp}は未処理の前置引数である。
つまり、前置引数を指定すると、テキストをキルリングに保存する。
前置引数を指定しないと1文字だけを削除するが、
キルリングには保存しない。

@c The value returned is always @code{nil}.
戻り値はつねに@code{nil}である。
@end deffn

@defopt backward-delete-char-untabify-method
@tindex backward-delete-char-untabify-method
@c This option specifies how @code{backward-delete-char-untabify} should
@c deal with whitespace.  Possible values include @code{untabify}, the
@c default, meaning convert a tab to many spaces and delete one;
@c @code{hungry}, meaning delete all the whitespace characters before point
@c with one command, and @code{nil}, meaning do nothing special for
@c whitespace characters.
このオプションは、@code{backward-delete-char-untabify}での
白文字の扱い方を指定する。
可能な値は、タブを空白に変換してから空白を削除することを意味する
デフォルトの@code{untabify}、
1回の呼び出しでポイントのまえにある白文字をすべて削除することを意味する
@code{hungry}、
白文字に対して特別なことをしないことを意味する@code{nil}である。
@end defopt

@node User-Level Deletion
@c @section User-Level Deletion Commands
@section ユーザーレベルの削除コマンド

@c   This section describes higher-level commands for deleting text,
@c commands intended primarily for the user but useful also in Lisp
@c programs.
本節では、テキストを削除する上位レベルのコマンドについて述べます。
これらはLispプログラムでも有用ですが主にユーザー向けのコマンドです。

@c @deffn Command delete-horizontal-space
@deffn コマンド delete-horizontal-space
@c @cindex deleting whitespace
@cindex 白文字の削除
@c This function deletes all spaces and tabs around point.  It returns
@c @code{nil}.
この関数は、ポイントの周りの空白やタブをすべて削除する。
@code{nil}を返す。

@c In the following examples, we call @code{delete-horizontal-space} four
@c times, once on each line, with point between the second and third
@c characters on the line each time.
つぎの例では、毎回ポイントを2番目と3番目の文字のあいだに置いて、
各行につき1回ずつ@code{delete-horizontal-space}を計4回呼び出す。

@example
@group
---------- Buffer: foo ----------
I @point{}thought
I @point{}     thought
We@point{} thought
Yo@point{}u thought
---------- Buffer: foo ----------
@end group

@group
(delete-horizontal-space)   ; @r{Four times.}
     @result{} nil

---------- Buffer: foo ----------
Ithought
Ithought
Wethought
You thought
---------- Buffer: foo ----------
@end group
@end example
@end deffn

@c @deffn Command delete-indentation &optional join-following-p 
@deffn コマンド delete-indentation &optional join-following-p 
@c This function joins the line point is on to the previous line, deleting
@c any whitespace at the join and in some cases replacing it with one
@c space.  If @var{join-following-p} is non-@code{nil},
@c @code{delete-indentation} joins this line to the following line
@c instead.  The function returns @code{nil}.
この関数は、ポイントがある行をそのまえの行に連結する。
連結箇所の白文字は削除し、場合によっては空白1個に置き換える。
@var{join-following-p}が@code{nil}以外であると、
@code{delete-indentation}は、この行を後続の行に連結する。
関数は@code{nil}を返す。

@c If there is a fill prefix, and the second of the lines being joined
@c starts with the prefix, then @code{delete-indentation} deletes the
@c fill prefix before joining the lines.  @xref{Margins}.
詰め込み接頭辞があり、かつ、連結対象の2番目の行が
その接頭辞で始まっている場合には、
@code{delete-indentation}は連結するまえに詰め込み接頭辞を削除する。
@pxref{Margins}。

@c In the example below, point is located on the line starting
@c @samp{events}, and it makes no difference if there are trailing spaces
@c in the preceding line.
以下の例では、ポイントは@samp{events}で始まる行にあり、
そのまえの行の行末に空白があっても違いはない。

@smallexample
@group
---------- Buffer: foo ----------
When in the course of human
@point{}    events, it becomes necessary
---------- Buffer: foo ----------
@end group

(delete-indentation)
     @result{} nil

@group
---------- Buffer: foo ----------
When in the course of human@point{} events, it becomes necessary
---------- Buffer: foo ----------
@end group
@end smallexample

@c After the lines are joined, the function @code{fixup-whitespace} is
@c responsible for deciding whether to leave a space at the junction.
行を連結したあと、
関数@code{fixup-whitespace}には、
連結箇所に空白を置くかどうかを決定する責任がある。
@end deffn

@defun fixup-whitespace
@c This function replaces all the whitespace surrounding point with either
@c one space or no space, according to the context.  It returns @code{nil}.
この関数は、文脈に応じて、
ポイントを囲む白文字すべてを1つの空白に置換するかまったくなくす。
@code{nil}を返す。

@c At the beginning or end of a line, the appropriate amount of space is
@c none.  Before a character with close parenthesis syntax, or after a
@c character with open parenthesis or expression-prefix syntax, no space is
@c also appropriate.  Otherwise, one space is appropriate.  @xref{Syntax
@c Class Table}.
行の先頭や末尾では、空白の適切な量は0である。
閉じ括弧構文の文字のまえや、
開き括弧構文や式前置子構文の文字のうしろでも空白はないほうが適している。
それ以外では、空白1個が適している。
@pxref{Syntax Class Table}。

@c In the example below, @code{fixup-whitespace} is called the first time
@c with point before the word @samp{spaces} in the first line.  For the
@c second invocation, point is directly after the @samp{(}.
以下の例では、最初の行の単語@samp{spaces}のまえにポイントがあるときに
最初に@code{fixup-whitespace}が呼ばれる。
2度目に呼ばれるときには、ポイントは@samp{(}の直後にある。

@smallexample
@group
---------- Buffer: foo ----------
This has too many     @point{}spaces
This has too many spaces at the start of (@point{}   this list)
---------- Buffer: foo ----------
@end group

@group
(fixup-whitespace)
     @result{} nil
(fixup-whitespace)
     @result{} nil
@end group

@group
---------- Buffer: foo ----------
This has too many spaces
This has too many spaces at the start of (this list)
---------- Buffer: foo ----------
@end group
@end smallexample
@end defun

@c @deffn Command just-one-space
@deffn コマンド just-one-space
@comment !!SourceFile simple.el
@c This command replaces any spaces and tabs around point with a single
@c space.  It returns @code{nil}.
このコマンドは、ポイントの周りのすべての空白やタブを1個の空白に置き換える。
@code{nil}を返す。
@end deffn

@c @deffn Command delete-blank-lines
@deffn コマンド delete-blank-lines
@c This function deletes blank lines surrounding point.  If point is on a
@c blank line with one or more blank lines before or after it, then all but
@c one of them are deleted.  If point is on an isolated blank line, then it
@c is deleted.  If point is on a nonblank line, the command deletes all
@c blank lines following it.
この関数は、ポイントを囲む空行を削除する。
前後に複数の空行がある空行にポイントがある場合、
1つの空行を残してそれ以外はすべて削除する。
孤立した1つの空行にポイントがある場合には、その行を削除する。
空行でない行にポイントがある場合には、
その行のうしろにある空行をすべて削除する。

@c A blank line is defined as a line containing only tabs and spaces.
空行とは、タブや空白のみから成る行と定義する。

@c @code{delete-blank-lines} returns @code{nil}.
@code{delete-blank-lines}は@code{nil}を返す。
@end deffn

@node The Kill Ring
@c @section The Kill Ring
@section キルリング
@c @cindex kill ring
@cindex キルリング

@c   @dfn{Kill functions} delete text like the deletion functions, but save
@c it so that the user can reinsert it by @dfn{yanking}.  Most of these
@c functions have @samp{kill-} in their name.  By contrast, the functions
@c whose names start with @samp{delete-} normally do not save text for
@c yanking (though they can still be undone); these are ``deletion''
@c functions.
@dfn{キル関数}は削除関数のようにテキストを削除しますが、
ユーザーが@dfn{ヤンク}（yank）で再度挿入できるように保存します。
これらの関数の多くは、その名前に@samp{kill-}があります。
対照的に、@samp{delete-}で始まる名前の関数は、
ヤンクできるようにテキストを保存しません（アンドゥはできる）。
それらは『削除』関数です。

@c   Most of the kill commands are primarily for interactive use, and are
@c not described here.  What we do describe are the functions provided for
@c use in writing such commands.  You can use these functions to write
@c commands for killing text.  When you need to delete text for internal
@c purposes within a Lisp function, you should normally use deletion
@c functions, so as not to disturb the kill ring contents.
@c @xref{Deletion}.
キルコマンドの多くは主に対話的に使うものであり、
ここではそれらについては述べません。
ここで述べるのは、そのようなコマンドを書くために使う関数についてです。
これらの関数は読者がテキストをキルするコマンドを書くために使えます。
Lisp関数において内部目的のためにテキストを削除する必要があるときには、
キルリングの内容を乱さないように普通は削除関数を用いるべきです。
@xref{Deletion}。

@c   Killed text is saved for later yanking in the @dfn{kill ring}.  This
@c is a list that holds a number of recent kills, not just the last text
@c kill.  We call this a ``ring'' because yanking treats it as having
@c elements in a cyclic order.  The list is kept in the variable
@c @code{kill-ring}, and can be operated on with the usual functions for
@c lists; there are also specialized functions, described in this section,
@c that treat it as a ring.
キルしたテキストはあとでヤンクできるように
@dfn{キルリング}（kill ring）に保存されます。
これは、最後にキルしたテキストだけでなく、
最近キルしたものを多数保持するリストです。
これを『リング』と呼ぶのは、
要素が循環しているようにヤンクが扱うからです。
このリストは変数@code{kill-ring}に保持されていて、
リスト向けの通常の関数で操作できますが、
本節で述べるように、それをリングとして扱う特別な関数もあります。

@c   Some people think this use of the word ``kill'' is unfortunate, since
@c it refers to operations that specifically @emph{do not} destroy the
@c entities ``killed''.  This is in sharp contrast to ordinary life, in
@c which death is permanent and ``killed'' entities do not come back to
@c life.  Therefore, other metaphors have been proposed.  For example, the
@c term ``cut ring'' makes sense to people who, in pre-computer days, used
@c scissors and paste to cut up and rearrange manuscripts.  However, it
@c would be difficult to change the terminology now.
単語『キル』の使い方が不適当だと考える人々がいます。
『キル』したものを特に破壊@emph{しない}操作を表すために使っているからです。
日常生活に照らしてみると、死は恒久的であり『キル』したものが
生き返ることはありません。
したがって、別の隠喩も提案されています。
たとえば、原稿を鋏で切り貼りすることに慣れていた前計算機世代の人々には
『カットリング』のほうが意味が通じるでしょう。
しかし、いまさら用語を変更するのは困難です。

@menu
* Kill Ring Concepts::     What text looks like in the kill ring.
* Kill Functions::         Functions that kill text.
* Yank Commands::          Commands that access the kill ring.
* Low-Level Kill Ring::	   Functions and variables for kill ring access.
* Internals of Kill Ring:: Variables that hold kill-ring data.
@end menu

@node Kill Ring Concepts
@comment  node-name,  next,  previous,  up
@c @subsection Kill Ring Concepts
@subsection キルリングの概念

@c   The kill ring records killed text as strings in a list, most recent
@c first.  A short kill ring, for example, might look like this:
キルリングは、もっとも最近にキルされたものを先頭にして、
キルされたテキストを文字列としてリストに記録します。
たとえば、短いキルリングはつぎのようになります。

@example
("some text" "a different piece of text" "even older text")
@end example

@noindent
@c When the list reaches @code{kill-ring-max} entries in length, adding a
@c new entry automatically deletes the last entry.
リストの長さが@code{kill-ring-max}に達すると、
新たな項目を追加すると自動的に最後の項目を削除します。

@c   When kill commands are interwoven with other commands, each kill
@c command makes a new entry in the kill ring.  Multiple kill commands in
@c succession build up a single kill-ring entry, which would be yanked as a
@c unit; the second and subsequent consecutive kill commands add text to
@c the entry made by the first one.
キルコマンドが他のコマンドと混在する場合、
各キルコマンドはキルリングに新たな項目を追加します。
連続した複数のキルコマンドは、キルリングに1つの項目を作りあげ、
それを1個としてヤンクできます。
2番目以降の連続したキルコマンドは、最初のキルコマンドが作った
項目にテキストを追加していきます。

@c   For yanking, one entry in the kill ring is designated the ``front'' of
@c the ring.  Some yank commands ``rotate'' the ring by designating a
@c different element as the ``front.''  But this virtual rotation doesn't
@c change the list itself---the most recent entry always comes first in the
@c list.
ヤンクでは、キルリングの1つの項目をリングの『先頭』として区別します。
リングの別の項目を『先頭』と指定することでリングを『回転』する
コマンドもあります。

@node Kill Functions
@comment  node-name,  next,  previous,  up
@c @subsection Functions for Killing
@subsection キル向けの関数

@c   @code{kill-region} is the usual subroutine for killing text.  Any
@c command that calls this function is a ``kill command'' (and should
@c probably have @samp{kill} in its name).  @code{kill-region} puts the
@c newly killed text in a new element at the beginning of the kill ring or
@c adds it to the most recent element.  It determines automatically (using
@c @code{last-command}) whether the previous command was a kill command,
@c and if so appends the killed text to the most recent entry.
@code{kill-region}は、テキストをキルするための普通のサブルーティンです。
この関数を呼び出す任意のコマンドは『キルコマンド』です
（その名前には@samp{kill}があるはず）。
@code{kill-region}は、新たにキルされたテキストを
キルリングの先頭に新たな項目として追加したり、
もっとも最近の項目に加えます。
まえのコマンドがキルコマンドであるかどうかを
（@code{last-command}を使って）自動的に判定し、
もしそうならば、キルされたテキストをもっとも最近の項目に加えます。

@c @deffn Command kill-region start end
@deffn コマンド kill-region start end
@c This function kills the text in the region defined by @var{start} and
@c @var{end}.  The text is deleted but saved in the kill ring, along with
@c its text properties.  The value is always @code{nil}.
この関数は、@var{start}と@var{end}で定義される領域のテキストをキルする。
テキストは削除されるが、テキスト属性とともにキルリングに保存される。
値はつねに@code{nil}である。

@c In an interactive call, @var{start} and @var{end} are point and
@c the mark.
対話的に呼ばれると、@var{start}と@var{end}はポイントとマークである。

@c @c Emacs 19 feature
@c If the buffer is read-only, @code{kill-region} modifies the kill ring
@c just the same, then signals an error without modifying the buffer.  This
@c is convenient because it lets the user use all the kill commands to copy
@c text into the kill ring from a read-only buffer.
バッファが読み出し専用であると、
@code{kill-region}はキルリングを同様に変更するが、
バッファを変更せずにエラーを通知する。
読み出し専用バッファからキルリングへテキストをコピーするために、
ユーザーはすべてのキルコマンドを使えるのでこれは便利である。
@end deffn

@defopt kill-read-only-ok
@c If this option is non-@code{nil}, @code{kill-region} does not get an
@c error if the buffer is read-only.  Instead, it simply returns, updating
@c the kill ring but not changing the buffer.
このオプションが@code{nil}以外であると、
@code{kill-region}は、バッファが読み出し専用であってもエラーとしない。
そのかわりに、キルリングを更新しバッファは変更せずに戻る。
@end defopt

@c @deffn Command copy-region-as-kill start end
@deffn コマンド copy-region-as-kill start end
@c This command saves the region defined by @var{start} and @var{end} on
@c the kill ring (including text properties), but does not delete the text
@c from the buffer.  It returns @code{nil}.  It also indicates the extent
@c of the text copied by moving the cursor momentarily, or by displaying a
@c message in the echo area.
このコマンドは、@var{start}と@var{end}で定義される領域を
（テキスト属性とともに）キルリングに保存するが、
バッファからテキストを削除しない。
@code{nil}を返す。
また、カーソルを一時的に移動してコピーしたテキストの範囲を示すか、
あるいは、エコー領域にメッセージを表示する。

@c The command does not set @code{this-command} to @code{kill-region}, so a
@c subsequent kill command does not append to the same kill ring entry.
このコマンドは@code{this-command}に@code{kill-region}を設定しないので、
これ以降のキルコマンドはキルリングの同じ項目には加えない。

@c Don't call @code{copy-region-as-kill} in Lisp programs unless you aim to
@c support Emacs 18.  For newer Emacs versions, it is better to use
@c @code{kill-new} or @code{kill-append} instead.  @xref{Low-Level Kill
@c Ring}.
Emacs 18版でも使うつもりがない限り、
Lispプログラムからは@code{copy-region-as-kill}を呼ばないこと。
Emacsの新しい版では、そのかわりに@code{kill-new}や@code{kill-append}を
使うほうがよい。
@pxref{Low-Level Kill Ring}。
@end deffn

@node Yank Commands
@comment  node-name,  next,  previous,  up
@c @subsection Functions for Yanking
@subsection ヤンク向けの関数

@c   @dfn{Yanking} means reinserting an entry of previously killed text
@c from the kill ring.  The text properties are copied too.
@dfn{ヤンク}（yank）とは、キルリングからまえにキルされたテキストの項目を
再度挿入することです。

@c @deffn Command yank &optional arg
@deffn コマンド yank &optional arg
@c @cindex inserting killed text
@cindex キルされたテキストの挿入
@c This command inserts before point the text in the first entry in the
@c kill ring.  It positions the mark at the beginning of that text, and
@c point at the end.
このコマンドは、キルリングの先頭項目のテキストを
ポイントのまえに挿入する。
そのテキストの先頭にマークを末尾にポイントを置く。

@c If @var{arg} is a list (which occurs interactively when the user
@c types @kbd{C-u} with no digits), then @code{yank} inserts the text as
@c described above, but puts point before the yanked text and puts the mark
@c after it.
@var{arg}がリスト（対話的な呼び出しではユーザーが数字文字なしに
@kbd{C-u}を打ったとき）であると、@code{yank}は上に述べたように
テキストを挿入するが、ヤンクしたテキストの先頭にポイントを
末尾にマークを置く。

@c If @var{arg} is a number, then @code{yank} inserts the @var{arg}th most
@c recently killed text---the @var{arg}th element of the kill ring list.
@var{arg}が数であると、@code{yank}は@var{arg}番目のもっとも最近に
キルされたテキスト、つまり、キルリングリストの@var{arg}番目の項目を
挿入する。

@c @code{yank} does not alter the contents of the kill ring or rotate it.
@c It returns @code{nil}.
@code{yank}はキルリングの内容を変更したり回転しない。
@code{nil}を返す。
@end deffn

@c @deffn Command yank-pop arg
@deffn コマンド yank-pop arg
@c This command replaces the just-yanked entry from the kill ring with a
@c different entry from the kill ring.
このコマンドは、キルリングからヤンクした項目を
キルリングの別の項目で置き換える。

@c This is allowed only immediately after a @code{yank} or another
@c @code{yank-pop}.  At such a time, the region contains text that was just
@c inserted by yanking.  @code{yank-pop} deletes that text and inserts in
@c its place a different piece of killed text.  It does not add the deleted
@c text to the kill ring, since it is already in the kill ring somewhere.
これは@code{yank}や別の@code{yank-pop}の直後でのみ許される。
そのような場合、リージョンにはヤンクしたばかりのテキストが含まれる。
@code{yank-pop}はそのテキストを削除し、
その位置にキルされた別のテキストを挿入する。
削除したテキストはすでにキルリングのどこかにあるので、
キルリングには追加しない。

@c If @var{arg} is @code{nil}, then the replacement text is the previous
@c element of the kill ring.  If @var{arg} is numeric, the replacement is
@c the @var{arg}th previous kill.  If @var{arg} is negative, a more recent
@c kill is the replacement.
@var{arg}が@code{nil}であると、キルリングの古い項目で置き換える。
@var{arg}が数であると、@var{arg}番古いキルで置き換える。
@var{arg}が負であると、より最近のキルで置き換える。

@c The sequence of kills in the kill ring wraps around, so that after the
@c oldest one comes the newest one, and before the newest one goes the
@c oldest.
キルリング内でのキルの順番は、
最古のもののつぎに最新のものがあり、
最新のもののまえに最古のものがあるように折り返されている。

@c The return value is always @code{nil}.
戻り値はつねに@code{nil}である。
@end deffn

@node Low-Level Kill Ring
@c @subsection Low-Level Kill Ring
@subsection 下位レベルのキルリング

@c   These functions and variables provide access to the kill ring at a
@c lower level, but still convenient for use in Lisp programs, because they
@c take care of interaction with window system selections
@c (@pxref{Window System Selections}).
これらの関数と変数は、下位レベルでキルリングを参照するためのものですが、
Lispプログラムで使っても便利です。
これらはウィンドウシステムのセレクション（@pxref{Window System Selections}）
との相互作用の面倒をみてくれるからです。

@defun current-kill n &optional do-not-move
@c The function @code{current-kill} rotates the yanking pointer, which
@c designates the ``front'' of the kill ring, by @var{n} places (from newer
@c kills to older ones), and returns the text at that place in the ring.
関数@code{current-kill}は、キルリングの『先頭』として区別する
ヤンクポインタを（新しいキルから古いキルへ向けて）@var{n}個分回転し、
リングのその位置のテキストを返す。

@c If the optional second argument @var{do-not-move} is non-@code{nil},
@c then @code{current-kill} doesn't alter the yanking pointer; it just
@c returns the @var{n}th kill, counting from the current yanking pointer.
省略可能な第2引数@var{do-not-move}が@code{nil}以外であると、
@code{current-kill}は、ヤンクポインタは変更せずに、
現在のヤンクポインタから数えて@var{n}番目のキルを返す。

@c If @var{n} is zero, indicating a request for the latest kill,
@c @code{current-kill} calls the value of
@c @code{interprogram-paste-function} (documented below) before consulting
@c the kill ring.
@var{n}が0であると、もっとも最近のキルを要求することを表し、
@code{current-kill}は、キルリングを調べるまえに
（以下に述べる）@code{interprogram-paste-function}の値を呼び出す。
@end defun

@defun kill-new string
@c This function puts the text @var{string} into the kill ring as a new
@c entry at the front of the ring.  It discards the oldest entry if
@c appropriate.  It also invokes the value of
@c @code{interprogram-cut-function} (see below).
この関数は、テキスト@var{string}を新たな項目として
キルリングの先頭に置く。
必要ならば最古の項目を破棄する。
@code{interprogram-cut-function}（下記参照）の値も起動する。
@end defun

@defun kill-append string before-p
@c This function appends the text @var{string} to the first entry in the
@c kill ring.  Normally @var{string} goes at the end of the entry, but if
@c @var{before-p} is non-@code{nil}, it goes at the beginning.  This
@c function also invokes the value of @code{interprogram-cut-function} (see
@c below).
この関数は、キルリングの先頭項目にテキスト@var{string}を追加する。
通常、@var{string}はその項目の末尾に加わるが、
@var{before-p}が@code{nil}以外であるとその項目の先頭に加わる。
この関数は、@code{interprogram-cut-function}（下記参照）の値も起動する。
@end defun

@defvar interprogram-paste-function
@c This variable provides a way of transferring killed text from other
@c programs, when you are using a window system.  Its value should be
@c @code{nil} or a function of no arguments.
この変数は、ウィンドウシステムを使っているときに
別のプログラムからキルされたテキストを転送する方法を提供する。
その値は、@code{nil}であるか、引数なしの関数であること。

@c If the value is a function, @code{current-kill} calls it to get the
@c ``most recent kill''.  If the function returns a non-@code{nil} value,
@c then that value is used as the ``most recent kill''.  If it returns
@c @code{nil}, then the first element of @code{kill-ring} is used.
値が関数であると、
『もっとも最近のキル』を得るために@code{current-kill}が呼び出す。
関数が@code{nil}以外の値を返すと、
その値は『もっとも最近のキル』として使われる。
@code{nil}を返せば、@code{kill-ring}の先頭項目が使われる。

@c The normal use of this hook is to get the window system's primary
@c selection as the most recent kill, even if the selection belongs to
@c another application.  @xref{Window System Selections}.
このフックの普通の用途は、
セレクションが別のアプリケーションに属する場合であっても、
ウィンドウシステムの一次セレクションを
もっとも最近のキルとして得ることである。
@pxref{Window System Selections}。
@end defvar

@defvar interprogram-cut-function
@c This variable provides a way of communicating killed text to other
@c programs, when you are using a window system.  Its value should be
@c @code{nil} or a function of one argument.
この変数は、ウィンドウシステムを使っているときに
キルされたテキストを別のプログラムへ転送する方法を提供する。
その値は、@code{nil}であるか、引数なしの関数であること。

@c If the value is a function, @code{kill-new} and @code{kill-append} call
@c it with the new first element of the kill ring as an argument.
値が関数であると、@code{kill-new}と@code{kill-append}が
キルリングの新たな先頭項目を引数として呼び出す。

@c The normal use of this hook is to set the window system's primary
@c selection from the newly killed text.  @xref{Window System Selections}.
このフックの普通の用途は、
新たにキルされたテキストを
ウィンドウシステムの一次セレクションにすることである。
@pxref{Window System Selections}。
@end defvar

@node Internals of Kill Ring
@comment  node-name,  next,  previous,  up
@c @subsection Internals of the Kill Ring
@subsection キルリングの内部

@c   The variable @code{kill-ring} holds the kill ring contents, in the
@c form of a list of strings.  The most recent kill is always at the front
@c of the list. 
変数@code{kill-ring}は、文字列のリストの形でキルリングの内容を保持します。
もっとも最近のキルがつねにリストの先頭にあります。

@c   The @code{kill-ring-yank-pointer} variable points to a link in the
@c kill ring list, whose @sc{car} is the text to yank next.  We say it
@c identifies the ``front'' of the ring.  Moving
@c @code{kill-ring-yank-pointer} to a different link is called
@c @dfn{rotating the kill ring}.  We call the kill ring a ``ring'' because
@c the functions that move the yank pointer wrap around from the end of the
@c list to the beginning, or vice-versa.  Rotation of the kill ring is
@c virtual; it does not change the value of @code{kill-ring}.
変数@code{kill-ring-yank-pointer}は、
@sc{car}がつぎにヤンクすべきテキストであるような
キルリングリストの項目を指しています。
この変数がリングの『先頭』を識別するといいます。
@code{kill-ring-yank-pointer}を別の項目へ動かすことを
@dfn{キルリングを回転する}と呼びます。
ヤンクポインタを動かす関数は、
リストの末尾からリストの先頭へ折り返しその逆も行うので、
キルリングを『リング』と呼ぶのです。
リングの回転は仮想的なものであり、
@code{kill-ring}の値は変更しません。

@c   Both @code{kill-ring} and @code{kill-ring-yank-pointer} are Lisp
@c variables whose values are normally lists.  The word ``pointer'' in the
@c name of the @code{kill-ring-yank-pointer} indicates that the variable's
@c purpose is to identify one element of the list for use by the next yank
@c command.
@code{kill-ring}も@code{kill-ring-yank-pointer}もLisp変数であり、
それらの値は普通のリストです。
@code{kill-ring-yank-pointer}の名前の単語『ポインタ』は、
つぎのヤンクコマンドで使うリストの項目を識別することが
変数の目的であることを表します。

@c   The value of @code{kill-ring-yank-pointer} is always @code{eq} to one
@c of the links in the kill ring list.  The element it identifies is the
@c @sc{car} of that link.  Kill commands, which change the kill ring, also
@c set this variable to the value of @code{kill-ring}.  The effect is to
@c rotate the ring so that the newly killed text is at the front.
@code{kill-ring-yank-pointer}の値は、キルリングリストの
1つの項目とつねに@code{eq}です。
これが識別する項目は、その項目の@sc{car}です。
キルリングを変更するキルコマンドも、
@code{kill-ring}の値をこの変数の値とします。
その効果は、新たにキルされたテキストが先頭にくるように
リングを回転することです。

@c   Here is a diagram that shows the variable @code{kill-ring-yank-pointer}
@c pointing to the second entry in the kill ring @code{("some text" "a
@c different piece of text" "yet older text")}.  
キルリング@code{("some text" "a different piece of text" "yet older text")}の
第2項目を変数@code{kill-ring-yank-pointer}が指しているようすをつぎに示します。

@example
@group
kill-ring                  ---- kill-ring-yank-pointer
  |                       |
  |                       v
  |     --- ---          --- ---      --- ---
   --> |   |   |------> |   |   |--> |   |   |--> nil
        --- ---          --- ---      --- ---
         |                |            |            
         |                |            |            
         |                |             -->"yet older text" 
         |                |
         |                 --> "a different piece of text" 
         |
          --> "some text"
@end group
@end example

@noindent
@c This state of affairs might occur after @kbd{C-y} (@code{yank})
@c immediately followed by @kbd{M-y} (@code{yank-pop}).
@kbd{C-y}（@code{yank}）の直後に@kbd{M-y}（@code{yank-pop}）を使うと
この状態になります。

@defvar kill-ring
@c This variable holds the list of killed text sequences, most recently
@c killed first.
この変数は、もっとも最近にキルされたものを最初にして
キルされたテキストを順に並べたリストを保持する。
@end defvar

@defvar kill-ring-yank-pointer
@c This variable's value indicates which element of the kill ring is at the
@c ``front'' of the ring for yanking.  More precisely, the value is a tail
@c of the value of @code{kill-ring}, and its @sc{car} is the kill string
@c that @kbd{C-y} should yank.
この変数の値は、キルリングのどの要素が
ヤンクするためのリングの『先頭』であるかを表す。
より正確には、その値は@code{kill-ring}のリストの一部であり、
その@sc{car}は@kbd{C-y}がヤンクするキルされた文字列である。
@end defvar

@defopt kill-ring-max
@c The value of this variable is the maximum length to which the kill
@c ring can grow, before elements are thrown away at the end.  The default
@c value for @code{kill-ring-max} is 30.
この変数の値は、末尾の要素が破棄されるまでに
キルリングが増大できる最大の長さである。
@code{kill-ring-max}のデフォルト値は30である。
@end defopt

@node Undo
@comment  node-name,  next,  previous,  up
@c @section Undo
@section アンドゥ
@c @cindex redo
@cindex リドゥ

@c   Most buffers have an @dfn{undo list}, which records all changes made
@c to the buffer's text so that they can be undone.  (The buffers that
@c don't have one are usually special-purpose buffers for which Emacs
@c assumes that undoing is not useful.)  All the primitives that modify the
@c text in the buffer automatically add elements to the front of the undo
@c list, which is in the variable @code{buffer-undo-list}.
ほとんどのバッファには、バッファのテキストに対する変更をアンドゥ（もとに戻す）
できるようにすべての変更を記録する
@dfn{アンドゥリスト}（undo list）があります。
（アンドゥリストのないバッファは、
Emacsがアンドゥは有用ではないと仮定する特殊目的のバッファである。）
バッファのテキストを変更するすべての基本関数は、
変数@code{buffer-undo-list}に収めたアンドゥリストの先頭に
自動的に要素を追加します。

@defvar buffer-undo-list
@c This variable's value is the undo list of the current buffer.
@c A value of @code{t} disables the recording of undo information.
この変数の値は、カレントバッファのアンドゥリストである。
値@code{t}はアンドゥ情報の記録を禁止する。
@end defvar

@c Here are the kinds of elements an undo list can have:
アンドゥリストの要素として可能なものをつぎに示します。

@table @code
@item @var{position}
@c This kind of element records a previous value of point; undoing this
@c element moves point to @var{position}.  Ordinary cursor motion does not
@c make any sort of undo record, but deletion operations use these entries
@c to record where point was before the command.
この種の要素は、まえのポイント値を記録する。
この要素をアンドゥするとポイントを@var{position}へ移動する。
通常のカーソル移動では、いかなる種類のアンドゥ記録も作らないが、
削除操作ではコマンド実行前のポイント位置を記録するためにこの項目を作る。

@item (@var{beg} . @var{end})
@c This kind of element indicates how to delete text that was inserted.
@c Upon insertion, the text occupied the range @var{beg}--@var{end} in the 
@c buffer.
この種の要素は、挿入されたテキストを削除する方法を表す。
挿入されたテキストはバッファの@var{beg}から@var{end}までの範囲を占める。

@item (@var{text} . @var{position})
@c This kind of element indicates how to reinsert text that was deleted.
@c The deleted text itself is the string @var{text}.  The place to
@c reinsert it is @code{(abs @var{position})}.
この種の要素は、削除されたテキストを再度挿入する方法を表す。
削除されたテキストそのものは文字列@var{text}である。
再度挿入する位置は@code{(abs @var{position})}である。

@item (t @var{high} . @var{low})
@c This kind of element indicates that an unmodified buffer became
@c modified.  The elements @var{high} and @var{low} are two integers, each
@c recording 16 bits of the visited file's modification time as of when it
@c was previously visited or saved.  @code{primitive-undo} uses those
@c values to determine whether to mark the buffer as unmodified once again;
@c it does so only if the file's modification time matches those numbers.
この種の要素は、未変更のバッファが変更されたことを表す。
@var{high}と@var{low}は2つの整数であり、それぞれ、
まえに訪問したときや保存したときの訪問しているファイルの更新時刻の
16ビットを記録している。
@code{primitive-undo}はこれらの値を用いて、
バッファを再度未変更と印を付けるかどうか判定する。
ファイルの更新時刻がこれに一致するときにのみ再度未変更とする。

@item (nil @var{property} @var{value} @var{beg} . @var{end})
@c This kind of element records a change in a text property.
@c Here's how you might undo the change:
この種の要素は、テキスト属性の変更を記録する。
変更をアンドゥするにはつぎのようにする。

@example
(put-text-property @var{beg} @var{end} @var{property} @var{value})
@end example

@item (@var{marker} . @var{adjustment})
@c This kind of element records the fact that the marker @var{marker} was
@c relocated due to deletion of surrounding text, and that it moved
@c @var{adjustment} character positions.  Undoing this element moves
@c @var{marker} @minus{} @var{adjustment} characters.
この種の要素は、周りのテキストが削除されたために
マーカ@var{marker}を再配置し
@var{adjustment}文字分位置を移動したことを記録する。
この要素をアンドゥすると、
@var{marker} @minus{} @var{adjustment}文字に移動する。

@item nil
@c This element is a boundary.  The elements between two boundaries are
@c called a @dfn{change group}; normally, each change group corresponds to
@c one keyboard command, and undo commands normally undo an entire group as
@c a unit.
この要素は境界である。
2つの境界のあいだの要素群を@dfn{変更グループ}（change group）と呼ぶ。
通常、各変更グループは1つのキーボードコマンドに対応し、
アンドゥコマンドはグループ全体を1個としてアンドゥする。
@end table

@defun undo-boundary
@c This function places a boundary element in the undo list.  The undo
@c command stops at such a boundary, and successive undo commands undo
@c to earlier and earlier boundaries.  This function returns @code{nil}.
この関数は、アンドゥリストに境界要素を置く。
アンドゥコマンドはそのような境界で停止し、
連続したアンドゥコマンドはよりまえの境界までアンドゥする。
この関数は@code{nil}を返す。

@c The editor command loop automatically creates an undo boundary before
@c each key sequence is executed.  Thus, each undo normally undoes the
@c effects of one command.  Self-inserting input characters are an
@c exception.  The command loop makes a boundary for the first such
@c character; the next 19 consecutive self-inserting input characters do
@c not make boundaries, and then the 20th does, and so on as long as
@c self-inserting characters continue.
エディタコマンドループは、
各キー列を実行するまえにアンドゥの境界を自動的に作る。
したがって、各アンドゥは、1つのコマンドの効果を普通は取り消す。
自己挿入の入力文字は例外である。
コマンドループはそのような最初の文字に境界を作り、
つぎの19個の連続する自己挿入の入力文字では境界を作らず、
20番目で境界を作るということを自己挿入の入力文字が続く限り行う。

@c All buffer modifications add a boundary whenever the previous undoable
@c change was made in some other buffer.  This is to ensure that
@c each command makes a boundary in each buffer where it makes changes.
別のバッファでアンドゥ可能な変更を行うたびに
バッファのすべての変更で境界を追加する。
これは、各コマンドが変更した箇所で各バッファに境界を作ることを
保証するためである。

@c Calling this function explicitly is useful for splitting the effects of
@c a command into more than one unit.  For example, @code{query-replace}
@c calls @code{undo-boundary} after each replacement, so that the user can
@c undo individual replacements one by one.
1つのコマンドの効果を複数に分けるためにこの関数を直接呼ぶことは有用である。
たとえば、@code{query-replace}は各置換のあとで@code{undo-boundary}を呼び出し、
ユーザーが個々の置換を1つ1つアンドゥできるようにする。
@end defun

@defun primitive-undo count list
@c This is the basic function for undoing elements of an undo list.
@c It undoes the first @var{count} elements of @var{list}, returning
@c the rest of @var{list}.  You could write this function in Lisp,
@c but it is convenient to have it in C.
これは、アンドゥリストの要素をアンドゥする基本的な関数である。
@var{list}の先頭の@var{count}個の要素をアンドゥし、@var{list}の残りを返す。
この関数をLispで書くこともできるが、Cで書いたほうが便利である。

@c @code{primitive-undo} adds elements to the buffer's undo list when it
@c changes the buffer.  Undo commands avoid confusion by saving the undo
@c list value at the beginning of a sequence of undo operations.  Then the
@c undo operations use and update the saved value.  The new elements added
@c by undoing are not part of this saved value, so they don't interfere with
@c continuing to undo.
@code{primitive-undo}は、バッファを変更すると
バッファのアンドゥリストに要素を追加する。
アンドゥコマンドは一連のアンドゥ操作を始めるときに
アンドゥリストを保存して混乱を避ける。
アンドゥ操作では、保存しておいた値を使い更新する。
アンドゥによって追加される新たな要素はこの保存された値の一部ではないので、
それらはアンドゥを続行しても干渉しない。
@end defun

@node Maintaining Undo
@c @section Maintaining Undo Lists
@section アンドゥリストの管理

@c   This section describes how to enable and disable undo information for
@c a given buffer.  It also explains how the undo list is truncated
@c automatically so it doesn't get too big.
本節では、指定されたバッファでアンドゥ情報の記録をオン／オフする
方法について述べます。
また、アンドゥリストが大きくなりすぎないように
自動的に切り詰める方法についても説明します。

@c   Recording of undo information in a newly created buffer is normally
@c enabled to start with; but if the buffer name starts with a space, the
@c undo recording is initially disabled.  You can explicitly enable or
@c disable undo recording with the following two functions, or by setting
@c @code{buffer-undo-list} yourself.
新たに作成されたバッファのアンドゥ情報の記録は普通は始めオンですが、
バッファ名が空白で始まる場合は最初からオフです。
つぎの2つの関数を使うか、読者自身が@code{buffer-undo-list}に設定すれば、
アンドゥ記録を明示的にオン／オフできます。

@c @deffn Command buffer-enable-undo &optional buffer-or-name
@deffn コマンド buffer-enable-undo &optional buffer-or-name
@c This command enables recording undo information for buffer
@c @var{buffer-or-name}, so that subsequent changes can be undone.  If no
@c argument is supplied, then the current buffer is used.  This function
@c does nothing if undo recording is already enabled in the buffer.  It
@c returns @code{nil}.
このコマンドは、バッファ@var{buffer-or-name}でのアンドゥ記録をオンにし、
以降の変更を取り消せるようにする。
引数を指定しないと、カレントバッファを使う。
当該バッファでアンドゥ記録がすでにオンであると、
この関数はなにもしない。
@code{nil}を返す。

@c In an interactive call, @var{buffer-or-name} is the current buffer.
@c You cannot specify any other buffer.
対話的に呼ばれると、@var{buffer-or-name}はカレントバッファである。
他のバッファを指定できない。
@end deffn

@c @deffn Command buffer-disable-undo &optional buffer
@deffn コマンド buffer-disable-undo &optional buffer
@c @deffnx Command buffer-flush-undo &optional buffer
@deffnx コマンド buffer-flush-undo &optional buffer
@c @cindex disable undo
@cindex アンドゥのオフ
@c This function discards the undo list of @var{buffer}, and disables
@c further recording of undo information.  As a result, it is no longer
@c possible to undo either previous changes or any subsequent changes.  If
@c the undo list of @var{buffer} is already disabled, this function
@c has no effect.
この関数はバッファ@var{buffer}のアンドゥリストを破棄し、
以降のアンドゥ情報の記録をオフにする。
その結果、これ以前の変更も以降の変更も取り消すことはできない。
@var{buffer}のアンドゥリストがすでにオフであると、
この関数にはなんの効果もない。

@c This function returns @code{nil}.
この関数は@code{nil}を返す。

@c The name @code{buffer-flush-undo} is not considered obsolete, but the
@c preferred name is @code{buffer-disable-undo}.
名前@code{buffer-flush-undo}は廃れているとはみなさないが、
好ましい名前は@code{buffer-disable-undo}である。
@end deffn

@c   As editing continues, undo lists get longer and longer.  To prevent
@c them from using up all available memory space, garbage collection trims
@c them back to size limits you can set.  (For this purpose, the ``size''
@c of an undo list measures the cons cells that make up the list, plus the
@c strings of deleted text.)  Two variables control the range of acceptable
@c sizes: @code{undo-limit} and @code{undo-strong-limit}.
編集を続けるにしたがってアンドゥリストはどんどん長くなります。
これらがメモリを使い尽くさないように、
読者が設定した上限サイズにガベッジコレクションが切り詰めます。
（この目的においてアンドゥリストの『サイズ』は、
リストを構成するコンスセルの個数と削除された文字列の和である。）
2つの変数@code{undo-limit}と@code{undo-strong-limit}は、
許容できるサイズの範囲を制御します。

@defvar undo-limit
@c This is the soft limit for the acceptable size of an undo list.  The
@c change group at which this size is exceeded is the last one kept.
これはアンドゥリストの許容できるサイズの緩い制限である。
このサイズを越える位置にある変更グループは保持される最古のものである。
@end defvar

@defvar undo-strong-limit
@c This is the upper limit for the acceptable size of an undo list.  The
@c change group at which this size is exceeded is discarded itself (along
@c with all older change groups).  There is one exception: the very latest
@c change group is never discarded no matter how big it is.
これはアンドゥリストの許容できるサイズの上限である。
このサイズを越える位置にある変更グループは
（これより古いものも含めて）削除される。
例外が1つあり、最新の変更グループは
それがどれほど大きくてもけっして破棄しない。
@end defvar

@node Filling
@comment  node-name,  next,  previous,  up
@c @section Filling
@section 詰め込み
@c @cindex filling, explicit
@cindex 詰め込み、明示的

@c   @dfn{Filling} means adjusting the lengths of lines (by moving the line
@c breaks) so that they are nearly (but no greater than) a specified
@c maximum width.  Additionally, lines can be @dfn{justified}, which means
@c inserting spaces to make the left and/or right margins line up
@c precisely.  The width is controlled by the variable @code{fill-column}.
@c For ease of reading, lines should be no longer than 70 or so columns.
@dfn{詰め込み}（fill）とは、指定されている最大幅
（を越えず）にほぼ収まるように（行分け位置を移動して）
行の長さを調整することです。
さらに、行を@dfn{幅揃え}（justify）することもできます。
つまり、左右の両端や片側の余白をきちんと揃えるため
空白を挿入することです。
幅は変数@code{fill-column}で制御します。
読みやすいように、行は70コラム程度に収めるべきです。

@c   You can use Auto Fill mode (@pxref{Auto Filling}) to fill text
@c automatically as you insert it, but changes to existing text may leave
@c it improperly filled.  Then you must fill the text explicitly.
テキストを挿入するにつれて自動的にテキストを詰め込むには、
自動詰め込み（auto-fill）モード（@pxref{Auto Filling}）を使いますが、
既存のテキストを変更しても正しくない詰め込み状態のまま放置されます。
したがって、そのようなテキストは明示的に詰め込む必要があります。

@c   Most of the commands in this section return values that are not
@c meaningful.  All the functions that do filling take note of the current
@c left margin, current right margin, and current justification style
@c (@pxref{Margins}).  If the current justification style is
@c @code{none}, the filling functions don't actually do anything.
本節のほとんどの関数が返す値には意味はありません。
詰め込みを行うすべての関数は、現在の左端余白、現在の右端余白、
現在の幅揃えスタイルに注意をはらいます（@pxref{Margins}）。
現在の幅揃えスタイルが@code{none}であると、
詰め込み関数は実際にはなにもしません。

@c   Several of the filling functions have an argument @var{justify}.
@c If it is non-@code{nil}, that requests some kind of justification.  It
@c can be @code{left}, @code{right}, @code{full}, or @code{center}, to
@c request a specific style of justification.  If it is @code{t}, that
@c means to use the current justification style for this part of the text
@c (see @code{current-justification}, below).  Any other value is treated
@c as @code{full}.
詰め込み関数には引数@var{justify}を取るものもあります。
それが@code{nil}以外であると、幅揃えの種類を指示します。
特定の幅揃えスタイルを指示するものは、
@code{left}、@code{right}、@code{full}、@code{center}です。
それが@code{t}であると、
テキストの当該部分には現在の幅揃えスタイルを用いることを意味します
（下記の@code{current-justification}を参照）。
これ以外の値は@code{full}として扱います。

@c   When you call the filling functions interactively, using a prefix
@c argument implies the value @code{full} for @var{justify}.
対話的に詰め込み関数を呼ぶときに前置引数を使うと、
@var{justify}として値@code{full}を暗に指示します。

@c @deffn Command fill-paragraph justify
@deffn コマンド fill-paragraph justify
@c @cindex filling a paragraph
@cindex 段落の詰め込み
@cindex 詰め込み、段落
@c This command fills the paragraph at or after point.  If
@c @var{justify} is non-@code{nil}, each line is justified as well.
@c It uses the ordinary paragraph motion commands to find paragraph
@c boundaries.  @xref{Paragraphs,,, emacs, The Emacs Manual}.
このコマンドは、ポイントがある段落、あるいは、ポイントのあとの段落を詰め込む。
@var{justify}が@code{nil}以外であると、各行の幅揃えも行う。
段落の境界を探すために普通の段落移動コマンドを用いる。
@pxref{Paragraphs,, 段落, emacs, GNU Emacs マニュアル}。
@end deffn

@c @deffn Command fill-region start end &optional justify nosqueeze
@c = 誤植                                                           to-eop
@deffn コマンド fill-region start end &optional justify nosqueeze to-eop
@c This command fills each of the paragraphs in the region from @var{start}
@c to @var{end}.  It justifies as well if @var{justify} is
@c non-@code{nil}.
このコマンドは、@var{start}から@var{end}の領域内の各段落を詰め込む。
@var{justify}が@code{nil}以外であれば、幅揃えも行う。

@c If @var{nosqueeze} is non-@code{nil}, that means to leave whitespace
@c other than line breaks untouched.  If @var{to-eop} is non-@code{nil},
@c that means to keep filling to the end of the paragraph---or the next hard
@c newline, if @code{use-hard-newlines} is enabled (see below).
@var{nosqueeze}が@code{nil}以外であると、
行分け以外の白文字にはふれないことを意味する。
@var{to-eop}が@code{nil}以外であると、
段落の末尾まで、あるいは、
@code{use-hard-newlines}がオンならばつぎのハード改行（下記参照）までを
詰め込むことを意味する。

@c The variable @code{paragraph-separate} controls how to distinguish
@c paragraphs.  @xref{Standard Regexps}.
変数@code{paragraph-separate}は、段落の区別方法を制御する。
@pxref{Standard Regexps}。
@end deffn

@c @deffn Command fill-individual-paragraphs start end &optional justify mail-flag
@deffn コマンド fill-individual-paragraphs start end &optional justify mail-flag
@c This command fills each paragraph in the region according to its
@c individual fill prefix.  Thus, if the lines of a paragraph were indented
@c with spaces, the filled paragraph will remain indented in the same
@c fashion.
このコマンドは、領域内の各段落を各段落の詰め込み接頭辞に従って詰め込む。
したがって、段落の行が空白で字下げされていると、
詰め込んだあとの段落も同じように字下げされる。

@c The first two arguments, @var{start} and @var{end}, are the beginning
@c and end of the region to be filled.  The third and fourth arguments,
@c @var{justify} and @var{mail-flag}, are optional.  If
@c @var{justify} is non-@code{nil}, the paragraphs are justified as
@c well as filled.  If @var{mail-flag} is non-@code{nil}, it means the
@c function is operating on a mail message and therefore should not fill
@c the header lines.
最初の2つの引数@var{start}と@var{end}は、
詰め込むべき範囲の先頭と末尾である。
3番目と4番目の引数、@var{justify}と@var{mail-flag}は省略できる。
@var{justify}が@code{nil}以外であると、
段落の詰め込みに加えて幅揃えも行う。
@var{mail-flag}が@code{nil}以外であると、
メイルメッセージなのでヘッダ行を詰め込まないことを意味する。

@c Ordinarily, @code{fill-individual-paragraphs} regards each change in
@c indentation as starting a new paragraph.  If
@c @code{fill-individual-varying-indent} is non-@code{nil}, then only
@c separator lines separate paragraphs.  That mode can handle indented
@c paragraphs with additional indentation on the first line.
通常、@code{fill-individual-paragraphs}は、
字下げが変わると新しい段落の開始とみなす。
@code{fill-individual-varying-indent}が@code{nil}以外であると、
区切り行のみが段落を区切るとみなす。
これは段落の先頭行と後続の行で字下げが異なる段落を処理できる。
@end deffn

@defopt fill-individual-varying-indent
@c This variable alters the action of @code{fill-individual-paragraphs} as
@c described above.
この変数は、上に述べたように
@code{fill-individual-paragraphs}の動作を変える。
@end defopt

@c @deffn Command fill-region-as-paragraph start end &optional justify nosqueeze squeeze-after
@deffn コマンド fill-region-as-paragraph start end &optional justify nosqueeze squeeze-after
@c This command considers a region of text as a single paragraph and fills
@c it.  If the region was made up of many paragraphs, the blank lines
@c between paragraphs are removed.  This function justifies as well as
@c filling when @var{justify} is non-@code{nil}.
このコマンドは、テキストの領域を1つの段落とみなして詰め込む。
領域に複数の段落があると、段落のあいだの空行は取りさる。
@var{justify}が@code{nil}以外であると幅揃えも行う。

@c In an interactive call, any prefix argument requests justification.
対話的な呼び出しでは、前置引数で幅揃えを指示する。

@c If @var{nosqueeze} is non-@code{nil}, that means to leave whitespace
@c other than line breaks untouched.  If @var{squeeze-after} is
@c non-@code{nil}, it specifies a position in the region, and means don't
@c canonicalize spaces before that position.
@var{nosqueeze}が@code{nil}以外であると、
行分け以外の白文字にはふれないことを意味する。
@var{squeeze-after}が@code{nil}以外であると、
それは領域内の位置を表し、
その位置よりまえにある空白を変更しないように指示する。

@c In Adaptive Fill mode, this command calls @code{fill-context-prefix} to
@c choose a fill prefix by default.  @xref{Adaptive Fill}.
適応型詰め込み（adaptive-fill）モードでは、
デフォルトの詰め込み接頭辞を選ぶために
このコマンドは@code{fill-context-prefix}を呼び出す。
@pxref{Adaptive Fill}。
@end deffn

@c @deffn Command justify-current-line how eop nosqueeze
@deffn コマンド justify-current-line how eop nosqueeze
@c This command inserts spaces between the words of the current line so
@c that the line ends exactly at @code{fill-column}.  It returns
@c @code{nil}.
このコマンドは、現在行の単語のあいだに空白を挿入し、
ちょうど@code{fill-column}コラムで行が終るようにする。
@code{nil}を返す。

@c The argument @var{how}, if non-@code{nil} specifies explicitly the style
@c of justification.  It can be @code{left}, @code{right}, @code{full},
@c @code{center}, or @code{none}.  If it is @code{t}, that means to do
@c follow specified justification style (see @code{current-justification},
@c below).  @code{nil} means to do full justification.
引数@var{how}が@code{nil}以外であると、
幅揃えスタイルを指定する。
可能な値は、@code{left}、@code{right}、@code{full}、
@code{center}、または、@code{none}である。
@code{t}であると、指定されている幅揃えスタイルに従うことを意味する
（下記の@code{current-justification}を参照）。
@code{nil}は、幅揃えしないことを意味する。

@c If @var{eop} is non-@code{nil}, that means do left-justification if
@c @code{current-justification} specifies full justification.  This is used
@c for the last line of a paragraph; even if the paragraph as a whole is
@c fully justified, the last line should not be.
@var{eop}が@code{nil}以外であると、
@code{current-justification}が両端揃えを指定しているときには
左端揃えを行うことを意味する。
これは段落の最後の行に適用される。
段落全体として両端揃えであっても、最後の行はそうすべきではない。

@c If @var{nosqueeze} is non-@code{nil}, that means do not change interior
@c whitespace.
@var{nosqueeze}が@code{nil}以外であると、
内側の白文字を変更しないことを意味する。
@end deffn

@defopt default-justification
@c This variable's value specifies the style of justification to use for
@c text that doesn't specify a style with a text property.  The possible
@c values are @code{left}, @code{right}, @code{full}, @code{center}, or
@c @code{none}.  The default value is @code{left}.
この変数の値は、テキスト属性で幅揃えスタイルを指定していない
テキストに対して用いる幅揃えスタイルを指定する。
可能な値は、@code{left}、@code{right}、@code{full}、@code{center}、
@code{none}である。
デフォルト値は@code{left}である。
@end defopt

@defun current-justification
@c This function returns the proper justification style to use for filling
@c the text around point.
この関数は、ポイントの周りのテキストを詰め込むときに使う
正しい幅揃えスタイルを返す。
@end defun

@defopt sentence-end-double-space
@c If this variable is non-@code{nil}, a period followed by just one space
@c does not count as the end of a sentence, and the filling functions
@c avoid breaking the line at such a place.
この変数が@code{nil}以外であると、
直後に1つの空白を従えたピリオドを文末とみなさず、
詰め込み関数はそのような箇所で行分けしない。
@end defopt

@defvar fill-paragraph-function
@c This variable provides a way for major modes to override the filling of
@c paragraphs.  If the value is non-@code{nil}, @code{fill-paragraph} calls
@c this function to do the work.  If the function returns a non-@code{nil}
@c value, @code{fill-paragraph} assumes the job is done, and immediately
@c returns that value.
この変数は、段落の詰め込みに優先する方法をメジャーモードに与える。
値が@code{nil}以外であると、
@code{fill-paragraph}は詰め込み処理のためにこの関数を呼び出す。
関数が@code{nil}以外の値を返すと、
@code{fill-paragraph}は処理が完了したとみなして戻り値をただちに返す。

@c The usual use of this feature is to fill comments in programming
@c language modes.  If the function needs to fill a paragraph in the usual
@c way, it can do so as follows:
この機能の普通の用途は、
プログラム言語向けのモードでコメントを詰め込むためである。
この関数で普通の方法で詰め込む必要がある場合には、つぎのようにする。

@example
(let ((fill-paragraph-function nil))
  (fill-paragraph arg))
@end example
@end defvar

@defvar use-hard-newlines
@c If this variable is non-@code{nil}, the filling functions do not delete
@c newlines that have the @code{hard} text property.  These ``hard
@c newlines'' act as paragraph separators.
この変数が@code{nil}以外であると、
詰め込み関数は、テキスト属性@code{hard}を持つ改行を削除しない。
これらの『ハード改行』は段落の区切りとして働く。
@end defvar

@node Margins
@c @section Margins for Filling
@section 詰め込みのための余白

@defopt fill-prefix
@c This buffer-local variable specifies a string of text that appears at
@c the beginning
@c of normal text lines and should be disregarded when filling them.  Any
@c line that fails to start with the fill prefix is considered the start of
@c a paragraph; so is any line that starts with the fill prefix followed by
@c additional whitespace.  Lines that start with the fill prefix but no
@c additional whitespace are ordinary text lines that can be filled
@c together.  The resulting filled lines also start with the fill prefix.
このバッファローカルな変数は、普通のテキスト行の先頭に現れ、
詰め込み時には無視すべきテキストの文字列（詰め込み接頭辞）を指定する。
詰め込み接頭辞で始まらない行は段落の開始行とみなすため、
詰め込み接頭辞のあとに余分に白文字があるとそれらも段落の開始行とみなす。
詰め込み接頭辞で始まりそのあとに余分な白文字がない行は、
いっしょに詰め込める普通のテキスト行である。

@c The fill prefix follows the left margin whitespace, if any.
左端余白がある場合には、左端余白のあとに詰め込み接頭辞が続く。
@end defopt

@defopt fill-column
@c This buffer-local variable specifies the maximum width of filled lines.
@c Its value should be an integer, which is a number of columns.  All the
@c filling, justification, and centering commands are affected by this
@c variable, including Auto Fill mode (@pxref{Auto Filling}).
このバッファローカルな変数は、詰め込んだ行の最大幅を指定する。
この値は整数であり、コラム数であること。
自動詰め込み（auto-fill）モード（@pxref{Auto Filling}）を含めて
すべての詰め込み／幅揃え／中央揃えを行うコマンドは、
この変数に影響される。

@c As a practical matter, if you are writing text for other people to
@c read, you should set @code{fill-column} to no more than 70.  Otherwise
@c the line will be too long for people to read comfortably, and this can
@c make the text seem clumsy.
特に他人のために書いているテキストでは、
@code{fill-column}を70未満にするべきである。
さもないと、人によっては快適に読むには行が長すぎて、
テキストが不恰好に見える。
@end defopt

@defvar default-fill-column
@c The value of this variable is the default value for @code{fill-column} in
@c buffers that do not override it.  This is the same as
@c @code{(default-value 'fill-column)}.
この変数の値は、バッファで@code{fill-column}の値を設定していない場合の
@code{fill-column}のデフォルト値である。
これは@code{(default-value 'fill-column)}と同じである。

@c The default value for @code{default-fill-column} is 70.
@code{default-fill-column}のデフォルト値は70である。
@end defvar

@c @deffn Command set-left-margin from to margin
@deffn コマンド set-left-margin from to margin
@c This sets the @code{left-margin} property on the text from @var{from} to
@c @var{to} to the value @var{margin}.  If Auto Fill mode is enabled, this
@c command also refills the region to fit the new margin.
@var{from}から@var{to}までのテキストの
属性@code{left-margin}を値@var{margin}にする。
自動詰め込み（auto-fill）モードがオンであると、
このコマンドは、当該領域を再詰め込みして新たな余白に適合するようにする。
@end deffn

@c @deffn Command set-right-margin from to margin
@deffn コマンド set-right-margin from to margin
@c This sets the @code{right-margin} property on the text from @var{from}
@c to @var{to} to the value @var{margin}.  If Auto Fill mode is enabled,
@c this command also refills the region to fit the new margin.
@var{from}から@var{to}までのテキストの
属性@code{right-margin}を値@var{margin}にする。
自動詰め込み（auto-fill）モードがオンであると、
このコマンドは、当該領域を再詰め込みして新たな余白に適合するようにする。
@end deffn

@defun current-left-margin
@c This function returns the proper left margin value to use for filling
@c the text around point.  The value is the sum of the @code{left-margin}
@c property of the character at the start of the current line (or zero if
@c none), and the value of the variable @code{left-margin}.
この関数は、ポイントの周りのテキストを詰め込むときに使う
正しい左端余白の値を返す。
その値は、現在行の最初の文字の属性@code{left-margin}の値（なければ0）
と変数@code{left-margin}の値の和である。
@end defun

@defun current-fill-column
@c This function returns the proper fill column value to use for filling
@c the text around point.  The value is the value of the @code{fill-column}
@c variable, minus the value of the @code{right-margin} property of the
@c character after point.
この関数は、ポイントの周りのテキストを詰め込むときに使う
正しい詰め込み幅を返す。
その値は、変数@code{fill-column}の値から
ポイント直後の文字の属性@code{right-margin}の値を引いたものである。
@end defun

@c @deffn Command move-to-left-margin &optional n force
@deffn コマンド move-to-left-margin &optional n force
@c This function moves point to the left margin of the current line.  The
@c column moved to is determined by calling the function
@c @code{current-left-margin}.  If the argument @var{n} is non-@code{nil},
@c @code{move-to-left-margin} moves forward @var{n}@minus{}1 lines first.
この関数は、ポイントを現在行の左端余白へ移動する。
移動先のコラム位置は関数@code{current-left-margin}を呼び出して決定する。
引数@var{n}が@code{nil}以外であると、
@code{move-to-left-margin}は@var{n}@minus{}1先の行へまず移動する。

@c If @var{force} is non-@code{nil}, that says to fix the line's
@c indentation if that doesn't match the left margin value.
@var{force}が@code{nil}以外であると、
行の字下げが左端余白の値に一致しないときには、
字下げを修正することを指示する。
@end deffn

@defun delete-to-left-margin from to
@c This function removes left margin indentation from the text
@c between @var{from} and @var{to}.  The amount of indentation
@c to delete is determined by calling @code{current-left-margin}.
@c In no case does this function delete non-whitespace.
この関数は、@var{from}から@var{to}までのテキストから
左端余白分の字下げを取りさる。
削除する字下げ量は、@code{current-left-margin}を呼び出して決定する。
この関数が白文字以外を削除することは絶対にない。
@end defun

@defun indent-to-left-margin
@c This is the default @code{indent-line-function}, used in Fundamental
@c mode, Text mode, etc.  Its effect is to adjust the indentation at the
@c beginning of the current line to the value specified by the variable
@c @code{left-margin}.  This may involve either inserting or deleting
@c whitespace.
これは、基本（fundamental）モード、テキスト（text）モードなどが使う
デフォルトの@code{indent-line-function}である。
その効果は、変数@code{left-margin}の値で指定した位置から
現在行が始まるように字下げを調整することである。
それには白文字の挿入や削除が伴う。
@end defun

@defvar left-margin
@c This variable specifies the base left margin column.  In Fundamental
@c mode, @kbd{C-j} indents to this column.  This variable automatically
@c becomes buffer-local when set in any fashion.
この変数は、左端余白コラムの起点を指定する。
基本（fundamental）モードでは、@kbd{C-j}がこのコラム位置に字下げする。
この変数に設定すると自動的にバッファローカルになる。
@end defvar

@defvar fill-nobreak-predicate
@tindex fill-nobreak-predicate
@c This variable gives major modes a way to specify not to break a line at
@c certain places.  Its value should be a function.  This function is
@c called during filling, with no arguments and with point located at the
@c place where a break is being considered.  If the function returns
@c non-@code{nil}, then the line won't be broken there.
この変数は、特定の箇所では行分けしない方法をメジャーモードに提供する。
その値は関数であること。
この関数は、引数なしで行分け予定箇所にポイントを置いて呼び出される。
この関数が@code{nil}以外を返すと、当該箇所では行分けしない。
@end defvar

@node Adaptive Fill
@c @section Adaptive Fill Mode
@section 適応型詰め込み（adaptive-fill）モード
@c @cindex Adaptive Fill mode
@cindex 適応型詰め込み（adaptive-fill）モード

@c   Adaptive Fill mode chooses a fill prefix automatically from the text
@c in each paragraph being filled.
適応型詰め込みモード（adaptive-fill）では、
詰め込むべき各段落のテキストから自動的に詰め込み接頭辞を選びます。

@defopt adaptive-fill-mode
@c Adaptive Fill mode is enabled when this variable is non-@code{nil}.
@c It is @code{t} by default.
この変数が@code{nil}以外であると、
適応型詰め込みモード（adaptive-fill）がオンである。
デフォルトでは@code{t}である。
@end defopt

@defun fill-context-prefix from to
@c This function implements the heart of Adaptive Fill mode; it chooses a
@c fill prefix based on the text between @var{from} and @var{to}.  It does
@c this by looking at the first two lines of the paragraph, based on the
@c variables described below.
この関数は適応型詰め込みモード（adaptive-fill）の中核を実装するものであり、
@var{from}から@var{to}のあいだのテキストに基づいて詰め込み接頭辞を選ぶ。
以下に述べる変数に基づいて、段落の最初の2行を調べてこれを行う。
@end defun

@defopt adaptive-fill-regexp
@c This variable holds a regular expression to control Adaptive Fill mode.
@c Adaptive Fill mode matches this regular expression against the text
@c starting after the left margin whitespace (if any) on a line; the
@c characters it matches are that line's candidate for the fill prefix.
この変数は、適応型詰め込みモード（adaptive-fill）を制御する
正規表現を保持する。
適応型詰め込みモード（adaptive-fill）では、
行の（あれば）左端余白の白文字のうしろから始まるテキストに対して
この正規表現の一致を試みる。
一致した文字群が当該行の詰め込み接頭辞の候補になる。
@end defopt

@defopt adaptive-fill-first-line-regexp
@c In a one-line paragraph, if the candidate fill prefix matches this
@c regular expression, or if it matches @code{comment-start-skip}, then it
@c is used---otherwise, spaces amounting to the same width are used
@c instead.
1行だけの段落において、詰め込み接頭辞の候補がこの正規表現に一致するか、
@code{comment-start-skip}に一致すると、その候補を使う。
さもなければ、同じ幅に相当する白文字をかわりに使う。

@c However, the fill prefix is never taken from a one-line paragraph
@c if it would act as a paragraph starter on subsequent lines.
1行だけの段落から選んだ詰め込み接頭辞が後続の行の段落の始まりである場合には、
1行だけの段落からはけっして詰め込み接頭辞を選ばない。
@end defopt

@defopt adaptive-fill-function
@c You can specify more complex ways of choosing a fill prefix
@c automatically by setting this variable to a function.  The function is
@c called when @code{adaptive-fill-regexp} does not match, with point after
@c the left margin of a line, and it should return the appropriate fill
@c prefix based on that line.  If it returns @code{nil}, that means it sees
@c no fill prefix in that line.
この変数に関数を指定することで、
詰め込み接頭辞のより複雑な自動選択方法を指定できる。
この関数は、@code{adaptive-fill-regexp}の一致に失敗したときに、
行の左端余白のうしろにポイントを置いて呼び出され、
当該行に基づいて適切な詰め込み接頭辞を返すこと。
それが@code{nil}を返すと、当該行には詰め込み接頭辞がないことを意味する。
@end defopt

@node Auto Filling
@comment  node-name,  next,  previous,  up
@c @section Auto Filling
@section 自動詰め込み（auto-filling）モード
@c @cindex filling, automatic
@c @cindex Auto Fill mode
@cindex 詰め込み、自動
@cindex 自動詰め込み（auto-filling）モード

@c   Auto Fill mode is a minor mode that fills lines automatically as text
@c is inserted.  This section describes the hook used by Auto Fill mode.
@c For a description of functions that you can call explicitly to fill and
@c justify existing text, see @ref{Filling}.
自動詰め込み（auto-filling）モードは、テキストを挿入するにつれて
自動的に行を詰め込むマイナモードです。
本節では、自動詰め込み（auto-filling）モードが使うフックについて述べます。
既存のテキストを詰め込んだり幅揃えするために
明示的に呼び出す関数については、@ref{Filling}を参照してください。

@c   Auto Fill mode also enables the functions that change the margins and
@c justification style to refill portions of the text.  @xref{Margins}.
自動詰め込み（auto-filling）モードでは、
テキストの一部を再詰め込む際の
余白や幅揃えスタイルを変更するための関数も使えるようにします。
@xref{Margins}。

@defvar auto-fill-function
@c The value of this variable should be a function (of no arguments) to be
@c called after self-inserting a space or a newline.  It may be @code{nil},
@c in which case nothing special is done in that case.
この変数の値は、
自己挿入される空白や改行のあとで呼び出されるべき
（引数なしの）関数であること。
これが@code{nil}であると、そのような場合に特別なことを行わない。

@c The value of @code{auto-fill-function} is @code{do-auto-fill} when
@c Auto-Fill mode is enabled.  That is a function whose sole purpose is to
@c implement the usual strategy for breaking a line.
自動詰め込み（auto-filling）モードがオンであると、
@code{auto-fill-function}の値は@code{do-auto-fill}である。
この関数の目的は、行分けの通常の方針を実装することである。

@quotation
@c In older Emacs versions, this variable was named @code{auto-fill-hook},
@c but since it is not called with the standard convention for hooks, it
@c was renamed to @code{auto-fill-function} in version 19.
Emacsの古い版では、この変数を@code{auto-fill-hook}と命名していたが、
フックの標準的な慣習に従って呼ばれないため
19版で@code{auto-fill-function}と改名した。
@end quotation
@end defvar

@defvar normal-auto-fill-function
@c This variable specifies the function to use for
@c @code{auto-fill-function}, if and when Auto Fill is turned on.  Major
@c modes can set buffer-local values for this variable to alter how Auto
@c Fill works.
この変数は、自動詰め込み（auto-filling）モードがオンになったとき／であるときに
@code{auto-fill-function}として用いる関数を指定する。
メジャーモードでは、この変数のバッファローカルな値に設定することで
自動詰め込み（auto-filling）モードのふるまいを変更できる。
@end defvar

@node Sorting
@c @section Sorting Text
@section テキストのソート
@c @cindex sorting text
@cindex テキストのソート
@cindex ソート、テキスト

@c   The sorting functions described in this section all rearrange text in
@c a buffer.  This is in contrast to the function @code{sort}, which
@c rearranges the order of the elements of a list (@pxref{Rearrangement}).
@c The values returned by these functions are not meaningful.
本節で述べるソート関数すべては、バッファ内のテキストを並べ替えます。
これは、リスト内の要素の順番を並べ替える関数@code{sort}
（@pxref{Rearrangement}）と対照的です。
これらの関数が返す値には意味はありません。

@defun sort-subr reverse nextrecfun endrecfun &optional startkeyfun endkeyfun
@c This function is the general text-sorting routine that subdivides a
@c buffer into records and then sorts them.  Most of the commands in this
@c section use this function.
この関数は、バッファ内のテキストをレコードに分割してソートする
汎用のテキストソートルーティンである。
本節のコマンドのほとんどは、この関数を用いる。

@c To understand how @code{sort-subr} works, consider the whole accessible
@c portion of the buffer as being divided into disjoint pieces called
@c @dfn{sort records}.  The records may or may not be contiguous, but they
@c must not overlap.  A portion of each sort record (perhaps all of it) is
@c designated as the sort key.  Sorting rearranges the records in order by
@c their sort keys.
@code{sort-subr}の動作方法を理解するためは、
バッファの参照可能部分全体が
@dfn{ソートレコード}（sort record）と呼ばれる
重なり合いのない断片に分割されていると考える。
レコードは連続しているかもしれないし、そうでないかもしれないが、
けっして重なり合わない。
各ソートレコードの一部分（あるいは全体）をソートキーとして区別する。
ソートでは、ソートキーの順に並ぶようにレコードを並び替える。

@c Usually, the records are rearranged in order of ascending sort key.
@c If the first argument to the @code{sort-subr} function, @var{reverse},
@c is non-@code{nil}, the sort records are rearranged in order of
@c descending sort key.
通常、レコードをソートキーの昇順に並べ替える。
関数@code{sort-subr}の第1引数@var{reverse}が@code{nil}以外であると、
ソートキーの降順にレコードを並べ替える。

@c The next four arguments to @code{sort-subr} are functions that are
@c called to move point across a sort record.  They are called many times
@c from within @code{sort-subr}.
@code{sort-subr}のつぎの4つの引数は、
ソートレコードをまたいでポイントを移動するために呼ばれる関数である。
それらは、@code{sort-subr}で多数回呼び出される。

@enumerate
@item
@c @var{nextrecfun} is called with point at the end of a record.  This
@c function moves point to the start of the next record.  The first record
@c is assumed to start at the position of point when @code{sort-subr} is
@c called.  Therefore, you should usually move point to the beginning of
@c the buffer before calling @code{sort-subr}.
@var{nextrecfun}は、レコードの末尾にポイントを置いて呼び出される。
この関数は、つぎのレコードの先頭にポイントを移動する。
最初のレコードの先頭は、
@code{sort-subr}を呼び出したときのポイント位置であると仮定する。
したがって、@code{sort-subr}を呼び出すまえには、普通、
バッファの先頭にポイントを移動しておくこと。

@c This function can indicate there are no more sort records by leaving
@c point at the end of the buffer.
この関数は、バッファの末尾にポイントを置いておくことで、
ソートレコードがなくなったことを表せる。

@item
@c @var{endrecfun} is called with point within a record.  It moves point to
@c the end of the record.
@var{endrecfun}は、レコード内にポイントを置いて呼び出される。
レコードの末尾にポイントを移動する。

@item
@c @var{startkeyfun} is called to move point from the start of a record to
@c the start of the sort key.  This argument is optional; if it is omitted,
@c the whole record is the sort key.  If supplied, the function should
@c either return a non-@code{nil} value to be used as the sort key, or
@c return @code{nil} to indicate that the sort key is in the buffer
@c starting at point.  In the latter case, @var{endkeyfun} is called to
@c find the end of the sort key.
@var{startkeyfun}は、レコードの先頭からソートキーの先頭へ
ポイントを移動するために呼び出される。
この引数は省略可能であり、省略するとレコード全体をソートキーとする。
指定した場合、その関数は、ソートキーとして用いる@code{nil}以外の値を返すか、
バッファのポイント位置からソートキーが始まることを表す@code{nil}を返すこと。
後者の場合、ソートキーの末尾を探すために@var{endkeyfun}が呼ばれる。

@item
@c @var{endkeyfun} is called to move point from the start of the sort key
@c to the end of the sort key.  This argument is optional.  If
@c @var{startkeyfun} returns @code{nil} and this argument is omitted (or
@c @code{nil}), then the sort key extends to the end of the record.  There
@c is no need for @var{endkeyfun} if @var{startkeyfun} returns a
@c non-@code{nil} value.
@var{endkeyfun}は、ソートキーの先頭からソートキーの末尾に
ポイントを移動するために呼び出される。
この引数は省略可能である。
@var{startkeyfun}が@code{nil}を返しこの引数が省略されている
（あるいは@code{nil}である）と、ソートキーはレコードの末尾までである。
@var{startkeyfun}が@code{nil}以外の値を返すのであれば、
@var{endkeyfun}は必要ない。
@end enumerate

@c As an example of @code{sort-subr}, here is the complete function
@c definition for @code{sort-lines}:
@code{sort-subr}の例として、
@code{sort-lines}の完全な関数定義を示す。

@example
@group
@c ;; @r{Note that the first two lines of doc string}
@c ;; @r{are effectively one line when viewed by a user.}
;; @r{説明文字列の始めの2行は、ユーザーが見るときには}
;; @r{実質的には1行であることに注意}
(defun sort-lines (reverse beg end)
  "Sort lines in region alphabetically;\
 argument means descending order.
Called from a program, there are three arguments:
@end group
@group
REVERSE (non-nil means reverse order),\
 BEG and END (region to sort).
The variable `sort-fold-case' determines\
 whether alphabetic case affects
the sort order.
@end group
@group
  (interactive "P\nr")
  (save-excursion
    (save-restriction
      (narrow-to-region beg end)
      (goto-char (point-min))
      (sort-subr reverse 'forward-line 'end-of-line))))
@end group
@end example

@c Here @code{forward-line} moves point to the start of the next record,
@c and @code{end-of-line} moves point to the end of record.  We do not pass
@c the arguments @var{startkeyfun} and @var{endkeyfun}, because the entire
@c record is used as the sort key.
ここで、@code{forward-line}はつぎのレコードの先頭にポイントを移動し、
@code{end-of-line}はレコードの末尾にポイントを移動する。
レコード全体をソートキーとして用いるため、
引数@var{startkeyfun}と@var{endkeyfun}は指定しない。

@c The @code{sort-paragraphs} function is very much the same, except that
@c its @code{sort-subr} call looks like this:
関数@code{sort-paragraphs}もほぼ同様であるが、
つぎのように@code{sort-subr}を呼び出す点が異なる。

@example
@group
(sort-subr reverse
           (function
             (lambda ()
               (while (and (not (eobp))
                      (looking-at paragraph-separate))
                 (forward-line 1))))
           'forward-paragraph)
@end group
@end example

@c Markers pointing into any sort records are left with no useful
@c position after @code{sort-subr} returns.
@code{sort-subr}から戻ったあとでは、
ソートレコードを指しているマーカは意味のある位置を指していない。
@end defun

@defopt sort-fold-case
@c If this variable is non-@code{nil}, @code{sort-subr} and the other
@c buffer sorting functions ignore case when comparing strings.
この変数が@code{nil}以外であると、
@code{sort-subr}や他のバッファソート関数は、
文字列の比較において大文字小文字を区別しない。
@end defopt

@c @deffn Command sort-regexp-fields reverse record-regexp key-regexp start end
@deffn コマンド sort-regexp-fields reverse record-regexp key-regexp start end
@c This command sorts the region between @var{start} and @var{end}
@c alphabetically as specified by @var{record-regexp} and @var{key-regexp}.
@c If @var{reverse} is a negative integer, then sorting is in reverse
@c order.
このコマンドは、@var{start}と@var{end}のあいだの領域を
@var{record-regexp}と@var{key-regexp}の指定に従って
アルファベット順にソートする。
@var{reverse}が負の整数であると、逆順にソートする。

@c Alphabetical sorting means that two sort keys are compared by
@c comparing the first characters of each, the second characters of each,
@c and so on.  If a mismatch is found, it means that the sort keys are
@c unequal; the sort key whose character is less at the point of first
@c mismatch is the lesser sort key.  The individual characters are compared
@c according to their numerical character codes in the Emacs character set.
アルファベット順のソートとは、
最初の文字同士、2番目の文字同士といった具合に
2つのソートキーを比較することである。
不一致がみつかると、ソートキーが等しくないことを意味し、
最初の不一致箇所の文字が小さいほうのソートキーが小さい。
個々の文字は、Emacsの文字集合における文字コードの数値に従って比較する。

@c The value of the @var{record-regexp} argument specifies how to divide
@c the buffer into sort records.  At the end of each record, a search is
@c done for this regular expression, and the text that matches it is taken
@c as the next record.  For example, the regular expression @samp{^.+$},
@c which matches lines with at least one character besides a newline, would
@c make each such line into a sort record.  @xref{Regular Expressions}, for
@c a description of the syntax and meaning of regular expressions.
引数@var{record-regexp}の値は、バッファをソートレコードに
分割する方法を指定する。
各レコードの末尾において、この正規表現を探索し
それに一致したテキストをつぎのレコードとする。
たとえば、正規表現@samp{^.+$}は、
少なくとも1つの文字のあとに改行があるような行に一致し、
そのような行をソートレコードとする。
正規表現の構文と意味については、@pxref{Regular Expressions}。

@c The value of the @var{key-regexp} argument specifies what part of each
@c record is the sort key.  The @var{key-regexp} could match the whole
@c record, or only a part.  In the latter case, the rest of the record has
@c no effect on the sorted order of records, but it is carried along when
@c the record moves to its new position.
引数@var{key-regexp}の値は、
レコードのどの部分がソートキーであるかを指定する。
@var{key-regexp}は、レコード全体かその一部分に一致する。
後者の場合、レコードの残りの部分は、レコードの並び替え順序には影響しないが、
レコードをその新たな位置に移動するときにいっしょに移動される。

@c The @var{key-regexp} argument can refer to the text matched by a
@c subexpression of @var{record-regexp}, or it can be a regular expression
@c on its own.
引数@var{key-regexp}で
@var{record-regexp}の部分式に一致したテキストを参照してもよいし、
独立した正規表現でもよい。

@c If @var{key-regexp} is:
@var{key-regexp}にはつぎの可能性がある。

@table @asis
@item @samp{\@var{digit}}
@c then the text matched by the @var{digit}th @samp{\(...\)} parenthesis
@c grouping in @var{record-regexp} is the sort key.
@var{record-regexp}の@var{digit}番目の
括弧によるグループ化@samp{\(...\)}に一致したテキストがソートキーである。

@item @samp{\&}
@c then the whole record is the sort key.
レコード全体がソートキーである。

@c @item a regular expression
@item 正規表現
@c then @code{sort-regexp-fields} searches for a match for the regular
@c expression within the record.  If such a match is found, it is the sort
@c key.  If there is no match for @var{key-regexp} within a record then
@c that record is ignored, which means its position in the buffer is not
@c changed.  (The other records may move around it.)
@code{sort-regexp-fields}はレコード内でこの正規表現に一致するものを探す。
一致がみつかれば、それがソートキーになる。
レコード内で@var{key-regexp}に対する一致がみつからなければ、
レコードを無視する。
つまり、バッファ内での当該レコードの位置を変更しない。
（別のレコードが周りに移動してくるかもしれない。）
@end table

@c For example, if you plan to sort all the lines in the region by the
@c first word on each line starting with the letter @samp{f}, you should
@c set @var{record-regexp} to @samp{^.*$} and set @var{key-regexp} to
@c @samp{\<f\w*\>}.  The resulting expression looks like this:
たとえば、領域内のすべての行を各行の@samp{f}で始まる最初の単語で
ソートするには、@var{record-regexp}に@samp{^.*$}、
@var{key-regexp}に@samp{\<f\w*\>}を指定する。
つまり、つぎのような式になる。

@example
@group
(sort-regexp-fields nil "^.*$" "\\<f\\w*\\>"
                    (region-beginning)
                    (region-end))
@end group
@end example

@c If you call @code{sort-regexp-fields} interactively, it prompts for
@c @var{record-regexp} and @var{key-regexp} in the minibuffer.
@code{sort-regexp-fields}を対話的に呼び出すと、
ミニバッファで@var{record-regexp}と@var{key-regexp}を問い合わせる。
@end deffn

@c @deffn Command sort-lines reverse start end
@deffn コマンド sort-lines reverse start end
@c This command alphabetically sorts lines in the region between
@c @var{start} and @var{end}.  If @var{reverse} is non-@code{nil}, the sort
@c is in reverse order.
このコマンドは、@var{start}と@var{end}のあいだの領域の行を
アルファベット順にソートする。
@var{reverse}が@code{nil}以外であると、逆順にソートする。
@end deffn

@c @deffn Command sort-paragraphs reverse start end
@deffn コマンド sort-paragraphs reverse start end
@c This command alphabetically sorts paragraphs in the region between
@c @var{start} and @var{end}.  If @var{reverse} is non-@code{nil}, the sort
@c is in reverse order.
このコマンドは、@var{start}と@var{end}のあいだの領域の段落を
アルファベット順にソートする。
@var{reverse}が@code{nil}以外であると、逆順にソートする。
@end deffn

@c @deffn Command sort-pages reverse start end
@deffn コマンド sort-pages reverse start end
@c This command alphabetically sorts pages in the region between
@c @var{start} and @var{end}.  If @var{reverse} is non-@code{nil}, the sort
@c is in reverse order.
このコマンドは、@var{start}と@var{end}のあいだの領域のページを
アルファベット順にソートする。
@var{reverse}が@code{nil}以外であると、逆順にソートする。
@end deffn

@c @deffn Command sort-fields field start end
@deffn コマンド sort-fields field start end
@c This command sorts lines in the region between @var{start} and
@c @var{end}, comparing them alphabetically by the @var{field}th field
@c of each line.  Fields are separated by whitespace and numbered starting
@c from 1.  If @var{field} is negative, sorting is by the
@c @w{@minus{}@var{field}th} field from the end of the line.  This command
@c is useful for sorting tables.
このコマンドは、@var{start}と@var{end}のあいだの領域の行を
各行の@var{field}番目のフィールド同士をアルファベット順に比較してソートする。
フィールドは白文字で区切られ、1から数える。
@var{field}が負であると、
行末から@minus{}@var{field}番目のフィールドでソートする。
このコマンドは、表をソートするのに有用である。
@end deffn

@c @deffn Command sort-numeric-fields field start end
@deffn コマンド sort-numeric-fields field start end
@c This command sorts lines in the region between @var{start} and
@c @var{end}, comparing them numerically by the @var{field}th field of each
@c line.  The specified field must contain a number in each line of the
@c region.  Fields are separated by whitespace and numbered starting from
@c 1.  If @var{field} is negative, sorting is by the
@c @w{@minus{}@var{field}th} field from the end of the line.  This command
@c is useful for sorting tables.
このコマンドは、@var{start}と@var{end}のあいだの領域の行を
各行の@var{field}番目のフィールド同士を数値として比較してソートする。
領域内の各行の指定したフィールドには数があること。
フィールドは白文字で区切られ、1から数える。
@var{field}が負であると、
行末から@minus{}@var{field}番目のフィールドでソートする。
このコマンドは、表をソートするのに有用である。
@end deffn

@c @deffn Command sort-columns reverse &optional beg end
@deffn コマンド sort-columns reverse &optional beg end
@c This command sorts the lines in the region between @var{beg} and
@c @var{end}, comparing them alphabetically by a certain range of columns.
@c The column positions of @var{beg} and @var{end} bound the range of
@c columns to sort on.
このコマンドは、@var{start}と@var{end}のあいだの領域の行を
特定範囲のコラムをアルファベット順に比較してソートする。
@var{beg}と@var{end}のコラム位置は、ソート対象のコラムの範囲を区切る。

@c If @var{reverse} is non-@code{nil}, the sort is in reverse order.
@var{reverse}が@code{nil}以外であると、逆順にソートする。

@c One unusual thing about this command is that the entire line
@c containing position @var{beg}, and the entire line containing position
@c @var{end}, are included in the region sorted.
このコマンドの普通でない点は、
位置@var{beg}を含む行全体と位置@var{end}を含む行全体も
ソート対象の領域に含まれることである。

@c Note that @code{sort-columns} uses the @code{sort} utility program,
@c and so cannot work properly on text containing tab characters.  Use
@c @kbd{M-x untabify} to convert tabs to spaces before sorting.
@code{sort-columns}は、ユーティリティプログラム@code{sort}を使うため、
タブ文字を含むテキストを正しく扱えない。
ソートするまえに@kbd{M-x untabify}を使ってタブを空白に変換すること。
@end deffn

@node Columns
@comment  node-name,  next,  previous,  up
@c @section Counting Columns
@section コラムを数える
@c @cindex columns
@c @cindex counting columns
@c @cindex horizontal position
@cindex コラム
@cindex コラムを数える
@cindex 水平位置

@c   The column functions convert between a character position (counting
@c characters from the beginning of the buffer) and a column position
@c (counting screen characters from the beginning of a line).
コラム関数は、（バッファの先頭から文字を数えた）文字位置を
（スクリーンの行頭から文字を数えた）コラム位置に変換します。

@c   These functions count each character according to the number of
@c columns it occupies on the screen.  This means control characters count
@c as occupying 2 or 4 columns, depending upon the value of
@c @code{ctl-arrow}, and tabs count as occupying a number of columns that
@c depends on the value of @code{tab-width} and on the column where the tab
@c begins.  @xref{Usual Display}.
これらの関数は、各文字をそれがスクリーン上で占めるコラム数を基に数える。
つまり、@code{ctl-arrow}の値に依存してコントロール文字は、
2コラムか4コラム占めると数え、
タブ文字は、タブの開始コラムと@code{tab-width}の値に依存する
コラム数を占めると数えることを意味します。
@xref{Usual Display}。

@c   Column number computations ignore the width of the window and the
@c amount of horizontal scrolling.  Consequently, a column value can be
@c arbitrarily high.  The first (or leftmost) column is numbered 0.
コラム番号の計算では、ウィンドウの幅や水平スクロール量を無視します。
その結果、コラム値は任意の大きさになりえます。
最初の（スクリーン左端の）コラムの番号は0です。

@defun current-column
@c This function returns the horizontal position of point, measured in
@c columns, counting from 0 at the left margin.  The column position is the
@c sum of the widths of all the displayed representations of the characters
@c between the start of the current line and point.
この関数は、左端を0としてコラム数で数えたポイントの水平位置を返す。
コラム位置は、現在行の先頭からポイント位置までの文字すべての
表示上の表記の幅の総和である。

@c For an example of using @code{current-column}, see the description of
@c @code{count-lines} in @ref{Text Lines}.
@code{current-column}の使用例については、
@ref{Text Lines}の@code{count-lines}を参照。
@end defun

@defun move-to-column column &optional force
@c This function moves point to @var{column} in the current line.  The
@c calculation of @var{column} takes into account the widths of the
@c displayed representations of the characters between the start of the
@c line and point.
この関数は、ポイントを現在行の@var{column}へ移動する。
@var{column}の計算では、現在行の先頭からポイント位置までの
文字すべての表示上の表記の幅を考慮する。

@c If column @var{column} is beyond the end of the line, point moves to the
@c end of the line.  If @var{column} is negative, point moves to the
@c beginning of the line.
コラム@var{column}が行末を越える場合、ポイントを行末へ移動する。
@var{column}が負であると、ポイントを行頭へ移動する。

@c If it is impossible to move to column @var{column} because that is in
@c the middle of a multicolumn character such as a tab, point moves to the
@c end of that character.  However, if @var{force} is non-@code{nil}, and
@c @var{column} is in the middle of a tab, then @code{move-to-column}
@c converts the tab into spaces so that it can move precisely to column
@c @var{column}.  Other multicolumn characters can cause anomalies despite
@c @var{force}, since there is no way to split them.
コラム@var{column}がタブなどの複数コラムを占める文字の中ほどにあるために
そこへ移動できない場合には、
ポイントを当該文字の末尾へ移動する。
しかし、@var{force}が@code{nil}以外であり
@var{column}がタブの中ほどであると、
コラム@var{column}に正確に移動できるようにタブを空白に変換する。
複数コラムを占めるその他の文字では、それらを分割する方法がないため、
@var{force}を指定しても変則的になる。

@c The argument @var{force} also has an effect if the line isn't long
@c enough to reach column @var{column}; in that case, it says to add
@c whitespace at the end of the line to reach that column.
コラム@var{column}に到達できるほど行が長くない場合にも
引数@var{force}には効果がある。
そのような場合、指定コラムに達するように行末に白文字を追加する。

@c If @var{column} is not an integer, an error is signaled.
@var{column}が整数でないと、エラーを通知する。

@c The return value is the column number actually moved to.
戻り値は、実際の移動先のコラム番号である。
@end defun

@node Indentation
@c @section Indentation
@section 字下げ
@c @cindex indentation
@cindex 字下げ

@c   The indentation functions are used to examine, move to, and change
@c whitespace that is at the beginning of a line.  Some of the functions
@c can also change whitespace elsewhere on a line.  Columns and indentation
@c count from zero at the left margin.
字下げ関数は、行頭の空白を調べたり、そこへ移動したり、
変更するために使います。
行の他の白文字を変更するものもあります。
コラム関数と字下げ関数は左端を0と数えます。

@menu
* Primitive Indent::      Functions used to count and insert indentation.
* Mode-Specific Indent::  Customize indentation for different modes.
* Region Indent::         Indent all the lines in a region.
* Relative Indent::       Indent the current line based on previous lines.
* Indent Tabs::           Adjustable, typewriter-like tab stops.
* Motion by Indent::      Move to first non-blank character.
@end menu

@node Primitive Indent
@c @subsection Indentation Primitives
@subsection 字下げ基本関数

@c   This section describes the primitive functions used to count and
@c insert indentation.  The functions in the following sections use these
@c primitives.  @xref{Width}, for related functions.
本節では、字下げを数えたり挿入するために使われる基本関数について述べます。
後続の節の関数群は、これらの基本関数を使っています。
関連する関数については、@xref{Width}。

@defun current-indentation
@comment !!Type Primitive Function
@comment !!SourceFile indent.c
@c This function returns the indentation of the current line, which is
@c the horizontal position of the first nonblank character.  If the
@c contents are entirely blank, then this is the horizontal position of the
@c end of the line.
この関数は、現在行の字下げを返す。
これは最初の白文字以外の文字の水平位置である。
行全体が白文字や空である場合には、行末の水平位置を返す。
@end defun

@c @deffn Command indent-to column &optional minimum
@deffn コマンド indent-to column &optional minimum
@comment !!Type Primitive Function
@comment !!SourceFile indent.c
@c This function indents from point with tabs and spaces until @var{column}
@c is reached.  If @var{minimum} is specified and non-@code{nil}, then at
@c least that many spaces are inserted even if this requires going beyond
@c @var{column}.  Otherwise the function does nothing if point is already
@c beyond @var{column}.  The value is the column at which the inserted
@c indentation ends.
この関数は、ポイント位置から@var{column}に達するまでタブや空白で字下げする。
@var{minimum}を指定し@code{nil}以外であると、
@var{column}を越える場合であっても最低@var{minimum}個の空白を挿入する。
さもなければ、ポイントが@var{column}を越えている場合には、
この関数はなにもしない。
戻り値は、挿入した字下げが終る箇所のコラムである。

@c The inserted whitespace characters inherit text properties from the
@c surrounding text (usually, from the preceding text only).  @xref{Sticky
@c Properties}.
挿入された白文字は周りの文字（普通は、まえの文字）からテキスト属性を継承する。
@pxref{Sticky Properties}。
@end deffn

@defopt indent-tabs-mode
@comment !!SourceFile indent.c
@c If this variable is non-@code{nil}, indentation functions can insert
@c tabs as well as spaces.  Otherwise, they insert only spaces.  Setting
@c this variable automatically makes it buffer-local in the current buffer.
この変数が@code{nil}以外であると、
字下げ関数は空白に加えてタブも挿入する。
さもなければ、空白のみを挿入する。
この変数に設定すると、カレントバッファでバッファローカルになる。
@end defopt

@node Mode-Specific Indent
@c @subsection Indentation Controlled by Major Mode
@subsection メジャーモードの制御による字下げ

@c   An important function of each major mode is to customize the @key{TAB}
@c key to indent properly for the language being edited.  This section
@c describes the mechanism of the @key{TAB} key and how to control it.
@c The functions in this section return unpredictable values.
各メジャーモードの重要な機能は、
キー@key{TAB}を編集対象の言語に適した字下げにカスタマイズすることです。
本節では、キー@key{TAB}の機構とそれを制御する方法について述べます。
本節の関数は、予測できない値を返します。

@defvar indent-line-function
@c This variable's value is the function to be used by @key{TAB} (and
@c various commands) to indent the current line.  The command
@c @code{indent-according-to-mode} does no more than call this function.
この変数の値は、現在行を字下げするために
@key{TAB}（やさまざまなコマンド）が使う関数である。
コマンド@code{indent-according-to-mode}は、
この関数を呼ぶこと以上のことはしない。

@c In Lisp mode, the value is the symbol @code{lisp-indent-line}; in C
@c mode, @code{c-indent-line}; in Fortran mode, @code{fortran-indent-line}.
@c In Fundamental mode, Text mode, and many other modes with no standard
@c for indentation, the value is @code{indent-to-left-margin} (which is the
@c default value).
lispモードでは値はシンボル@code{lisp-indent-line}、
Cモードでは@code{c-indent-line}、
fortranモードでは@code{fortran-indent-line}である。
標準的な字下げがない基本（fundamental）モード、
テキスト（text）モード、他の多くのモードでは、
値は@code{indent-to-left-margin}（デフォルト値）である
@end defvar

@c @deffn Command indent-according-to-mode
@deffn コマンド indent-according-to-mode
@c This command calls the function in @code{indent-line-function} to
@c indent the current line in a way appropriate for the current major mode.
このコマンドは、現在のメジャーモードに適した方法で現在行を字下げするために
@code{indent-line-function}で指定される関数を呼び出す。
@end deffn

@c @deffn Command indent-for-tab-command
@deffn コマンド indent-for-tab-command
@c This command calls the function in @code{indent-line-function} to indent
@c the current line; however, if that function is
@c @code{indent-to-left-margin}, @code{insert-tab} is called instead.  (That
@c is a trivial command that inserts a tab character.)
このコマンドは、現在行を字下げするために
@code{indent-line-function}で指定される関数を呼び出すが、
その関数が@code{indent-to-left-margin}であると、
かわりに@code{insert-tab}を呼び出す。
（これはタブ文字を挿入する単純なコマンドである。）
@end deffn

@c @deffn Command newline-and-indent
@deffn コマンド newline-and-indent
@comment !!SourceFile simple.el
@c This function inserts a newline, then indents the new line (the one
@c following the newline just inserted) according to the major mode.
この関数は、改行を挿入してから、
（改行を挿入したばかりの行に続く）新たな行を
メジャーモードに基づいて字下げする。

@c It does indentation by calling the current @code{indent-line-function}.
@c In programming language modes, this is the same thing @key{TAB} does,
@c but in some text modes, where @key{TAB} inserts a tab,
@c @code{newline-and-indent} indents to the column specified by
@c @code{left-margin}.
現在の@code{indent-line-function}を呼び出して字下げを行う。
プログラム言語向けのモードでは、これは@key{TAB}が行うことと同じであるが、
@key{TAB}がタブを挿入するテキスト向けのモードの一部では、
@code{newline-and-indent}は@code{left-margin}で指定されたコラムに字下げする。
@end deffn

@c @deffn Command reindent-then-newline-and-indent
@deffn コマンド reindent-then-newline-and-indent
@comment !!SourceFile simple.el
@c This command reindents the current line, inserts a newline at point,
@c and then indents the new line (the one following the newline just
@c inserted).
このコマンドは、現在行を字下げし直し、ポイント位置に改行を挿入し、
（改行を挿入したばかりの行に続く）新たな行を字下げする。

@c This command does indentation on both lines according to the current
@c major mode, by calling the current value of @code{indent-line-function}.
@c In programming language modes, this is the same thing @key{TAB} does,
@c but in some text modes, where @key{TAB} inserts a tab,
@c @code{reindent-then-newline-and-indent} indents to the column specified
@c by @code{left-margin}.
このコマンドは、@code{indent-line-function}の現在の値を呼び出すことで、
どちらの行も現在のメジャーモードに基づいて字下げする。
プログラム言語向けのモードでは、これは@key{TAB}が行うことと同じであるが、
@key{TAB}がタブを挿入するテキスト向けのモードの一部では、
@code{reindent-then-newline-and-indent}は、
@code{left-margin}で指定されるコラムに字下げする。
@end deffn

@node Region Indent
@c @subsection Indenting an Entire Region
@subsection 領域全体の字下げ

@c   This section describes commands that indent all the lines in the
@c region.  They return unpredictable values.
本節では、領域内のすべての行を字下げするコマンドについて述べます。
これらは予測できない値を返します。

@c @deffn Command indent-region start end to-column
@deffn コマンド indent-region start end to-column
@c This command indents each nonblank line starting between @var{start}
@c (inclusive) and @var{end} (exclusive).  If @var{to-column} is
@c @code{nil}, @code{indent-region} indents each nonblank line by calling
@c the current mode's indentation function, the value of
@c @code{indent-line-function}.
このコマンドは、@var{start}（を含めて）と
@var{end}（を含めない）のあいだで始まる空でない各行を字下げする。
@var{to-column}が@code{nil}であると、
@code{indent-region}は、現在のモードの字下げ関数、
つまり、@code{indent-line-function}の値を呼び出して、
空でない各行を字下げする。

@c If @var{to-column} is non-@code{nil}, it should be an integer
@c specifying the number of columns of indentation; then this function
@c gives each line exactly that much indentation, by either adding or
@c deleting whitespace.
@var{to-column}が@code{nil}以外であると、
それは字下げ先のコラム番号を指定する整数であること。
すると、この関数は、白文字を追加するか削除して、
各行を指定どおりに字下げする。

@c If there is a fill prefix, @code{indent-region} indents each line
@c by making it start with the fill prefix.
詰め込み接頭辞がある場合、
@code{indent-region}は詰め込み接頭辞で行を始めることで各行を字下げする。
@end deffn

@defvar indent-region-function
@c The value of this variable is a function that can be used by
@c @code{indent-region} as a short cut.  It should take two arguments, the
@c start and end of the region.  You should design the function so
@c that it will produce the same results as indenting the lines of the
@c region one by one, but presumably faster.
この変数の値は、@code{indent-region}の短縮版として利用可能な関数である。
領域の開始位置と終了位置の2つの引数をとる。
領域の行を1つ1つ字下げする場合と同じ結果を生じるが、
より速く動作することを意図してこの関数を設計するべきである。

@c If the value is @code{nil}, there is no short cut, and
@c @code{indent-region} actually works line by line.
値が@code{nil}であると短縮版はなく、
@code{indent-region}が実際に1行ずつ処理する。

@c A short-cut function is useful in modes such as C mode and Lisp mode,
@c where the @code{indent-line-function} must scan from the beginning of
@c the function definition: applying it to each line would be quadratic in
@c time.  The short cut can update the scan information as it moves through
@c the lines indenting them; this takes linear time.  In a mode where
@c indenting a line individually is fast, there is no need for a short cut.
短縮版関数はCモードやlispモードのようなモードで有用である。
そのようなモードでは、@code{indent-line-function}で関数定義の始まりを
走査する必要があり、これを各行に適用すると自乗の時間がかかる。
短縮版では、字下げし終えた関数定義を通過するたびに
走査情報を更新でき、これには線形時間かかるだけである。
個々の行を高速に字下げできるモードでは、短縮版は必要ない。

@c @code{indent-region} with a non-@code{nil} argument @var{to-column} has
@c a different meaning and does not use this variable.
引数@var{to-column}に@code{nil}以外を指定した@code{indent-region}には
別の意味があり、この変数を使わない。
@end defvar

@c @deffn Command indent-rigidly start end count
@deffn コマンド indent-rigidly start end count
@comment !!SourceFile indent.el
@c This command indents all lines starting between @var{start}
@c (inclusive) and @var{end} (exclusive) sideways by @var{count} columns.
@c This ``preserves the shape'' of the affected region, moving it as a
@c rigid unit.  Consequently, this command is useful not only for indenting
@c regions of unindented text, but also for indenting regions of formatted
@c code.
このコマンドは、@var{start}（を含めて）と
@var{end}（を含めない）のあいだで始まる行すべてを
コラム数@var{count}だけ字下げする。
これは、領域を1つの塊として動かしてその領域の『形を保つ』。
このコマンドは、字下げしていないテキストの領域だけでなく、
整形済みの領域を字下げするためにも有用である。

@c For example, if @var{count} is 3, this command adds 3 columns of
@c indentation to each of the lines beginning in the region specified.
たとえば、@var{count}が3であると、
このコマンドは指定した領域内の各行の行頭に3コラムの字下げを追加する。

@c In Mail mode, @kbd{C-c C-y} (@code{mail-yank-original}) uses
@c @code{indent-rigidly} to indent the text copied from the message being
@c replied to.
メイル（mail）モードでは、@kbd{C-c C-y}（@code{mail-yank-original}）が
返信対象のメッセージからコピーしたテキストを字下げするために
@code{indent-rigidly}を使っている。
@end deffn

@defun indent-code-rigidly start end columns &optional nochange-regexp
@c This is like @code{indent-rigidly}, except that it doesn't alter lines
@c that start within strings or comments.
この関数は@code{indent-rigidly}と同様であるが、
文字列やコメントで始まる行を変更しない点が異なる。

@c In addition, it doesn't alter a line if @var{nochange-regexp} matches at
@c the beginning of the line (if @var{nochange-regexp} is non-@code{nil}).
さらに、（@var{nochange-regexp}が@code{nil}以外のとき）
行の先頭が@var{nochange-regexp}に一致する場合にも行を変更しない。
@end defun

@node Relative Indent
@c @subsection Indentation Relative to Previous Lines
@subsection 先行行相対の字下げ

@c   This section describes two commands that indent the current line
@c based on the contents of previous lines.
本節では、先行する行の内容に基づいて現在行を字下げする2つの
コマンドについて述べます。

@c @deffn Command indent-relative &optional unindented-ok
@deffn コマンド indent-relative &optional unindented-ok
@c This command inserts whitespace at point, extending to the same
@c column as the next @dfn{indent point} of the previous nonblank line.  An
@c indent point is a non-whitespace character following whitespace.  The
@c next indent point is the first one at a column greater than the current
@c column of point.  For example, if point is underneath and to the left of
@c the first non-blank character of a line of text, it moves to that column
@c by inserting whitespace.
このコマンドは、空白でないまえの行のつぎの@dfn{字下げ位置}のコラムに
達するまで、ポイント位置に白文字を挿入する。
字下げ位置とは、白文字に続く白文字以外の文字である。
つぎの字下げ位置とは、現在行のポイントのコラム位置より大きな
最初の字下げ位置のことである。
たとえば、テキスト行の白文字以外の最初の文字より左側で、
その下の行にポイントがあると、
白文字を挿入してそのコラム位置にポイントを移動する。

@c If the previous nonblank line has no next indent point (i.e., none at a
@c great enough column position), @code{indent-relative} either does
@c nothing (if @var{unindented-ok} is non-@code{nil}) or calls
@c @code{tab-to-tab-stop}.  Thus, if point is underneath and to the right
@c of the last column of a short line of text, this command ordinarily
@c moves point to the next tab stop by inserting whitespace.
空白でないまえの行に、つぎの字下げ位置（つまり、ポイント位置より
大きなコラム）がないと、@code{indent-relative}は、
（@var{unindented-ok}が@code{nil}以外であれば）なにもしないか、
@code{tab-to-tab-stop}を呼び出す。
したがって、まえのテキスト行が短くてその行末より右側で、
その下の行にポイントがあると、このコマンドは、通常どおり、
白文字を挿入してつぎのタブ位置へポイントを移動する。

@c The return value of @code{indent-relative} is unpredictable.
@code{indent-relative}の戻り値は予測できない。

@c In the following example, point is at the beginning of the second
@c line:
つぎの例では、ポイントは2行目の行頭にある。

@example
@group
            This line is indented twelve spaces.
@point{}The quick brown fox jumped.
@end group
@end example

@noindent
@c Evaluation of the expression @code{(indent-relative nil)} produces the
@c following:
式@code{(indent-relative nil)}を評価すると、つぎのようになる。

@example
@group
            This line is indented twelve spaces.
            @point{}The quick brown fox jumped.
@end group
@end example

@c   In this next example, point is between the @samp{m} and @samp{p} of
@c @samp{jumped}:
つぎの例では、ポイントは@samp{jumped}の@samp{m}と@samp{p}のあいだにある。

@example
@group
            This line is indented twelve spaces.
The quick brown fox jum@point{}ped.
@end group
@end example

@noindent
@c Evaluation of the expression @code{(indent-relative nil)} produces the
@c following:
式@code{(indent-relative nil)}を評価すると、つぎのようになる。

@example
@group
            This line is indented twelve spaces.
The quick brown fox jum  @point{}ped.
@end group
@end example
@end deffn

@c @deffn Command indent-relative-maybe
@deffn コマンド indent-relative-maybe
@comment !!SourceFile indent.el
@c This command indents the current line like the previous nonblank line,
@c by calling @code{indent-relative} with @code{t} as the
@c @var{unindented-ok} argument.  The return value is unpredictable.
このコマンドは、引数@var{unindented-ok}に@code{t}を指定して
@code{indent-relative}を呼び出すことで、
まえの行と同様に字下げする。
戻り値は予測できない。

@c If the previous nonblank line has no indent points beyond the current
@c column, this command does nothing.
空行でないまえの行に現在のコラム位置を越える字下げ位置がなければ、
このコマンドはなにもしない。
@end deffn

@node Indent Tabs
@comment  node-name,  next,  previous,  up
@c @subsection Adjustable ``Tab Stops''
@subsection 調整可能な『タブストップ』
@c @cindex tabs stops for indentation
@cindex 字下げのためのタブストップ

@c   This section explains the mechanism for user-specified ``tab stops''
@c and the mechanisms that use and set them.  The name ``tab stops'' is
@c used because the feature is similar to that of the tab stops on a
@c typewriter.  The feature works by inserting an appropriate number of
@c spaces and tab characters to reach the next tab stop column; it does not
@c affect the display of tab characters in the buffer (@pxref{Usual
@c Display}).  Note that the @key{TAB} character as input uses this tab
@c stop feature only in a few major modes, such as Text mode.
本節では、ユーザー指定の『タブストップ』の機構と、
それを使ったり設定するための機構について説明します。
『タブストップ』という名前を使うのは、
この機構がタイプライタのタブストップに似た機能だからです。
この機能は、適切な個数の空白とタブ文字を挿入して
つぎのタブストップのコラムへ到達しますが、
バッファ内のタブ文字の表示に影響することはありません
（@pxref{Usual Display}）。
テキスト（text）モードなどの少数のメジャーモードでのみ、
入力としての文字@key{TAB}がこのタブストップ機能を使います。

@c @deffn Command tab-to-tab-stop
@deffn コマンド tab-to-tab-stop
@c This command inserts spaces or tabs before point, up to the next tab
@c stop column defined by @code{tab-stop-list}.  It searches the list for
@c an element greater than the current column number, and uses that element
@c as the column to indent to.  It does nothing if no such element is
@c found.
このコマンドは、@code{tab-stop-list}で定義されたつぎのタブストップコラムまで、
ポイントのまえに空白やタブを挿入する。
このリストで現在のコラム番号より大きな要素を探し、
その要素を字下げ位置のコラムとして使う。
そのような要素がなければ、このコマンドはないもしない。
@end deffn

@defopt tab-stop-list
@c This variable is the list of tab stop columns used by
@c @code{tab-to-tab-stops}.  The elements should be integers in increasing
@c order.  The tab stop columns need not be evenly spaced.
この変数は、@code{tab-to-tab-stops}が使うタブストップコラムのリストである。
それらの要素は、昇順の整数であること。
タブストップコラムの間隔は、等間隔である必要はない。

@c Use @kbd{M-x edit-tab-stops} to edit the location of tab stops
@c interactively.
タブストップを対話的に編集するには@kbd{M-x edit-tab-stops}を使う。
@end defopt

@node Motion by Indent
@c @subsection Indentation-Based Motion Commands
@subsection 字下げに基づく移動コマンド

@c   These commands, primarily for interactive use, act based on the
@c indentation in the text.
これらのコマンドは、主に対話的に使うもので、
テキストの字下げに基づいて動作します。

@c @deffn Command back-to-indentation 
@deffn コマンド back-to-indentation 
@comment !!SourceFile simple.el
@c This command moves point to the first non-whitespace character in the
@c current line (which is the line in which point is located).  It returns
@c @code{nil}.
このコマンドは、現在行（ポイントが位置する行）の
白文字でない最初の文字へポイントを移動する。
@code{nil}を返す。
@end deffn

@c @deffn Command backward-to-indentation arg
@deffn コマンド backward-to-indentation arg
@comment !!SourceFile simple.el
@c This command moves point backward @var{arg} lines and then to the
@c first nonblank character on that line.  It returns @code{nil}.
このコマンドは、@var{arg}行だけポイントを後方へ移動してから、
当該行の白文字でない最初の文字へポイントを移動する。
@code{nil}を返す。
@end deffn

@c @deffn Command forward-to-indentation arg
@deffn コマンド forward-to-indentation arg
@comment !!SourceFile simple.el
@c This command moves point forward @var{arg} lines and then to the first
@c nonblank character on that line.  It returns @code{nil}.
このコマンドは、@var{arg}行だけポイントを前方へ移動してから、
当該行の白文字でない最初の文字へポイントを移動する。
@code{nil}を返す。
@end deffn

@node Case Changes
@comment  node-name,  next,  previous,  up
@c @section Case Changes
@section 大文字小文字の変更
@c @cindex case conversion in buffers
@cindex バッファ内での大文字小文字変換

@c   The case change commands described here work on text in the current
@c buffer.  @xref{Case Conversion}, for case conversion functions that work
@c on strings and characters.  @xref{Case Tables}, for how to customize
@c which characters are upper or lower case and how to convert them.
ここに述べる大文字小文字の変更コマンドは、
カレントバッファのテキストに作用します。
文字列や文字の大文字小文字を変換する関数については、
@xref{Case Conversion}。
どの文字が大文字でどの文字が小文字であり、それらをどのように変換するかを
カスタマイズする方法については、@xref{Case Tables}。

@c @deffn Command capitalize-region start end
@deffn コマンド capitalize-region start end
@c This function capitalizes all words in the region defined by
@c @var{start} and @var{end}.  To capitalize means to convert each word's
@c first character to upper case and convert the rest of each word to lower
@c case.  The function returns @code{nil}.
この関数は、@var{start}と@var{end}で定義される領域内の
すべての単語をキャピタライズ（大文字で始まるように）する。
つまり、各単語の最初の文字を大文字に、残りの文字を小文字に変換する。
この関数は@code{nil}を返す。

@c If one end of the region is in the middle of a word, the part of the
@c word within the region is treated as an entire word.
領域の端が単語の途中にあると、
その単語の領域内の部分を1つの単語とみなす。

@c When @code{capitalize-region} is called interactively, @var{start} and
@c @var{end} are point and the mark, with the smallest first.
@code{capitalize-region}を対話的に呼び出すと、
@var{start}と@var{end}はポイントとマークであり、小さいほうがさきにくる。

@example
@group
---------- Buffer: foo ----------
This is the contents of the 5th foo.
---------- Buffer: foo ----------
@end group

@group
(capitalize-region 1 44)
@result{} nil

---------- Buffer: foo ----------
This Is The Contents Of The 5th Foo.
---------- Buffer: foo ----------
@end group
@end example
@end deffn

@c @deffn Command downcase-region start end
@deffn コマンド downcase-region start end
@c This function converts all of the letters in the region defined by
@c @var{start} and @var{end} to lower case.  The function returns
@c @code{nil}.
この関数は、@var{start}と@var{end}で定義される領域内の
すべての文字を小文字に変換する。
この関数は@code{nil}を返す。

@c When @code{downcase-region} is called interactively, @var{start} and
@c @var{end} are point and the mark, with the smallest first.
@code{downcase-region}を対話的に呼び出すと、
@var{start}と@var{end}はポイントとマークであり、小さいほうが先にくる。
@end deffn

@c @deffn Command upcase-region start end
@deffn コマンド upcase-region start end
@c This function converts all of the letters in the region defined by
@c @var{start} and @var{end} to upper case.  The function returns
@c @code{nil}.
この関数は、@var{start}と@var{end}で定義される領域内の
すべての文字を大文字に変換する。
この関数は@code{nil}を返す。

@c When @code{upcase-region} is called interactively, @var{start} and
@c @var{end} are point and the mark, with the smallest first.
@code{upcase-region}を対話的に呼び出すと、
@var{start}と@var{end}はポイントとマークであり、小さいほうが先にくる。
@end deffn

@c @deffn Command capitalize-word count
@deffn コマンド capitalize-word count
@c This function capitalizes @var{count} words after point, moving point
@c over as it does.  To capitalize means to convert each word's first
@c character to upper case and convert the rest of each word to lower case.
@c If @var{count} is negative, the function capitalizes the
@c @minus{}@var{count} previous words but does not move point.  The value
@c is @code{nil}.
この関数は、ポイントのうしろの@var{count}個の単語を
キャピタライズ（大文字で始まるように）し、ポイントをそれらの末尾に移動する。
つまり、各単語の最初の文字を大文字に、残りの文字を小文字に変換する。
@var{count}が負であると、まえの@minus{}@var{count}個の単語を
大文字で始まるようにするが、ポイントは移動しない。
値は@code{nil}である。

@c If point is in the middle of a word, the part of the word before point
@c is ignored when moving forward.  The rest is treated as an entire word.
ポイントが単語の途中にあると、単語を前方へ移動するときには
ポイントよりまえにある単語の部分を無視する。
単語の残りの部分を1つの単語として扱う。

@c When @code{capitalize-word} is called interactively, @var{count} is
@c set to the numeric prefix argument.
@code{capitalize-word}を対話的に呼び出すと、
@var{count}は数値前置引数である。
@end deffn

@c @deffn Command downcase-word count
@deffn コマンド downcase-word count
@c This function converts the @var{count} words after point to all lower
@c case, moving point over as it does.  If @var{count} is negative, it
@c converts the @minus{}@var{count} previous words but does not move point.
@c The value is @code{nil}.
この関数は、ポイントのうしろの@var{count}個の単語を
すべて小文字に替え、ポイントをそれらの末尾に移動する。
@var{count}が負であると、まえの@minus{}@var{count}個の単語を
変換するが、ポイントは移動しない。
値は@code{nil}である。

@c When @code{downcase-word} is called interactively, @var{count} is set
@c to the numeric prefix argument.
@code{downcase-word}を対話的に呼び出すと、
@var{count}は数値前置引数である。
@end deffn

@c @deffn Command upcase-word count
@deffn コマンド upcase-word count
@c This function converts the @var{count} words after point to all upper
@c case, moving point over as it does.  If @var{count} is negative, it
@c converts the @minus{}@var{count} previous words but does not move point.
@c The value is @code{nil}.
この関数は、ポイントのうしろの@var{count}個の単語を
すべて大文字に替え、ポイントをそれらの末尾に移動する。
@var{count}が負であると、まえの@minus{}@var{count}個の単語を
変換するが、ポイントは移動しない。
値は@code{nil}である。

@c When @code{upcase-word} is called interactively, @var{count} is set to
@c the numeric prefix argument.
@code{upcase-word}を対話的に呼び出すと、
@var{count}は数値前置引数である。
@end deffn

@node Text Properties
@c @section Text Properties
@section テキスト属性
@c @cindex text properties
@c @cindex attributes of text
@c @cindex properties of text
@cindex テキスト属性
@cindex 属性、テキスト

@c   Each character position in a buffer or a string can have a @dfn{text
@c property list}, much like the property list of a symbol (@pxref{Property
@c Lists}).  The properties belong to a particular character at a
@c particular place, such as, the letter @samp{T} at the beginning of this
@c sentence or the first @samp{o} in @samp{foo}---if the same character
@c occurs in two different places, the two occurrences generally have
@c different properties.
シンボルの属性リスト（@pxref{Property Lists}）のように、
バッファや文字列の各文字には@dfn{テキスト属性リスト}
（text property list）を持てます。
この属性は、（本節の原文のタイトルの）文字@samp{T}や
@samp{foo}の最初の@samp{o}のような特定の箇所の特定の文字に属します。
同じ文字が異なる箇所に現れるとき、
一般にはそれぞれに異なる属性を持てます。

@c   Each property has a name and a value.  Both of these can be any Lisp
@c object, but the name is normally a symbol.  The usual way to access the
@c property list is to specify a name and ask what value corresponds to it.
各属性には、名前と値があります。
どちらも任意のLispオブジェクトでかまいませんが、
名前は普通はシンボルです。
属性リストを参照する普通の方法では、
名前を指定してそれに対応する値を問い合わせます。

@c   If a character has a @code{category} property, we call it the
@c @dfn{category} of the character.  It should be a symbol.  The properties
@c of the symbol serve as defaults for the properties of the character.
文字に属性@code{category}があるとき、
それを文字の@dfn{カテゴリ}（category）といいます。
それはシンボルであるべきです。
そのシンボルの属性が、文字の属性のデフォルトとして働きます。

@c   Copying text between strings and buffers preserves the properties
@c along with the characters; this includes such diverse functions as
@c @code{substring}, @code{insert}, and @code{buffer-substring}.
文字列とバッファのあいだでテキストをコピーすると、
文字とともにその属性も保たれます。
@code{substring}、@code{insert}、@code{buffer-substring}などの
さまざまな関数がそうします。

@menu
* Examining Properties::	Looking at the properties of one character.
* Changing Properties::		Setting the properties of a range of text.
* Property Search::		Searching for where a property changes value.
* Special Properties::		Particular properties with special meanings.
* Format Properties::           Properties for representing formatting of text.
* Sticky Properties::           How inserted text gets properties from
                                  neighboring text.
* Saving Properties::           Saving text properties in files, and reading
                                  them back.
* Lazy Properties::             Computing text properties in a lazy fashion
                                  only when text is examined.
* Clickable Text::              Using text properties to make regions of text
                                  do something when you click on them.
* Not Intervals::		Why text properties do not use
				  Lisp-visible text intervals.
@end menu

@node Examining Properties
@c @subsection Examining Text Properties
@subsection テキスト属性を調べる

@c   The simplest way to examine text properties is to ask for the value of
@c a particular property of a particular character.  For that, use
@c @code{get-text-property}.  Use @code{text-properties-at} to get the
@c entire property list of a character.  @xref{Property Search}, for
@c functions to examine the properties of a number of characters at once.
テキスト属性を調べるもっとも簡単な方法は、
特定の文字の特定の属性の値を問い合わせることです。
それには、@code{get-text-property}を使います。
文字の属性リスト全体を取得するには@code{text-properties-at}を使います。
複数の文字の属性を一度に調べるための関数については、
@xref{Property Search}。

@c   These functions handle both strings and buffers.  Keep in mind that
@c positions in a string start from 0, whereas positions in a buffer start
@c from 1.
これらの関数は、文字列とバッファの両方を扱えます。
文字列内の位置は0から始まり、
バッファ内の位置は1から始まることに注意してください。

@defun get-text-property pos prop &optional object
@c This function returns the value of the @var{prop} property of the
@c character after position @var{pos} in @var{object} (a buffer or
@c string).  The argument @var{object} is optional and defaults to the
@c current buffer.
この関数は、@var{object}（バッファか文字列）内の位置@var{pos}の
うしろの1文字の属性@var{prop}の値を返す。
引数@var{object}は省略でき、
デフォルトはカレントバッファである。

@c If there is no @var{prop} property strictly speaking, but the character
@c has a category that is a symbol, then @code{get-text-property} returns
@c the @var{prop} property of that symbol.
その文字に属性@var{prop}がなくてもシンボルであるカテゴリがあれば、
@code{get-text-property}は当該シンボルの属性@var{prop}を返す。
@end defun

@defun get-char-property pos prop &optional object
@c This function is like @code{get-text-property}, except that it checks
@c overlays first and then text properties.  @xref{Overlays}.
この関数は@code{get-text-property}に似ているが、
まずオーバレイを調べてからテキスト属性を調べる。
@pxref{Overlays}。

@c The argument @var{object} may be a string, a buffer, or a window.  If it
@c is a window, then the buffer displayed in that window is used for text
@c properties and overlays, but only the overlays active for that window
@c are considered.  If @var{object} is a buffer, then all overlays in that
@c buffer are considered, as well as text properties.  If @var{object} is a
@c string, only text properties are considered, since strings never have
@c overlays.
引数@var{object}は、文字列、バッファ、ウィンドウのいずれかである。
ウィンドウであると、そのウィンドウに表示しているバッファの
テキスト属性とオーバレイを対象にするが、
対象となるオーバレイはそのウィンドウに対して活性なものだけである。
@var{object}がバッファであると、テキスト属性に加えて
そのバッファのすべてのオーバレイを対象にする。
@var{object}が文字列であると、
文字列にはオーバレイはないので、テキスト属性のみを対象にする。
@end defun

@defun text-properties-at position &optional object
@c This function returns the entire property list of the character at
@c @var{position} in the string or buffer @var{object}.  If @var{object} is
@c @code{nil}, it defaults to the current buffer.
この関数は、文字列やバッファである@var{object}内の
位置@var{position}にある1文字の属性リスト全体を返す。
@var{object}が@code{nil}であると、デフォルトはカレントバッファである。
@end defun

@defvar default-text-properties
@c This variable holds a property list giving default values for text
@c properties.  Whenever a character does not specify a value for a
@c property, neither directly nor through a category symbol, the value
@c stored in this list is used instead.  Here is an example:
この変数は、テキスト属性のデフォルト値を与える属性リストを保持する。
直接的にもカテゴリシンボルを介して間接的にも
文字に属性の値が指定されていないと、
このリストに収めた値をかわりに使う。
つぎに例を示す。

@example
(setq default-text-properties '(foo 69))
@c ;; @r{Make sure character 1 has no properties of its own.}
;; @r{位置1の文字に属性がないことを保証する}
(set-text-properties 1 2 nil)
@c ;; @r{What we get, when we ask, is the default value.}
;; @r{問い合わせたときに見えるのはデフォルト値である}
(get-text-property 1 'foo)
     @result{} 69
@end example
@end defvar

@node Changing Properties
@c @subsection Changing Text Properties
@subsection テキスト属性の変更

@c   The primitives for changing properties apply to a specified range of
@c text in a buffer or string.  The function @code{set-text-properties}
@c (see end of section) sets the entire property list of the text in that
@c range; more often, it is useful to add, change, or delete just certain
@c properties specified by name.
属性を変更する基本関数は、バッファや文字列の指定した範囲に作用します。
関数@code{set-text-properties}（本節の最後）は、
その範囲のテキストの属性リスト全体を設定します。
これは、名前で指定した特定の属性のみを追加／変更／削除するのに
しばしば有用です。

@c   Since text properties are considered part of the contents of the
@c buffer (or string), and can affect how a buffer looks on the screen, any
@c change in buffer text properties mark the buffer as modified.  Buffer
@c text property changes are undoable also (@pxref{Undo}).
テキスト属性はバッファ（や文字列）の一部分であるとみなされ、
スクリーン上でのバッファの見た目に影響するので、
バッファのテキスト属性を変更すると、
バッファには変更済みの印を付けます。
バッファのテキスト属性の変更もアンドゥ（@pxref{Undo}）できます。

@defun put-text-property start end prop value &optional object
@c This function sets the @var{prop} property to @var{value} for the text
@c between @var{start} and @var{end} in the string or buffer @var{object}.
@c If @var{object} is @code{nil}, it defaults to the current buffer.
この関数は、文字列やバッファである@var{object}内の
@var{start}と@var{end}のあいだのテキストの属性@var{prop}の値を
@var{value}とする。
@var{object}が@code{nil}であると、デフォルトはカレントバッファである。
@end defun

@defun add-text-properties start end props &optional object
@c This function adds or overrides text properties for the text between
@c @var{start} and @var{end} in the string or buffer @var{object}.  If
@c @var{object} is @code{nil}, it defaults to the current buffer.
この関数は、文字列やバッファである@var{object}内の
@var{start}と@var{end}のあいだのテキストの
テキスト属性に追加／上書きする。
@var{object}が@code{nil}であると、デフォルトはカレントバッファである。

@c The argument @var{props} specifies which properties to add.  It should
@c have the form of a property list (@pxref{Property Lists}): a list whose
@c elements include the property names followed alternately by the
@c corresponding values.
引数@var{props}で追加する属性を指定する。
これは属性リスト（@pxref{Property Lists}）の形であること。
つまり、属性名とその値を交互に並べたリストであること。

@c The return value is @code{t} if the function actually changed some
@c property's value; @code{nil} otherwise (if @var{props} is @code{nil} or
@c its values agree with those in the text).
この関数が属性の値をどれか実際に変更したならば、戻り値は@code{t}である。
さもなければ（@var{props}が@code{nil}だったり、
テキスト内の値と同じ値であると）@code{nil}である。

@c For example, here is how to set the @code{comment} and @code{face}
@c properties of a range of text:
たとえば、テキストのある範囲の属性@code{comment}と@code{face}を
設定するにはつぎのようにする。

@example
(add-text-properties @var{start} @var{end}
                     '(comment t face highlight))
@end example
@end defun

@defun remove-text-properties start end props &optional object
@c This function deletes specified text properties from the text between
@c @var{start} and @var{end} in the string or buffer @var{object}.  If
@c @var{object} is @code{nil}, it defaults to the current buffer.
この関数は、文字列やバッファである@var{object}内の
@var{start}と@var{end}のあいだのテキストから
指定したテキスト属性を削除する。
@var{object}が@code{nil}であると、デフォルトはカレントバッファである。

@c The argument @var{props} specifies which properties to delete.  It
@c should have the form of a property list (@pxref{Property Lists}): a list
@c whose elements are property names alternating with corresponding values.
@c But only the names matter---the values that accompany them are ignored.
@c For example, here's how to remove the @code{face} property.
引数@var{props}で削除する属性を指定する。
これは属性リスト（@pxref{Property Lists}）の形であること。
つまり、属性名とその値を交互に並べたリストであること。
ただし、意味があるのは名前のみであり、その値は無視する。
たとえば、属性@code{face}を削除するにはつぎのようにする。

@example
(remove-text-properties @var{start} @var{end} '(face nil))
@end example

@c The return value is @code{t} if the function actually changed some
@c property's value; @code{nil} otherwise (if @var{props} is @code{nil} or
@c if no character in the specified text had any of those properties).
この関数が属性の値をどれか実際に変更したならば、戻り値は@code{t}である。
さもなければ（@var{props}が@code{nil}だったり、
指定したテキスト内の文字にそれらのいずれの属性もなければ）
@code{nil}である。

@c To remove all text properties from certain text, use
@c @code{set-text-properties} and specify @code{nil} for the new property
@c list.
特定のテキストからすべてのテキスト属性を削除するには、
新たな属性リストとして@code{nil}を指定して
@code{set-text-properties}を使う。
@end defun

@defun set-text-properties start end props &optional object
@c This function completely replaces the text property list for the text
@c between @var{start} and @var{end} in the string or buffer @var{object}.
@c If @var{object} is @code{nil}, it defaults to the current buffer.
この関数は、文字列やバッファである@var{object}内の
@var{start}と@var{end}のあいだのテキストのテキスト属性を完全に置き換える。
@var{object}が@code{nil}であると、
デフォルトはカレントバッファである。

@c The argument @var{props} is the new property list.  It should be a list
@c whose elements are property names alternating with corresponding values.
引数@var{props}は新たな属性リストである。
これは、属性名とその値を交互に並べたリストであること。

@c After @code{set-text-properties} returns, all the characters in the
@c specified range have identical properties.
@code{set-text-properties}から戻ると、
指定した範囲のすべての文字は同一の属性を持つことになる。

@c If @var{props} is @code{nil}, the effect is to get rid of all properties
@c from the specified range of text.  Here's an example:
@var{props}が@code{nil}であると、
テキストの指定した範囲からすべての属性を削除する効果がある。
たとえば、つぎのようにする。

@example
(set-text-properties @var{start} @var{end} nil)
@end example
@end defun

@c   See also the function @code{buffer-substring-no-properties}
@c (@pxref{Buffer Contents}) which copies text from the buffer
@c but does not copy its properties.
バッファからテキストをコピーするがその属性はコピーしない
関数@code{buffer-substring-no-properties}（@pxref{Buffer Contents}）も
参照してください。

@node Property Search
@c @subsection Text Property Search Functions
@subsection テキスト属性を探す関数

@c   In typical use of text properties, most of the time several or many
@c consecutive characters have the same value for a property.  Rather than
@c writing your programs to examine characters one by one, it is much
@c faster to process chunks of text that have the same property value.
テキスト属性の典型的な用途では、
ほとんどの場合多くの連続した文字の1つの属性には同じ値があります。
1つずつ文字を調べるようにプログラムするよりは、
同じ属性値を持つテキストの塊を処理するほうがとても速いです。

@c   Here are functions you can use to do this.  They use @code{eq} for
@c comparing property values.  In all cases, @var{object} defaults to the
@c current buffer.
このために使える関数をここで説明します。
これらは属性値の比較に@code{eq}を使います。
@var{object}のデフォルトは、すべての場合でカレントバッファです。

@c   For high performance, it's very important to use the @var{limit}
@c argument to these functions, especially the ones that search for a
@c single property---otherwise, they may spend a long time scanning to the
@c end of the buffer, if the property you are interested in does not change.
高い効率のためには、これらの関数に引数@var{limit}を使うことが重要であり、
1つの属性を探す関数には特にあてはまります。
さもないと、読者が望む属性が変更されないような場合、
それらの関数はバッファの末尾まで走査して長い時間を費すことになります。

@c   These functions do not move point; instead, they return a position (or
@c @code{nil}).  Remember that a position is always between two characters;
@c the position returned by these functions is between two characters with
@c different properties.
これらの関数はポイントを移動しませんが、そのかわりに
位置（あるいは@code{nil}）を返します。
位置はつねに2つの文字のあいだにあることに注意してください。
これらの関数が返す位置は、異なる属性を持つ2つの文字のあいだです。

@defun next-property-change pos &optional object limit
@c The function scans the text forward from position @var{pos} in the
@c string or buffer @var{object} till it finds a change in some text
@c property, then returns the position of the change.  In other words, it
@c returns the position of the first character beyond @var{pos} whose
@c properties are not identical to those of the character just after
@c @var{pos}.
この関数は、文字列やバッファである@var{object}内の位置@var{pos}から
テキスト属性のいずれかが異なるまでテキストを走査し、その変化する位置を返す。
いいかえれば、@var{pos}の直後の文字のテキスト属性とは異なる
属性を持つ@var{pos}のあとにある最初の文字の位置を返す。

@c If @var{limit} is non-@code{nil}, then the scan ends at position
@c @var{limit}.  If there is no property change before that point, 
@c @code{next-property-change} returns @var{limit}.
@var{limit}が@code{nil}以外であると、@var{limit}の位置で走査を終える。
その箇所まで異なる属性がないと、
@code{next-property-change}は@var{limit}を返す。

@c The value is @code{nil} if the properties remain unchanged all the way
@c to the end of @var{object} and @var{limit} is @code{nil}.  If the value
@c is non-@code{nil}, it is a position greater than or equal to @var{pos}.
@c The value equals @var{pos} only when @var{limit} equals @var{pos}.
@var{limit}が@code{nil}であり@var{object}の末尾まで属性に変化がないと、
値は@code{nil}である。
値が@code{nil}以外であると、それは@var{pos}より大きいか等しい位置である。
値が@var{pos}に等しいのは、@var{limit}が@var{pos}に等しい場合のみである。

@c Here is an example of how to scan the buffer by chunks of text within
@c which all properties are constant:
バッファからすべての属性が同じであるテキストの塊を
走査する方法の例をつぎに示す。

@smallexample
(while (not (eobp))
  (let ((plist (text-properties-at (point)))
        (next-change
         (or (next-property-change (point) (current-buffer))
             (point-max))))
@c     @r{Process text from point to @var{next-change}@dots{}}
    @r{ポイントから@var{next-change}までのテキストを処理する@dots{}}
    (goto-char next-change)))
@end smallexample
@end defun

@defun next-single-property-change pos prop &optional object limit
@c The function scans the text forward from position @var{pos} in the
@c string or buffer @var{object} till it finds a change in the @var{prop}
@c property, then returns the position of the change.  In other words, it
@c returns the position of the first character beyond @var{pos} whose
@c @var{prop} property differs from that of the character just after
@c @var{pos}.
この関数は、文字列やバッファである@var{object}内の位置@var{pos}から
属性@var{prop}が異なるまでテキストを走査し、その変化する位置を返す。
いいかえれば、@var{pos}の直後の文字の属性@var{prop}とは異なる
属性@var{prop}をもつ@var{pos}のあとにある最初の文字の位置を返す。

@c If @var{limit} is non-@code{nil}, then the scan ends at position
@c @var{limit}.  If there is no property change before that point, 
@c @code{next-single-property-change} returns @var{limit}.
@var{limit}が@code{nil}以外であると、@var{limit}の位置で走査を終える。
その箇所まで異なる属性がないと、
@code{next-single-property-change}は@var{limit}を返す。

@c The value is @code{nil} if the property remains unchanged all the way to
@c the end of @var{object} and @var{limit} is @code{nil}.  If the value is
@c non-@code{nil}, it is a position greater than or equal to @var{pos}; it
@c equals @var{pos} only if @var{limit} equals @var{pos}.
@var{limit}が@code{nil}であり@var{object}の末尾まで属性に変化がないと、
値は@code{nil}である。
値が@code{nil}以外であると、それは@var{pos}より大きいか等しい位置である。
値が@var{pos}に等しいのは、@var{limit}が@var{pos}に等しい場合のみである。
@end defun

@defun previous-property-change pos &optional object limit
@c This is like @code{next-property-change}, but scans back from @var{pos}
@c instead of forward.  If the value is non-@code{nil}, it is a position
@c less than or equal to @var{pos}; it equals @var{pos} only if @var{limit}
@c equals @var{pos}.
これは@code{next-property-change}と同様であるが、
前方へではなく@var{pos}から後方へ走査する。
値が@code{nil}以外であると、それは@var{pos}より小さいか等しい位置である。
値が@var{pos}に等しいのは、@var{limit}が@var{pos}に等しい場合のみである。
@end defun

@defun previous-single-property-change pos prop &optional object limit
@c This is like @code{next-single-property-change}, but scans back from
@c @var{pos} instead of forward.  If the value is non-@code{nil}, it is a
@c position less than or equal to @var{pos}; it equals @var{pos} only if
@c @var{limit} equals @var{pos}.
これは@code{next-single-property-change}と同様であるが、
前方へではなく@var{pos}から後方へ走査する。
値が@code{nil}以外であると、それは@var{pos}より小さいか等しい位置である。
値が@var{pos}に等しいのは、@var{limit}が@var{pos}に等しい場合のみである。
@end defun

@defun next-char-property-change position &optional limit
@tindex next-char-property-change
@c This is like @code{next-property-change} except that it considers
@c overlay properties as well as text properties.  There is no @var{object}
@c operand because this function operates only on the current buffer.  It
@c returns the next address at which either kind of property changes.
これは@code{next-property-change}と同様であるが、
テキスト属性に加えてオーバレイも対象にする。
この関数はカレントバッファにのみ作用するため、
@var{object}を表す引数はない。
どちらかの属性が異なるつぎの位置を返す。
@end defun

@defun previous-char-property-change position &optional limit
@tindex previous-char-property-change
@c This is like @code{next-char-property-change}, but scans back from
@c @var{position} instead of forward.
これは@code{next-char-property-change}と同様であるが、
前方へではなく@var{pos}から後方へ走査する。
@end defun

@defun text-property-any start end prop value &optional object
@c This function returns non-@code{nil} if at least one character between
@c @var{start} and @var{end} has a property @var{prop} whose value is
@c @var{value}.  More precisely, it returns the position of the first such
@c character.  Otherwise, it returns @code{nil}.
@var{start}と@var{end}のあいだに属性@var{prop}の値が@var{value}である
文字が1つでもあれば、この関数は@code{nil}以外を返す。
より正確には、そのような最初の文字の位置を返す。
さもなければ@code{nil}を返す。

@c The optional fifth argument, @var{object}, specifies the string or
@c buffer to scan.  Positions are relative to @var{object}.  The default
@c for @var{object} is the current buffer.
省略可能な5番目の引数@var{object}は、走査すべき文字列やバッファを指定する。
位置は@var{object}に相対である。
@var{object}のデフォルトはカレントバッファである。
@end defun

@defun text-property-not-all start end prop value &optional object
@c This function returns non-@code{nil} if at least one character between
@c @var{start} and @var{end} does not have a property @var{prop} with value
@c @var{value}.  More precisely, it returns the position of the first such
@c character.  Otherwise, it returns @code{nil}.
@var{start}と@var{end}のあいだに属性@var{prop}の値が@var{value}でない
文字が1つでもあれば、この関数は@code{nil}以外を返す。
より正確には、そのような最初の文字の位置を返す。
さもなければ@code{nil}を返す。

@c The optional fifth argument, @var{object}, specifies the string or
@c buffer to scan.  Positions are relative to @var{object}.  The default
@c for @var{object} is the current buffer.
省略可能な5番目の引数@var{object}は、走査すべき文字列やバッファを指定する。
位置は@var{object}に相対である。
@var{object}のデフォルトはカレントバッファである。
@end defun

@node Special Properties
@c @subsection Properties with Special Meanings
@subsection 特別な意味を持つ属性

@c   Here is a table of text property names that have special built-in
@c meanings.  The following sections list a few additional special property
@c names that control filling and property inheritance.  All other names
@c have no standard meaning, and you can use them as you like.
特別な組み込みの意味を持つテキスト属性名の一覧を以下に示します。
以降の節では、詰め込みや属性の継承を制御する特別な属性名も示します。
それ以外の名前には標準的な意味はないので、
読者はそれらを好きなように使ってかまいません。

@table @code
@c @cindex category of text character
@cindex テキスト文字のカテゴリ
@c @kindex category @r{(text property)}
@kindex category @r{（テキスト属性）}
@item category
@c If a character has a @code{category} property, we call it the
@c @dfn{category} of the character.  It should be a symbol.  The properties
@c of the symbol serve as defaults for the properties of the character.
文字に属性@code{category}があるとき、
これを文字の@dfn{カテゴリ}（category）と呼ぶ。
これはシンボルであること。
そのシンボルの属性が、文字の属性のデフォルトとして働く。

@item face
@c @cindex face codes of text
@cindex テキストのフェイスコード
@c @kindex face @r{(text property)}
@kindex face @r{（テキスト属性）}
@c You can use the property @code{face} to control the font and color of
@c text.  Its value is a face name or a list of face names.  @xref{Faces},
@c for more information.
テキストのフォントと表示色を制御するために属性@code{face}を使う。
その値はフェイス名かフェイス名のリストである。
詳しくは、@pxref{Faces}。

@c If the property value is a list, elements may also have the form
@c @code{(foreground-color . @var{color-name})} or @code{(background-color
@c . @var{color-name})}.  These elements specify just the foreground color
@c or just the background color; therefore, there is no need to create a
@c face for each color that you want to use.
属性値がリストであると、その要素は、
@code{(foreground-color . @var{color-name})}や
@code{(background-color . @var{color-name})}の形でもよい。
これらの要素は、前景色だけや背景色だけを指定する。
したがって、使用する各色を表すフェイスを作成する必要はない。

@c @xref{Font Lock Mode}, for information on how to update @code{face}
@c properties automatically based on the contents of the text.
テキストの内容に基づいて属性@code{face}を自動的に更新する方法に関しては、
@pxref{Font Lock Mode}。

@item mouse-face
@c @kindex mouse-face @r{(text property)}
@kindex mouse-face @r{（テキスト属性）}
@c The property @code{mouse-face} is used instead of @code{face} when the
@c mouse is on or near the character.  For this purpose, ``near'' means
@c that all text between the character and where the mouse is have the same
@c @code{mouse-face} property value.
マウスが文字の上やその近くにあると、属性@code{face}のかわりに
属性@code{mouse-face}が使われる。
この目的において『近く』とは、
文字とマウスの位置のあいだの
属性@code{mouse-face}の値が同じであるすべてのテキストである。

@item local-map
@c @cindex keymap of character
@cindex 文字のキーマップ
@cindex キーマップ、文字
@c @kindex local-map @r{(text property)}
@kindex local-map @r{（テキスト属性）}
@c You can specify a different keymap for some of the text in a buffer by
@c means of the @code{local-map} property.  The property's value for the
@c character after point, if non-@code{nil}, is used for key lookup instead
@c of the buffer's local map.  If the property value is a symbol, the
@c symbol's function definition is used as the keymap.  @xref{Active
@c Keymaps}.
属性@code{local-map}を用いることで、
バッファ内のテキストの一部分に対して別のキーマップを指定できる。
ポイントのうしろの文字のこの属性の値が@code{nil}以外であると、
バッファのローカルマップのかわりにその値をキー探索に使う。
属性値がシンボルであると、シンボルの関数定義をキーマップとして使う。
@pxref{Active Keymaps}。

@item syntax-table
@c The @code{syntax-table} property overrides what the syntax table says
@c about this particular character.  @xref{Syntax Properties}.
属性@code{syntax-table}は、構文テーブルがこの文字に指定するものに優先する。
@pxref{Syntax Properties}。

@item read-only
@c @cindex read-only character
@cindex 読み出し専用文字
@c @kindex read-only @r{(text property)}
@kindex read-only @r{（テキスト属性）}
@c If a character has the property @code{read-only}, then modifying that
@c character is not allowed.  Any command that would do so gets an error.
文字に属性@code{read-only}があると、その文字を変更できない。
変更するどのようなコマンドもエラーになる。

@c Insertion next to a read-only character is an error if inserting
@c ordinary text there would inherit the @code{read-only} property due to
@c stickiness.  Thus, you can control permission to insert next to
@c read-only text by controlling the stickiness.  @xref{Sticky Properties}.
挿入されるテキストがスティッキ性のために属性@code{read-only}を
継承する場合には、読み出し専用文字のつぎにテキストを挿入するとエラーになる。
したがって、スティッキ性を制御することで、
読み出し専用テキストのつぎへのテキスト挿入を許すかどうかを制御できる。
@pxref{Sticky Properties}。

@c Since changing properties counts as modifying the buffer, it is not
@c possible to remove a @code{read-only} property unless you know the
@c special trick: bind @code{inhibit-read-only} to a non-@code{nil} value
@c and then remove the property.  @xref{Read Only Buffers}.
属性を変更するとバッファを変更したとみなすため、
特別なトリックを知らない限り、属性を@code{read-only}を削除できない。
つまり、@code{inhibit-read-only}に@code{nil}以外の値を束縛して、
属性を削除する。
@pxref{Read Only Buffers}。

@item invisible
@c @kindex invisible @r{(text property)}
@kindex invisible @r{（テキスト属性）}
@c A non-@code{nil} @code{invisible} property can make a character invisible
@c on the screen.  @xref{Invisible Text}, for details.
属性@code{invisible}が@code{nil}以外であると、
その文字はスクリーンに表示されない。
詳しくは、@pxref{Invisible Text}。

@item intangible
@c @kindex intangible @r{(text property)}
@kindex intangible @r{（テキスト属性）}
@c If a group of consecutive characters have equal and non-@code{nil}
@c @code{intangible} properties, then you cannot place point between them.
@c If you try to move point forward into the group, point actually moves to
@c the end of the group.  If you try to move point backward into the group,
@c point actually moves to the start of the group.
連続する文字に属性@code{intangible}の@code{nil}でない同じ値があると、
それらのあいだにポイントを置けなくなる。
前方に向けてこれらの文字の中にポイントを移動しようとすると、
ポイントは実際にはそれらの末尾へ移動する。
後方に向けてこれらの文字の中にポイントを移動しようとすると、
ポイントは実際にはそれらの先頭へ移動する。

@c When the variable @code{inhibit-point-motion-hooks} is non-@code{nil},
@c the @code{intangible} property is ignored.
変数@code{inhibit-point-motion-hooks}が@code{nil}以外であると、
属性@code{intangible}は無視される。

@item modification-hooks
@c @cindex change hooks for a character
@c @cindex hooks for changing a character
@cindex 文字に対する変更フック
@cindex 文字変更に対するフック
@c @kindex modification-hooks @r{(text property)}
@kindex modification-hooks @r{（テキスト属性）}
@c If a character has the property @code{modification-hooks}, then its
@c value should be a list of functions; modifying that character calls all
@c of those functions.  Each function receives two arguments: the beginning
@c and end of the part of the buffer being modified.  Note that if a
@c particular modification hook function appears on several characters
@c being modified by a single primitive, you can't predict how many times
@c the function will be called.
文字に属性@code{modification-hooks}がある場合、それは関数のリストであること。
その文字の変更にはそれらの関数すべてが呼び出される。
各関数は2つの引数、つまり、バッファの変更対象部分の先頭と末尾を受け取る。
1つの操作で変更される一連の文字に同じ変更フック関数が現れる場合、
関数が実際に何回呼ばれるか予測できないことに注意してほしい。

@item insert-in-front-hooks
@itemx insert-behind-hooks
@c @kindex insert-in-front-hooks @r{(text property)}
@c @kindex insert-behind-hooks @r{(text property)}
@kindex insert-in-front-hooks @r{（テキスト属性）}
@kindex insert-behind-hooks @r{（テキスト属性）}
@c The operation of inserting text in a buffer also calls the functions
@c listed in the @code{insert-in-front-hooks} property of the following
@c character and in the @code{insert-behind-hooks} property of the
@c preceding character.  These functions receive two arguments, the
@c beginning and end of the inserted text.  The functions are called
@c @emph{after} the actual insertion takes place.
バッファにテキストを挿入する操作でも、
挿入箇所のうしろの文字の属性@code{insert-in-front-hooks}と
まえの文字の属性@code{insert-behind-hooks}に指定されている
関数群を呼び出す。
これらの関数は2つの引数、つまり、挿入されたテキストの先頭と末尾を受け取る。
これらの関数が呼ばれるのは、実際の挿入操作を@emph{終えてから}である。

@c See also @ref{Change Hooks}, for other hooks that are called
@c when you change text in a buffer.
バッファ内のテキストを変更するときに呼び出される他のフックについては、
@ref{Change Hooks}も参照。

@item point-entered
@itemx point-left
@c @cindex hooks for motion of point
@cindex ポイント移動に対するフック
@c @kindex point-entered @r{(text property)}
@c @kindex point-left @r{(text property)}
@kindex point-entered @r{（テキスト属性）}
@kindex point-left @r{（テキスト属性）}
@c The special properties @code{point-entered} and @code{point-left}
@c record hook functions that report motion of point.  Each time point
@c moves, Emacs compares these two property values:
特別な属性@code{point-entered}と@code{point-left}は、
ポイント移動を報告するフック関数を保持する。
ポイントが動くたびに、Emacsはこれらの2つの属性値、つまり、

@itemize @bullet
@item
@c the @code{point-left} property of the character after the old location,
@c and
移動前のポイントのうしろの文字の属性@code{point-left}と
@item
@c the @code{point-entered} property of the character after the new
@c location.
移動後のポイントのうしろの文字の属性@code{point-entered}
@end itemize

@noindent
@c If these two values differ, each of them is called (if not @code{nil})
@c with two arguments: the old value of point, and the new one.
を比較する。
これら2つの値が異なれば、
ポイントの古い値と新しい値の2つの引数で（@code{nil}でなければ）
それぞれを呼び出す。

@c The same comparison is made for the characters before the old and new
@c locations.  The result may be to execute two @code{point-left} functions
@c (which may be the same function) and/or two @code{point-entered}
@c functions (which may be the same function).  In any case, all the
@c @code{point-left} functions are called first, followed by all the
@c @code{point-entered} functions.
同じことを移動前後のポイントのまえの文字についても行う。
その結果、（同じかもしれない）@code{point-left}の関数を2回、かつ／あるいは、
（同じかもしれない）@code{point-entered}の関数を2回実行する。
いずれにしても、@code{point-left}の関数が最初に呼ばれ、
そのあとで@code{point-entered}の関数が呼ばれる。

@c It is possible using @code{char-after} to examine characters at various
@c positions without moving point to those positions.  Only an actual
@c change in the value of point runs these hook functions.
これらの関数では、@code{char-after}を使って
ポイントを移動せずにさまざまな箇所の文字を調べられる。
ポイントの値が実際に変わったときにのみ、これらのフック関数が実行される。
@end table

@defvar inhibit-point-motion-hooks
@c When this variable is non-@code{nil}, @code{point-left} and
@c @code{point-entered} hooks are not run, and the @code{intangible}
@c property has no effect.  Do not set this variable globally; bind it with
@c @code{let}.
この変数が@code{nil}以外であると、
@code{point-left}と@code{point-entered}のフック関数は実行されなくなり、
属性@code{intangible}の効果もなくなる。
この変数はグローバルに設定せずに、@code{let}で束縛すること。
@end defvar

@node Format Properties
@c @subsection Formatted Text Properties
@subsection 整形済みテキストの属性

@c   These text properties affect the behavior of the fill commands.  They
@c are used for representing formatted text.  @xref{Filling}, and
@c @ref{Margins}.
これらのテキスト属性は、詰め込みコマンドのふるまいに影響します。
これらは整形済みのテキストを表現するために使われます。
@ref{Filling}と@xref{Margins}。

@table @code
@item hard
@c If a newline character has this property, it is a ``hard'' newline.
@c The fill commands do not alter hard newlines and do not move words
@c across them.  However, this property takes effect only if the variable
@c @code{use-hard-newlines} is non-@code{nil}.
改行文字にこの属性があると、『ハード』改行である。
詰め込みコマンドは『ハード』改行を変更せず、
それらをまたがって単語を移動しない。
しかし、この属性は@code{use-hard-newlines}が
@code{nil}以外の場合にのみ効果を持つ。

@item right-margin
@c This property specifies an extra right margin for filling this part of the
@c text.
テキストのこの部分を詰め込むための余分な右端余白を指定する。

@item left-margin
@c This property specifies an extra left margin for filling this part of the
@c text.
テキストのこの部分を詰め込むための余分な左端余白を指定する。

@item justification
@c This property specifies the style of justification for filling this part
@c of the text.
テキストのこの部分を詰め込むための幅揃えスタイルを指定する。
@end table

@node Sticky Properties
@c @subsection Stickiness of Text Properties
@subsection テキスト属性のスティッキ性
@c @cindex sticky text properties
@c @cindex inheritance of text properties
@cindex スティッキテキスト属性
@cindex テキスト属性の継承

@c   Self-inserting characters normally take on the same properties as the
@c preceding character.  This is called @dfn{inheritance} of properties.
自己挿入文字は、通常、先行する文字と同じ属性を持ちます。
これを属性の@dfn{継承}（inheritance）と呼びます。

@c   In a Lisp program, you can do insertion with inheritance or without,
@c depending on your choice of insertion primitive.  The ordinary text
@c insertion functions such as @code{insert} do not inherit any properties.
@c They insert text with precisely the properties of the string being
@c inserted, and no others.  This is correct for programs that copy text
@c from one context to another---for example, into or out of the kill ring.
@c To insert with inheritance, use the special primitives described in this
@c section.  Self-inserting characters inherit properties because they work
@c using these primitives.
Lispプログラムでは、挿入基本関数を選べば、
継承して挿入したり継承せずに挿入できます。
@code{insert}などの普通のテキスト挿入関数は、
いかなる属性も継承しません。
これらは、挿入する文字列の属性をそのまま持ったテキストを挿入し、
それ以外の属性はありません。
キルリングなどのある文脈から別の文脈へテキストをコピーするプログラムには、
これは正しい動作です。
継承して挿入するには、本節で述べる特別な基本関数を使います。
自己挿入文字はこれらの基本関数を使っているので、属性を継承します。

@c   When you do insertion with inheritance, @emph{which} properties are
@c inherited depends on two specific properties: @code{front-sticky} and
@c @code{rear-nonsticky}.
継承して挿入するとき、@emph{どの}属性を継承するかは、
2つの特別な属性@code{front-sticky}と@code{rear-nonsticky}に依存します。

@c   Insertion after a character inherits those of its properties that are
@c @dfn{rear-sticky}.  Insertion before a character inherits those of its
@c properties that are @dfn{front-sticky}.  By default, a text property is
@c rear-sticky but not front-sticky.  Thus, the default is to inherit all
@c the properties of the preceding character, and nothing from the
@c following character.  You can request different behavior by specifying
@c the stickiness of certain properties.
文字のうしろに挿入すると、その文字の@dfn{後続スティッキ}（rear-sticky）
である属性を継承します。
文字のまえに挿入すると、その文字の@dfn{先行スティッキ}（front-sticky）
である属性を継承します。
デフォルトでは、テキスト属性は先行スティッキではなく後続スティッキです。
したがって、デフォルトでは、まえの文字のすべての属性を継承して、
うしろの文字からはなにも継承しません。
特定の属性のスティッキ性を指定することで、異なるふるまいを指定できます。

@c   If a character's @code{front-sticky} property is @code{t}, then all
@c its properties are front-sticky.  If the @code{front-sticky} property is
@c a list, then the sticky properties of the character are those whose
@c names are in the list.  For example, if a character has a
@c @code{front-sticky} property whose value is @code{(face read-only)},
@c then insertion before the character can inherit its @code{face} property
@c and its @code{read-only} property, but no others.
文字の属性@code{front-sticky}が@code{t}であると、
その文字のすべての属性は先行スティッキです。
属性@code{front-sticky}がリストであると、
リストに現れる名前のその文字の属性は先行スティッキです。
たとえば、文字の属性@code{front-sticky}の値が@code{(face read-only)}であると、
この文字のまえに挿入するとこの文字の属性@code{face}と@code{read-only}を
継承しますが、それ以外には継承しません。

@c   The @code{rear-nonsticky} works the opposite way.  Every property is
@c rear-sticky by default, so the @code{rear-nonsticky} property says which
@c properties are @emph{not} rear-sticky.  If a character's
@c @code{rear-nonsticky} property is @code{t}, then none of its properties
@c are rear-sticky.  If the @code{rear-nonsticky} property is a list,
@c properties are rear-sticky @emph{unless} their names are in the list.
@code{rear-nonsticky}は反対の働きをします。
すべての属性はデフォルトでは後続スティッキですから、
属性@code{rear-nonsticky}はどの属性が
後続スティッキで@emph{ない}かを指定します。
文字の属性@code{rear-nonsticky}が@code{t}であると、
その文字には後続スティッキである属性はありません。
属性@code{rear-nonsticky}がリストであると、
リストに名前が現れ@emph{ない限り}、
属性は後続スティッキです。

@c   When you insert text with inheritance, it inherits all the rear-sticky
@c properties of the preceding character, and all the front-sticky
@c properties of the following character.  The previous character's
@c properties take precedence when both sides offer different sticky values
@c for the same property.
継承するようにテキストを挿入すると、
まえの文字からは後続スティッキであるすべての属性を継承し、
うしろの文字からは先行スティッキであるすべての属性を継承します。
両側の文字に異なるスティッキ性の同じ属性がある場合には、
まえの文字の属性が優先します。

@c   Here are the functions that insert text with inheritance of properties:
属性を継承してテキストを挿入する関数はつぎのとおりです。

@defun insert-and-inherit &rest strings
@c Insert the strings @var{strings}, just like the function @code{insert},
@c but inherit any sticky properties from the adjoining text.
関数@code{insert}と同様に文字列@var{strings}を挿入するが、
前後のテキストから任意のスティッキ性の属性を継承する。
@end defun

@defun insert-before-markers-and-inherit &rest strings
@c Insert the strings @var{strings}, just like the function
@c @code{insert-before-markers}, but inherit any sticky properties from the
@c adjoining text.
関数@code{insert-before-markers}と同様に文字列@var{strings}を挿入するが、
前後のテキストから任意のスティッキ性の属性を継承する。
@end defun

@c   @xref{Insertion}, for the ordinary insertion functions which do not
@c inherit.
継承しない普通の挿入関数については、@xref{Insertion}。

@node Saving Properties
@c @subsection Saving Text Properties in Files
@subsection テキスト属性をファイルへ保存する
@c @cindex text properties in files
@c @cindex saving text properties
@cindex ファイル内のテキスト属性
@cindex テキスト属性、ファイル内
@cindex テキスト属性の保存
@cindex 保存、テキスト属性

@c   You can save text properties in files (along with the text itself),
@c and restore the same text properties when visiting or inserting the
@c files, using these two hooks:
つぎの2つのフックを使って、
テキスト属性を（テキストそのものとともに）ファイルに保存しておき、
ファイルを訪問したり挿入するときに同じテキスト属性を復元できます。

@defvar write-region-annotate-functions
@c This variable's value is a list of functions for @code{write-region} to
@c run to encode text properties in some fashion as annotations to the text
@c being written in the file.  @xref{Writing to Files}.
この変数の値は、ファイルへ書き込むテキストに対する注記の形で
テキスト属性を符号化するために@code{write-region}が呼び出す関数の
リストである。
@pxref{Writing to Files}。

@c Each function in the list is called with two arguments: the start and
@c end of the region to be written.  These functions should not alter the
@c contents of the buffer.  Instead, they should return lists indicating
@c annotations to write in the file in addition to the text in the
@c buffer.
リスト内の各関数は2つの引数、つまり、
書き込む領域の先頭と末尾で呼び出される。
これらの関数はバッファの内容を変更しないこと。
そのかわりに、バッファのテキストに加えてファイルに書き込むべき
注記を表すリストを返すべきである。

@c Each function should return a list of elements of the form
@c @code{(@var{position} . @var{string})}, where @var{position} is an
@c integer specifying the relative position within the text to be written,
@c and @var{string} is the annotation to add there.
各関数は、@code{(@var{position} . @var{string})}の形の要素から成る
リストを返すべきである。
ここで、@var{position}は書き込まれるテキスト内の相対位置を指定する整数、
@var{string}はそこへ追加する注記である。

@c Each list returned by one of these functions must be already sorted in
@c increasing order by @var{position}.  If there is more than one function,
@c @code{write-region} merges the lists destructively into one sorted list.
これらの関数が返す各リストは、@var{position}の昇順になっている必要がある。
複数の関数があると、@code{write-region}は
リストを破壊的に併合して1つのソートしたリストにする。

@c When @code{write-region} actually writes the text from the buffer to the
@c file, it intermixes the specified annotations at the corresponding
@c positions.  All this takes place without modifying the buffer.
@code{write-region}がバッファからファイルにテキストを実際に書くときに、
指定された注記を対応する位置に混在させる。
バッファを変更せずにこれらすべてを行う。
@end defvar

@defvar after-insert-file-functions
@c This variable holds a list of functions for @code{insert-file-contents}
@c to call after inserting a file's contents.  These functions should scan
@c the inserted text for annotations, and convert them to the text
@c properties they stand for.
この変数は、@code{insert-file-contents}がファイルの内容を挿入してから
呼び出す関数のリストを保持する。
これらの関数は挿入されたテキストで注記を走査し、
それらが表すテキスト属性にそれらを変換する。

@c Each function receives one argument, the length of the inserted text;
@c point indicates the start of that text.  The function should scan that
@c text for annotations, delete them, and create the text properties that
@c the annotations specify.  The function should return the updated length
@c of the inserted text, as it stands after those changes.  The value
@c returned by one function becomes the argument to the next function.
各関数は1つの引数、つまり、挿入されたテキストの長さで呼ばれ、
ポイントは挿入されたテキストの先頭を表す。
関数は当該テキストで注記を走査して注記を削除し、
注記が指定するテキスト属性を作成する。
関数は、変更を反映した挿入されたテキストの更新された長さを返すこと。
関数が返した値がつぎの関数の引数になる。

@c These functions should always return with point at the beginning of
@c the inserted text.
これらの関数は、挿入されたテキストの先頭にポイントをつねに戻すこと。

@c The intended use of @code{after-insert-file-functions} is for converting
@c some sort of textual annotations into actual text properties.  But other
@c uses may be possible.
@code{after-insert-file-functions}の意図された用途は、
テキスト表現の注記を実際のテキスト属性に変換することである。
しかし、別の使い方も可能である。
@end defvar

@c We invite users to write Lisp programs to store and retrieve text
@c properties in files, using these hooks, and thus to experiment with
@c various data formats and find good ones.  Eventually we hope users 
@c will produce good, general extensions we can install in Emacs.
これらのフックを使ってファイルにテキスト属性を保存したり復元する
Lispプログラムを書いて、さまざまなデータ書式を試して
よいものをみつけるようにお願いします。
最終的には、Emacsに取り込める良質で汎用の拡張を
ユーザーが作り出すことを願っています。

@c We suggest not trying to handle arbitrary Lisp objects as text property
@c names or values---because a program that general is probably difficult
@c to write, and slow.  Instead, choose a set of possible data types that
@c are reasonably flexible, and not too hard to encode.
テキスト属性の名前や値として任意のLispオブジェクトを
処理しないように忠告しておきます。
そのような汎用のプログラムは書くのが難しく動作が遅くなりがちです。
そのかわりに、適当に柔軟性があり符号化が難しくないデータ型の集合を選びます。

@c @xref{Format Conversion}, for a related feature.
関連する機能については、@xref{Format Conversion}。

@c ??? In next edition, merge this info Format Conversion.

@node Lazy Properties
@c @subsection Lazy Computation of Text Properties
@subsection テキスト属性の遅延計算

@c   Instead of computing text properties for all the text in the buffer,
@c you can arrange to compute the text properties for parts of the text
@c when and if something depends on them.
バッファ内のすべてのテキストのテキスト属性を計算するかわりに、
必要になった時点でテキストの一部分のテキスト属性を計算するようにできます。

@c   The primitive that extracts text from the buffer along with its
@c properties is @code{buffer-substring}.  Before examining the properties,
@c this function runs the abnormal hook @code{buffer-access-fontify-functions}.
バッファからテキスト属性とともにテキストを取り出す基本関数は、
@code{buffer-substring}です。
属性を調べるまえに、この関数はアブノーマルフック
@code{buffer-access-fontify-functions}を実行します。

@defvar buffer-access-fontify-functions
@c This variable holds a list of functions for computing text properties.
@c Before @code{buffer-substring} copies the text and text properties for a
@c portion of the buffer, it calls all the functions in this list.  Each of
@c the functions receives two arguments that specify the range of the
@c buffer being accessed.  (The buffer itself is always the current
@c buffer.)
この変数は、テキスト属性を計算する関数のリストを保持する。
@code{buffer-substring}がバッファの一部分からテキストとテキスト属性を
コピーするまえに、この関数はこのリスト内の関数すべてを呼び出す。
各関数は、バッファの参照される範囲を指定する2つの引数を受け取る。
（バッファはつねにカレントバッファである。）
@end defvar

@c   The function @code{buffer-substring-no-properties} does not call these
@c functions, since it ignores text properties anyway.
関数@code{buffer-substring-no-properties}は
テキスト属性を無視するので、これらの関数を呼び出しません。

@c   In order to prevent the hook functions from being called more than
@c once for the same part of the buffer, you can use the variable
@c @code{buffer-access-fontified-property}.
バッファの同じ部分に対してフック関数が複数回呼び出されるのを防ぐには、
変数@code{buffer-access-fontified-property}を使います。

@defvar buffer-access-fontified-property
@c If this value's variable is non-@code{nil}, it is a symbol which is used
@c as a text property name.  A non-@code{nil} value for that text property
@c means, ``the other text properties for this character have already been
@c computed.''
この変数の値が@code{nil}以外であると、
それはテキスト属性の名前として使われるシンボルである。
そのテキスト属性に対する@code{nil}以外の値は、
『この文字の他のテキスト属性はすでに計算済みである』ことを意味する。

@c If all the characters in the range specified for @code{buffer-substring}
@c have a non-@code{nil} value for this property, @code{buffer-substring}
@c does not call the @code{buffer-access-fontify-functions} functions.  It
@c assumes these characters already have the right text properties, and
@c just copies the properties they already have.
@code{buffer-substring}に指定された範囲のすべての文字において、
この属性に対して@code{nil}以外の値があると、
@code{buffer-substring}は
@code{buffer-access-fontify-functions}の関数を呼び出さない。
それらの文字にはすでに正しいテキスト属性があるとみなし、
それらにすでにある属性をコピーする。

@c The normal way to use this feature is that the
@c @code{buffer-access-fontify-functions} functions add this property, as
@c well as others, to the characters they operate on.  That way, they avoid
@c being called over and over for the same text.
この機能を使う普通の方法は、
@code{buffer-access-fontify-functions}の関数が
他の属性ととともにこの属性をそれらが操作した文字に追加する。
そうすれば、同じテキストに対して何回も呼び出されるのを防ぐことができる。
@end defvar

@node Clickable Text
@c @subsection Defining Clickable Text
@subsection クリック可能なテキストを定義する
@c @cindex clickable text
@cindex クリック可能なテキスト

@c   There are two ways to set up @dfn{clickable text} in a buffer.
@c There are typically two parts of this: to make the text highlight
@c when the mouse is over it, and to make a mouse button do something
@c when you click it on that part of the text.
バッファ内に@dfn{クリック可能なテキスト}（clickable text）を設定するには
2つの方法があります。
これは典型的には2つの部分から成ります。
つまり、マウスが重なるとテキストを強調表示し、
テキストのその部分をクリックすると
マウスボタンがなんらかの処理を行うようにします。

@c   Highlighting is done with the @code{mouse-face} text property.
@c Here is an example of how Dired does it:
強調表示はテキスト属性@code{mouse-face}で行います。
diredでの方法を例として示します。

@smallexample
(condition-case nil
    (if (dired-move-to-filename)
        (put-text-property (point)
                           (save-excursion
                             (dired-move-to-end-of-filename)
                             (point))
                           'mouse-face 'highlight))
  (error nil))
@end smallexample

@noindent
@c The first two arguments to @code{put-text-property} specify the
@c beginning and end of the text.
@code{put-text-property}の最初の2つの引数は、
テキストの先頭と末尾を指定します。

@c   The usual way to make the mouse do something when you click it
@c on this text is to define @code{mouse-2} in the major mode's
@c keymap.  The job of checking whether the click was on clickable text
@c is done by the command definition.  Here is how Dired does it:
このテキストをクリックしたときにマウスになにかをさせるようにする
普通の方法は、メジャーモードのキーマップで@code{mouse-2}を定義することです。
クリック可能なテキストをクリックしたかどうかの検査は、
コマンド定義で行われます。
diredではつぎのようにしています。

@smallexample
(defun dired-mouse-find-file-other-window (event)
  "In dired, visit the file or directory name you click on."
  (interactive "e")
  (let (file)
    (save-excursion
      (set-buffer (window-buffer (posn-window (event-end event))))
      (save-excursion
        (goto-char (posn-point (event-end event)))
        (setq file (dired-get-filename))))
    (select-window (posn-window (event-end event)))
    (find-file-other-window (file-name-sans-versions file t))))
@end smallexample

@noindent
@c The reason for the outer @code{save-excursion} construct is to avoid
@c changing the current buffer; the reason for the inner one is to avoid
@c permanently altering point in the buffer you click on.  In this case,
@c Dired uses the function @code{dired-get-filename} to determine which
@c file to visit, based on the position found in the event.
外側の@code{save-excursion}は、カレントバッファが変わることを防ぎます。
内側のは、クリックしたバッファのポイントを恒久的に変更することを防ぎます。
この例では、diredは関数@code{dired-get-filename}を用いて、
イベントの位置に基づいて訪問すべきファイルを決定します。

@c   Instead of defining a mouse command for the major mode, you can define
@c a key binding for the clickable text itself, using the @code{local-map}
@c text property:
メジャーモードのマウスコマンドを定義するかわりに、
テキスト属性@code{local-map}を使って、
クリック可能なテキストそのものにキーバインディングを定義することもできます。

@example
(let ((map (make-sparse-keymap)))
  (define-key-binding map [mouse-2] 'operate-this-button)
  (put-text-property (point)
                     (save-excursion
                       (dired-move-to-end-of-filename)
                       (point))
                     'local-map map))
@end example

@noindent
@c This method makes it possible to define different commands for various
@c clickable pieces of text.  Also, the major mode definition (or the
@c global definition) remains available for the rest of the text in the
@c buffer.
この方法では、テキストのさまざまなクリック可能な部分に
異なるコマンドを定義できます。
さらに、バッファの残りの部分に対しては、
メジャーモードの定義（やグローバルな定義）がそのまま有効です。

@node Not Intervals
@c @subsection Why Text Properties are not Intervals
@subsection テキスト属性が範囲でない理由
@c @cindex intervals
@cindex 範囲

@c   Some editors that support adding attributes to text in the buffer do
@c so by letting the user specify ``intervals'' within the text, and adding
@c the properties to the intervals.  Those editors permit the user or the
@c programmer to determine where individual intervals start and end.  We
@c deliberately provided a different sort of interface in Emacs Lisp to
@c avoid certain paradoxical behavior associated with text modification.
バッファ内のテキストに属性を付加できるエディタのなかには、
ユーザーにテキスト内の『範囲』を指定させ、
その範囲に属性を付加するものがあります。
このようなエディタでは、ユーザーやプログラマが
個々の範囲の先頭と末尾を決定できます。
テキスト変更に伴うある種の矛盾するようなふるまいを避けるために、
熟考の結果Emacs Lispでは別の種類のインターフェイスを提供することにしました。

@c   If the actual subdivision into intervals is meaningful, that means you
@c can distinguish between a buffer that is just one interval with a
@c certain property, and a buffer containing the same text subdivided into
@c two intervals, both of which have that property.
複数の範囲に細分することが意味を持つならば、
ある属性の1つの範囲があるだけのバッファと、
その同じテキストをその同じ属性の2つの範囲にしてあるバッファとを
区別できるはずです。

@c   Suppose you take the buffer with just one interval and kill part of
@c the text.  The text remaining in the buffer is one interval, and the
@c copy in the kill ring (and the undo list) becomes a separate interval.
@c Then if you yank back the killed text, you get two intervals with the
@c same properties.  Thus, editing does not preserve the distinction
@c between one interval and two.
1つの範囲だけを持つバッファにおいて、そのテキストの一部をキルしたとします。
バッファに残っているテキストは1つの範囲であり、
キルリング（とアンドゥリスト）内のコピーは1つの別の範囲になります。
そしてキルされたテキストをヤンクして戻すと、
同じ属性を持つ2つの範囲ができます。
つまり、編集すると、1つの範囲と2つの範囲の区別を保存できなくなります。

@c   Suppose we ``fix'' this problem by coalescing the two intervals when
@c the text is inserted.  That works fine if the buffer originally was a
@c single interval.  But suppose instead that we have two adjacent
@c intervals with the same properties, and we kill the text of one interval
@c and yank it back.  The same interval-coalescence feature that rescues
@c the other case causes trouble in this one: after yanking, we have just
@c one interval.  One again, editing does not preserve the distinction
@c between one interval and two.
テキストを挿入すると2つの範囲を融合することで
この問題を『修正』したとします。
バッファにもともと1つの範囲しかなければ、うまくいきます。
しかし、同じ属性の範囲が連続して2つある場合に、
一方の範囲をキルしてからヤンクして戻したとします。
別の場面では救いになる同じ属性の範囲を融合する機能が、
ここではトラブルを引き起こします。
つまり、ヤンクすると1つの範囲になってしまいます。
ここでも、編集すると、1つの範囲と2つの範囲の区別を保存できなくなります。

@c   Insertion of text at the border between intervals also raises
@c questions that have no satisfactory answer.
2つの範囲の境界にテキストを挿入する場合でも、
満足できる解決方法がない問題を提起します。

@c   However, it is easy to arrange for editing to behave consistently for
@c questions of the form, ``What are the properties of this character?''
@c So we have decided these are the only questions that make sense; we have
@c not implemented asking questions about where intervals start or end.
しかし、『この文字の属性はなにか』といった形の問いに対して
一貫したふるまいをするような編集にするのは簡単です。
そのために、これらが唯一の意味ある問いかけであると判断したのです。
範囲の先頭と末尾を問うようなものは実装してありません。

@c   In practice, you can usually use the text property search functions in
@c place of explicit interval boundaries.  You can think of them as finding
@c the boundaries of intervals, assuming that intervals are always
@c coalesced whenever possible.  @xref{Property Search}.
実用上は、明示的な範囲の境界のかわりに、
テキスト属性を探索する関数を普通は使えます。
それらの関数は、可能な場合にはつねに範囲は融合されると仮定して
範囲の境界を探すと考えることができます。
@xref{Property Search}。

@c   Emacs also provides explicit intervals as a presentation feature; see
@c @ref{Overlays}.
Emacsには表示機能として明示的な範囲もあります。
@ref{Overlays}を参照してください。

@node Substitution
@c @section Substituting for a Character Code
@section 文字コードの置換

@c   The following functions replace characters within a specified region
@c based on their character codes.
つぎの関数は、指定した領域内の文字をそれらの文字コードに基づいて置き換えます。

@defun subst-char-in-region start end old-char new-char &optional noundo
@c @cindex replace characters
@cindex 文字の置換
@cindex 置換、文字
@c This function replaces all occurrences of the character @var{old-char}
@c with the character @var{new-char} in the region of the current buffer
@c defined by @var{start} and @var{end}.
この関数は、カレントバッファの@var{start}と@var{end}で定義される領域の
すべての文字@var{old-char}を文字@var{new-char}に置き換える。

@c @cindex Outline mode
@c @cindex undo avoidance
@cindex アウトライン（outline）モード
@cindex アンドゥの抑制
@c If @var{noundo} is non-@code{nil}, then @code{subst-char-in-region} does
@c not record the change for undo and does not mark the buffer as modified.
@c This feature is used for controlling selective display (@pxref{Selective
@c Display}).
@var{noundo}が@code{nil}以外であると、
@code{subst-char-in-region}はアンドゥ用の変更を記録せず、
バッファに変更済みの印も付けない。
この機能は、選択表示（@pxref{Selective Display}）の制御に使われている。

@c @code{subst-char-in-region} does not move point and returns
@c @code{nil}.
@code{subst-char-in-region}はポイントを移動せず、
@code{nil}を返す。

@example
@group
---------- Buffer: foo ----------
This is the contents of the buffer before.
---------- Buffer: foo ----------
@end group

@group
(subst-char-in-region 1 20 ?i ?X)
     @result{} nil

---------- Buffer: foo ----------
ThXs Xs the contents of the buffer before.
---------- Buffer: foo ----------
@end group
@end example
@end defun

@defun translate-region start end table
@c This function applies a translation table to the characters in the
@c buffer between positions @var{start} and @var{end}.
この関数は、バッファの@var{start}と@var{end}のあいだの文字に変換表を適用する。

@c The translation table @var{table} is a string; @code{(aref @var{table}
@c @var{ochar})} gives the translated character corresponding to
@c @var{ochar}.  If the length of @var{table} is less than 256, any
@c characters with codes larger than the length of @var{table} are not
@c altered by the translation.
変換表@var{table}は文字列であり、
@code{(aref @var{table} @var{ochar})}は、
@var{ochar}に対応する変換した文字を与える。
@var{table}の長さが256未満であると、
@var{table}の長さより大きなコードの文字は変換によっては変更されない。

@c The return value of @code{translate-region} is the number of
@c characters that were actually changed by the translation.  This does
@c not count characters that were mapped into themselves in the
@c translation table.
@code{translate-region}の戻り値は、
変換によって実際に変更した文字の個数を返す。
これには、変換表で自分自身に変換された文字は数えない。
@end defun

@node Registers
@c @section Registers
@section レジスタ
@c @cindex registers
@cindex レジスタ

@c   A register is a sort of variable used in Emacs editing that can hold a
@c variety of different kinds of values.  Each register is named by a
@c single character.  All ASCII characters and their meta variants (but
@c with the exception of @kbd{C-g}) can be used to name registers.  Thus,
@c there are 255 possible registers.  A register is designated in Emacs
@c Lisp by the character that is its name.
レジスタは、Emacsの編集においてさまざまな種類の値を保持できる変数の一種です。
各レジスタには1文字の名前が付いています。
すべてのASCII文字とそれらのメタ変種（ただし@kbd{C-g}を除く）を
レジスタの名前に使えます。
したがって、255個のレジスタを使えます。
Emacs Lispでは、レジスタ名でレジスタを区別します。

@defvar register-alist
@c This variable is an alist of elements of the form @code{(@var{name} .
@c @var{contents})}.  Normally, there is one element for each Emacs
@c register that has been used.
この変数は、@code{(@var{name} . @var{contents})}の形の要素の連想リストである。
通常、使用中のEmacsの各レジスタに対して1つの要素がある。

@c The object @var{name} is a character (an integer) identifying the
@c register.
オブジェクト@var{name}は、レジスタを識別する文字（整数）である。
@end defvar

@c   The @var{contents} of a register can have several possible types:
レジスタの内容（@var{contents}）に可能な型はいくつかあります。

@table @asis
@c @item a number
@item 数
@c A number stands for itself.  If @code{insert-register} finds a number
@c in the register, it converts the number to decimal.
数そのものを表す。
@code{insert-register}がレジスタ内で数をみつけると10進数に変換する。

@c @item a marker
@item マーカ
@c A marker represents a buffer position to jump to.
マーカはジャンプ先のバッファ内位置を表す。

@c @item a string
@item 文字列
@c A string is text saved in the register.
文字列はレジスタに保存されたテキストである。

@c @item a rectangle
@item 矩形領域
@c A rectangle is represented by a list of strings.
矩形領域は文字列のリストで表現される。

@item @code{(@var{window-configuration} @var{position})}
@c This represents a window configuration to restore in one frame, and a
@c position to jump to in the current buffer.
これは、1つのフレームに復元するウィンドウ構成と
カレントバッファでのポイントの移動先を表す。

@item @code{(@var{frame-configuration} @var{position})}
@c This represents a frame configuration to restore, and a position
@c to jump to in the current buffer.
これは、復元するフレーム構成とカレントバッファでのポイントの移動先を表す。

@item (file @var{filename})
@c This represents a file to visit; jumping to this value visits file
@c @var{filename}.
訪問すべきファイルを表す。
この値にジャンプするとファイル@var{filename}を訪問する。

@item (file-query @var{filename} @var{position})
@c This represents a file to visit and a position in it; jumping to this
@c value visits file @var{filename} and goes to buffer position
@c @var{position}.  Restoring this type of position asks the user for
@c confirmation first.
これは、訪問すべきファイルとその中での位置を表す。
この値にジャンプするとファイル@var{filename}を訪問し
バッファ内位置@var{position}へ移動する。
この種の位置を復元すると、まずユーザーに確認を取る。
@end table

@c   The functions in this section return unpredictable values unless
@c otherwise stated.
本節の関数は、明記してない場合には予測できない値を返します。

@defun get-register reg
@c This function returns the contents of the register
@c @var{reg}, or @code{nil} if it has no contents.
この関数は、レジスタ@var{reg}の内容、
あるいは、内容がなければ@code{nil}を返す。
@end defun

@defun set-register reg value
@c This function sets the contents of register @var{reg} to @var{value}.
@c A register can be set to any value, but the other register functions
@c expect only certain data types.  The return value is @var{value}.
この関数は、レジスタ@var{reg}の内容を@var{value}とする。
レジスタには任意の値を設定できるが、他のレジスタ関数は
特定のデータ型を期待する。
戻り値は@var{value}である。
@end defun

@c @deffn Command view-register reg
@deffn コマンド view-register reg
@c This command displays what is contained in register @var{reg}.
このコマンドは、レジスタ@var{reg}になにが入っているかを表示する。
@end deffn

@ignore
@deffn Command point-to-register reg
This command stores both the current location of point and the current
buffer in register @var{reg} as a marker.
@end deffn

@deffn Command jump-to-register reg
@deffnx Command register-to-point reg
@comment !!SourceFile register.el
This command restores the status recorded in register @var{reg}.

If @var{reg} contains a marker, it moves point to the position stored in
the marker.  Since both the buffer and the location within the buffer
are stored by the @code{point-to-register} function, this command can
switch you to another buffer.

If @var{reg} contains a window configuration or a frame configuration.
@code{jump-to-register} restores that configuration.
@end deffn
@end ignore

@c @deffn Command insert-register reg &optional beforep
@deffn コマンド insert-register reg &optional beforep
@c This command inserts contents of register @var{reg} into the current
@c buffer.
このコマンドはレジスタ@var{reg}の内容をカレントバッファに挿入する。

@c Normally, this command puts point before the inserted text, and the
@c mark after it.  However, if the optional second argument @var{beforep}
@c is non-@code{nil}, it puts the mark before and point after.
@c You can pass a non-@code{nil} second argument @var{beforep} to this
@c function interactively by supplying any prefix argument.
通常、このコマンドは挿入したテキストのまえにポイントを置き、
そのあとにマークを置く。
しかし、省略可能な2番目の引数@var{beforep}が@code{nil}以外であると、
まえにマークを置きあとにポイントを置く。
この関数を対話的に呼び出すときに前置引数を指定すれば、
2番目の引数@var{beforep}に@code{nil}以外を渡せる。

@c If the register contains a rectangle, then the rectangle is inserted
@c with its upper left corner at point.  This means that text is inserted
@c in the current line and underneath it on successive lines.
レジスタに矩形領域が含まれる場合、
ポイント位置に矩形領域の左上隅がくるように挿入される。
つまり、テキストは現在行とそのしたの連続する行に挿入される。

@c If the register contains something other than saved text (a string) or
@c a rectangle (a list), currently useless things happen.  This may be
@c changed in the future.
保存したテキスト（文字列）や矩形領域（リスト）以外がレジスタに入っていると、
現状では有用なことは起こらない。
将来これは変更されるであろう。
@end deffn

@ignore
@deffn Command copy-to-register reg start end &optional delete-flag
This command copies the region from @var{start} to @var{end} into
register @var{reg}.  If @var{delete-flag} is non-@code{nil}, it deletes
the region from the buffer after copying it into the register.
@end deffn

@deffn Command prepend-to-register reg start end &optional delete-flag
This command prepends the region from @var{start} to @var{end} into
register @var{reg}.  If @var{delete-flag} is non-@code{nil}, it deletes
the region from the buffer after copying it to the register.
@end deffn

@deffn Command append-to-register reg start end &optional delete-flag
This command appends the region from @var{start} to @var{end} to the
text already in register @var{reg}.  If @var{delete-flag} is
non-@code{nil}, it deletes the region from the buffer after copying it
to the register.
@end deffn

@deffn Command copy-rectangle-to-register reg start end &optional delete-flag
This command copies a rectangular region from @var{start} to @var{end}
into register @var{reg}.  If @var{delete-flag} is non-@code{nil}, it
deletes the region from the buffer after copying it to the register.
@end deffn

@deffn Command window-configuration-to-register reg
This function stores the window configuration of the selected frame in
register @var{reg}.
@end deffn

@deffn Command frame-configuration-to-register reg
This function stores the current frame configuration in register
@var{reg}.
@end deffn
@end ignore

@node Transposition
@c @section Transposition of Text
@section テキストの転置

@c   This subroutine is used by the transposition commands.
つぎのサブルーティンは転置コマンドで使われます。

@defun transpose-regions start1 end1 start2 end2 &optional leave-markers
@c This function exchanges two nonoverlapping portions of the buffer.
@c Arguments @var{start1} and @var{end1} specify the bounds of one portion
@c and arguments @var{start2} and @var{end2} specify the bounds of the
@c other portion.
この関数は、バッファの重なり合わない2つの部分を入れ換える。
引数@var{start1}と@var{end1}で一方の部分の境界を指定し、
引数@var{start2}と@var{end2}で他方の部分の境界を指定する。

@c Normally, @code{transpose-regions} relocates markers with the transposed
@c text; a marker previously positioned within one of the two transposed
@c portions moves along with that portion, thus remaining between the same
@c two characters in their new position.  However, if @var{leave-markers}
@c is non-@code{nil}, @code{transpose-regions} does not do this---it leaves
@c all markers unrelocated.
通常、@code{transpose-regions}は転置したテキスト内のマーカを再配置する。
つまり、2つの転置部分の一方の内側を指していたマーカは
その部分とともに移動して、新しい位置で同じ2つの文字のあいだに留まる。
しかし、@var{leave-markers}が@code{nil}以外であると、
@code{transpose-regions}はこれを行わず、
すべてのマーカは再配置されない。
@end defun

@node Change Hooks
@c @section Change Hooks
@section 変更フック
@c @cindex change hooks
@c @cindex hooks for text changes
@cindex 変更フック
@cindex テキスト変更向けのフック

@c   These hook variables let you arrange to take notice of all changes in
@c all buffers (or in a particular buffer, if you make them buffer-local).
@c See also @ref{Special Properties}, for how to detect changes to specific
@c parts of the text.
これらのフックにより、すべてのバッファ
（それらをバッファローカルにしておけば特定のバッファ）における
すべての変更を知るようにできます。
テキストの特定部分の変更を検出する方法については、
@ref{Special Properties}も参照してください。

@c   The functions you use in these hooks should save and restore the match
@c data if they do anything that uses regular expressions; otherwise, they
@c will interfere in bizarre ways with the editing operations that call
@c them.
これらのフックに使う関数において正規表現を使う場合には、
マッチデータを保存し復元する必要があります。
さもないと、それらを呼び出す編集操作と奇妙な干渉を引き起こします。

@defvar before-change-functions
@c This variable holds a list of functions to call before any buffer
@c modification.  Each function gets two arguments, the beginning and end
@c of the region that is about to change, represented as integers.  The
@c buffer that is about to change is always the current buffer.
この変数は、バッファを変更するまえに呼び出すべき関数のリストを保持する。
各関数は2つの引数、つまり、整数で表した変更対象の領域の先頭と末尾を受け取る。
変更対象のバッファはつねにカレントバッファである。
@end defvar

@defvar after-change-functions
@c This variable holds a list of functions to call after any buffer
@c modification.  Each function receives three arguments: the beginning and
@c end of the region just changed, and the length of the text that existed
@c before the change.  All three arguments are integers.  The buffer that's
@c about to change is always the current buffer.
この変数は、バッファを変更したあとに呼び出すべき関数のリストを保持する。
各関数は3つの引数、つまり、変更されたばかりの領域の先頭と末尾、
変更前に存在していたテキストの長さを受け取る。
3つの引数はすべて整数である。
変更対象のバッファはつねにカレントバッファである。

@c The length of the old text is the difference between the buffer positions
@c before and after that text as it was before the change.  As for the
@c changed text, its length is simply the difference between the first two
@c arguments.
古いテキストの長さは、変更前のそのテキストの先頭と末尾の
バッファ内位置の差である。
変更済みのテキストの長さは、単純に始めの2つの引数の差である。
@end defvar

@defmac combine-after-change-calls body...
@tindex combine-after-change-calls
@c The macro executes @var{body} normally, but arranges to call the
@c after-change functions just once for a series of several changes---if
@c that seems safe.
このマクロは通常どおり@var{body}を実行するが、
一連の変更に対して安全と思えるときには、
@code{after-change-functions}の関数を一度だけ呼び出す。

@c If a program makes several text changes in the same area of the buffer,
@c using the macro @code{combine-after-change-calls} around that part of
@c the program can make it run considerably faster when after-change hooks
@c are in use.  When the after-change hooks are ultimately called, the
@c arguments specify a portion of the buffer including all of the changes
@c made within the @code{combine-after-change-calls} body.
プログラムからバッファの同じ部分でテキスト変更を複数回行う場合、
プログラムの当該部分の周りでマクロ@code{combine-after-change-calls}を使うと、
フック@code{after-change-functions}を使用してるときには
動作がかなり速くなりうる。
最終的にフック@code{after-change-functions}が呼ばれると、
@code{combine-after-change-calls}の本体で行った変更すべてを含むような
バッファ部分が引数に指定される。

@c @strong{Warning:} You must not alter the values of
@c @code{after-change-functions} and @code{after-change-function} within
@c the body of a @code{combine-after-change-calls} form.
@strong{警告：}@code{ }
フォーム@code{combine-after-change-calls}の本体の内側では
@code{after-change-functions}と@code{after-change-function}の値を
変更しないこと。

@c @strong{Note:} If the changes you combine occur in widely scattered
@c parts of the buffer, this will still work, but it is not advisable,
@c because it may lead to inefficient behavior for some change hook
@c functions.
@strong{注意：}@code{ }
変更がバッファの広く分散した部分に行われるときにもこれは動作するが、
推奨できない。
非効率なふるまいをするようなフック関数があるからである。
@end defmac

@defvar before-change-function
@c This obsolete variable holds one function to call before any buffer
@c modification (or @code{nil} for no function).  It is called just like
@c the functions in @code{before-change-functions}.
この廃れた変数は、任意のバッファの変更を行うまえに
呼ばれる1つの関数を保持する
（@code{nil}ならばそのような関数はなし）。
@code{before-change-functions}の関数と同様に呼ばれる。
@end defvar

@defvar after-change-function
@c This obsolete variable holds one function to call after any buffer modification
@c (or @code{nil} for no function).  It is called just like the functions in
@c @code{after-change-functions}.
この廃れた変数は、任意のバッファの変更を行ったあとに
呼ばれる1つの関数を保持する
（@code{nil}ならばそのような関数はなし）。
@code{after-change-functions}の関数と同様に呼ばれる。
@end defvar

@c The four variables above are temporarily bound to @code{nil} during the
@c time that any of these functions is running.  This means that if one of
@c these functions changes the buffer, that change won't run these
@c functions.  If you do want a hook function to make changes that run
@c these functions, make it bind these variables back to their usual
@c values.
上の4つの変数は、これらの関数が実行中には一時的に@code{nil}に束縛されます。
つまり、これらの関数の1つがバッファを変更しても、
その変更ではこれらの関数を呼び出しません。
フック関数においてこれらの関数を実行するような変更を行いたい場合には、
フック関数でこれらの変数をそれらの通常の値に束縛し直します。

@c One inconvenient result of this protective feature is that you cannot
@c have a function in @code{after-change-functions} or
@c @code{before-change-functions} which changes the value of that variable.
@c But that's not a real limitation.  If you want those functions to change
@c the list of functions to run, simply add one fixed function to the hook,
@c and code that function to look in another variable for other functions
@c to call.  Here is an example:
この保護的な機構の1つの不便な帰結は、
@code{after-change-functions}や@code{before-change-functions}には、
その変数の値を変更する関数を持てないことです。
しかし、これは本当の制限ではありません。
それらの関数で実行すべき関数のリストを変更したければ、
単純に1つの定まった関数をフックに追加し、
その関数では呼び出すべき別の関数を指定する別の変数を調べます。
つぎのようにします。

@example
(setq my-own-after-change-functions nil)
(defun indirect-after-change-function (beg end len)
  (let ((list my-own-after-change-functions))
    (while list
      (funcall (car list) beg end len)
      (setq list (cdr list)))))

@group
(add-hooks 'after-change-functions
           'indirect-after-change-function)
@end group
@end example

@defvar first-change-hook
@c This variable is a normal hook that is run whenever a buffer is changed
@c that was previously in the unmodified state.
この変数は、未変更状態のバッファを変更するたびに実行される
ノーマルフックである。
@end defvar
