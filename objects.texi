@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1998 Free Software Foundation, Inc. 
@c See the file elisp.texi for copying conditions.
@setfilename ../info/objects
@node Lisp Data Types, Numbers, Introduction, Top
@c @chapter Lisp Data Types
@chapter Lispのデータ型
@c @cindex object
@c @cindex Lisp object
@c @cindex type
@c @cindex data type
@cindex オブジェクト
@cindex Lispオブジェクト
@cindex 型
@cindex データ型

@c   A Lisp @dfn{object} is a piece of data used and manipulated by Lisp
@c programs.  For our purposes, a @dfn{type} or @dfn{data type} is a set of
@c possible objects.
Lisp@dfn{オブジェクト}（object）とは、
Lispプログラムが使用し操作するデータのことです。
@dfn{型}（type）や@dfn{データ型}（data type）とは、ここでは、
可能なオブジェクトの集合を意味します。

@c   Every object belongs to at least one type.  Objects of the same type
@c have similar structures and may usually be used in the same contexts.
@c Types can overlap, and objects can belong to two or more types.
@c Consequently, we can ask whether an object belongs to a particular type,
@c but not for ``the'' type of an object.
各オブジェクトは、少なくとも、1つの型に属します。
同じ型のオブジェクトは、構造に類似性があり、普通、同じ文脈で使われます。
型は互いに重複していてもよく、オブジェクトは複数の型に属することができます。
そのため、オブジェクトが特定の型に属するかどうかは判断できますが、
オブジェクトの型を『1つ』に限定することはできません。

@c @cindex primitive type
@cindex 基本型
@c   A few fundamental object types are built into Emacs.  These, from
@c which all other types are constructed, are called @dfn{primitive
@c types}.  Each object belongs to one and only one primitive type.  These
@c types include @dfn{integer}, @dfn{float}, @dfn{cons}, @dfn{symbol},
@c @dfn{string}, @dfn{vector}, @dfn{subr}, @dfn{byte-code function}, plus
@c several special types, such as @dfn{buffer}, that are related to
@c editing.  (@xref{Editing Types}.)
Emacsには少数の基本オブジェクト型を組み込んであります。
これらの型は他のすべてのオブジェクト型を構成するもとであり、
@dfn{基本型}（primitive types）と呼びます。
各オブジェクトはたった1つの基本型に属します。
基本型には、
@dfn{整数}（integer）、@dfn{浮動小数点数}（float）、
@dfn{コンス}（cons）、@dfn{シンボル}（symbol）、
@dfn{文字列}（string）、@dfn{ベクトル}（vector）、@dfn{subr}、
@dfn{バイトコード関数}（byte-code function）、
ならびに、編集に関連する@dfn{バッファ}（buffer）などの
特別な型があります。
（@pxref{Editing Types}。）

@c   Each primitive type has a corresponding Lisp function that checks
@c whether an object is a member of that type.
各基本型には、その型に属するオブジェクトであるかどうかを検査する
対応するLisp関数があります。

@c   Note that Lisp is unlike many other languages in that Lisp objects are
@c @dfn{self-typing}: the primitive type of the object is implicit in the
@c object itself.  For example, if an object is a vector, nothing can treat
@c it as a number; Lisp knows it is a vector, not a number.
Lispオブジェクトは@dfn{型を自己記述}（self-typing）するという点で、
Lispは他の多くの言語とは異なります。
つまり、オブジェクトの基本型は、オブジェクト自体に暗に含まれています。
たとえば、オブジェクトがベクトルであれば、それを数と扱うことはありません。
Lispには、ベクトルは数ではないとわかっているのです。

@c   In most languages, the programmer must declare the data type of each
@c variable, and the type is known by the compiler but not represented in
@c the data.  Such type declarations do not exist in Emacs Lisp.  A Lisp
@c variable can have any type of value, and it remembers whatever value
@c you store in it, type and all.
多くの言語では、プログラマは各変数のデータ型を宣言する必要があります。
型はコンパイラが知っているのであって、データの中には入っていません。
このような型宣言はEmacs Lispには存在しません。
Lisp変数はどんな型の値でも保持でき、
変数に入れた値と型を記録しています。

@c   This chapter describes the purpose, printed representation, and read
@c syntax of each of the standard types in GNU Emacs Lisp.  Details on how
@c to use these types can be found in later chapters.
本章では、GNU Emacs Lispの各標準型の表示表現と入力構文を説明します。
これらの型の使用方法の詳細は、あとの章に譲ります。

@menu
* Printed Representation::      How Lisp objects are represented as text.
* Comments::                    Comments and their formatting conventions.
* Programming Types::           Types found in all Lisp systems.
* Editing Types::               Types specific to Emacs.
* Type Predicates::             Tests related to types.
* Equality Predicates::         Tests of equality between any two objects.
@end menu

@node Printed Representation
@comment  node-name,  next,  previous,  up
@c @section Printed Representation and Read Syntax
@section 表示表現と入力構文
@c @cindex printed representation
@c @cindex read syntax
@cindex 表示表現
@cindex 入力構文

@c   The @dfn{printed representation} of an object is the format of the
@c output generated by the Lisp printer (the function @code{prin1}) for
@c that object.  The @dfn{read syntax} of an object is the format of the
@c input accepted by the Lisp reader (the function @code{read}) for that
@c object.  @xref{Read and Print}.
オブジェクトの@dfn{表示表現}（printed representation）とは、
Lispプリンタ（関数@code{prin1}）がそのオブジェクトを出力表示するときの
書式です。
オブジェクトの@dfn{入力構文}（read syntax）とは、
Lispリーダ（関数@code{read}）がそのオブジェクトを入力として受理する書式です。
@xref{Read and Print}。

@c   Most objects have more than one possible read syntax.  Some types of
@c object have no read syntax, since it may not make sense to enter objects
@c of these types directly in a Lisp program.  Except for these cases, the
@c printed representation of an object is also a read syntax for it.
ほとんどのオブジェクトには1つ以上の可能な入力構文があります。
ある種の型のオブジェクトには入力構文はありませんが、
そのような型のオブジェクトをLispプログラムに直接入力する意味がないからです。
このような場合を除くと、
オブジェクトの表示表現はそのオブジェクトの入力構文でもあります。

@c   In other languages, an expression is text; it has no other form.  In
@c Lisp, an expression is primarily a Lisp object and only secondarily the
@c text that is the object's read syntax.  Often there is no need to
@c emphasize this distinction, but you must keep it in the back of your
@c mind, or you will occasionally be very confused.
他の言語では、式はテキストであって、これ以外の形はありません。
Lispでは、式はとにかくLispオブジェクトであって、
オブジェクトの入力構文であるテキストは副次的なものです。
この違いを強調する必要はありませんが、
このことを心に留めておかないと混乱することがあります。

@c @cindex hash notation
@cindex ハッシュ記法
@c   Every type has a printed representation.  Some types have no read
@c syntax---for example, the buffer type has none.  Objects of these types
@c are printed in @dfn{hash notation}: the characters @samp{#<} followed by
@c a descriptive string (typically the type name followed by the name of
@c the object), and closed with a matching @samp{>}.  Hash notation cannot
@c be read at all, so the Lisp reader signals the error
@c @code{invalid-read-syntax} whenever it encounters @samp{#<}.
各型には表示表現があります。
入力構文のない型もあります。
たとえば、バッファ型には入力構文はありません。
このような型のオブジェクトは@dfn{ハッシュ記法}（hash notation）で表示します。
つまり、文字列@samp{#<}のあとに説明用の文字列
（典型的には型名にオブジェクトの名前を続けたもの）を続け、
対応する@samp{>}で閉じます。
ハッシュ記法を読み取ることはできませんから、
Lispリーダが@samp{#<}に出会うとエラー@code{invalid-read-syntax}を
通知します。
@kindex invalid-read-syntax

@example
(current-buffer)
     @result{} #<buffer objects.texi>
@end example

@c   When you evaluate an expression interactively, the Lisp interpreter
@c first reads the textual representation of it, producing a Lisp object,
@c and then evaluates that object (@pxref{Evaluation}).  However,
@c evaluation and reading are separate activities.  Reading returns the
@c Lisp object represented by the text that is read; the object may or may
@c not be evaluated later.  @xref{Input Functions}, for a description of
@c @code{read}, the basic function for reading objects.
読者が対話的に式を評価するとき、
Lispインタープリタは、まず、
式のテキスト表現を読み取ってLispオブジェクトを生成し、
そのオブジェクトを評価します（@pxref{Evaluation}）。
しかしながら、評価と読み取りは別々の動作です。
読み取りでは、読み取ったテキストが表すLispオブジェクトを返します。
このオブジェクトを、のちに評価する場合もありますが、
評価しない場合もあります。
オブジェクトを読み取る基本関数@code{read}については、
@xref{Input Functions}。

@node Comments
@comment  node-name,  next,  previous,  up
@c @section Comments
@section コメント
@c @cindex comments
@c @cindex @samp{;} in comment
@cindex コメント
@cindex @samp{;}、コメント内

@c   A @dfn{comment} is text that is written in a program only for the sake
@c of humans that read the program, and that has no effect on the meaning
@c of the program.  In Lisp, a semicolon (@samp{;}) starts a comment if it
@c is not within a string or character constant.  The comment continues to
@c the end of line.  The Lisp reader discards comments; they do not become
@c part of the Lisp objects which represent the program within the Lisp
@c system.
@dfn{コメント}（comment）は、プログラム内に書かれたテキストであり、
プログラムを読む人間のためだけにあり、
プログラムの意味にはまったく影響しません。
Lispでは、文字列や文字定数の外にあるセミコロン（@samp{;}）で
コメントを始めます。
コメントは行末までです。
Lispリーダは、コメントを破棄します。
コメントは、
Lispシステム内部でプログラムを表すLispオブジェクトの一部にはなりません。

@c   The @samp{#@@@var{count}} construct, which skips the next @var{count}
@c characters, is useful for program-generated comments containing binary
@c data.  The Emacs Lisp byte compiler uses this in its output files
@c (@pxref{Byte Compilation}).  It isn't meant for source files, however.
@samp{#@@@var{count}}という書き方は、
後続の@var{count}個の文字を飛び越します。
これは、プログラムで生成したバイナリデータを含むコメントに便利です。
Emacs Lispのバイトコンパイラは、出力ファイルにこのようなコメントを使います
（@pxref{Byte Compilation}）。
しかしながら、ソースファイル向きではありません。

@c   @xref{Comment Tips}, for conventions for formatting comments.
コメントの体裁に関する慣習については、@xref{Comment Tips}。

@node Programming Types
@c @section Programming Types
@section プログラミング向けの型
@c @cindex programming types
@cindex プログラミング向けの型
@cindex 型、プログラミング向け

@c   There are two general categories of types in Emacs Lisp: those having
@c to do with Lisp programming, and those having to do with editing.  The
@c former exist in many Lisp implementations, in one form or another.  The
@c latter are unique to Emacs Lisp.
Emacs Lispには、大きく2種類の型があります。
Lispのプログラミングに関わるものと、編集に関わるものです。
前者は、さまざまな形でLispの多くの実装に見られます。
後者は、Emacs Lispに固有です。

@menu
* Integer Type::        Numbers without fractional parts.
* Floating Point Type:: Numbers with fractional parts and with a large range.
* Character Type::      The representation of letters, numbers and
                        control characters.
* Symbol Type::         A multi-use object that refers to a function,
                        variable, or property list, and has a unique identity.
* Sequence Type::       Both lists and arrays are classified as sequences.
* Cons Cell Type::      Cons cells, and lists (which are made from cons cells).
* Array Type::          Arrays include strings and vectors.
* String Type::         An (efficient) array of characters.
* Vector Type::         One-dimensional arrays.
* Char-Table Type::     One-dimensional sparse arrays indexed by characters.
* Bool-Vector Type::    One-dimensional arrays of @code{t} or @code{nil}.
* Function Type::       A piece of executable code you can call from elsewhere.
* Macro Type::          A method of expanding an expression into another
                          expression, more fundamental but less pretty.
* Primitive Function Type::     A function written in C, callable from Lisp.
* Byte-Code Type::      A function written in Lisp, then compiled.
* Autoload Type::       A type used for automatically loading seldom-used
                        functions.
@end menu

@node Integer Type
@c @subsection Integer Type
@subsection 整数型

@c   The range of values for integers in Emacs Lisp is @minus{}134217728 to
@c 134217727 (28 bits; i.e.,
Emacs Lispにおける整数の値の範囲は、ほとんどの計算機では、
@minus{}134217728から134217727（28ビット長。つまり
@ifinfo
-2**27
@end ifinfo
@tex
$-2^{27}$
@end tex
@c to
から
@ifinfo
@c 2**27 - 1)
2**27 - 1）
@end ifinfo
@tex
%c $2^{28}-1$)
$2^{27}-1$）%c 誤植？
@end tex
@c on most machines.  (Some machines may provide a wider range.)  It is
@c important to note that the Emacs Lisp arithmetic functions do not check
@c for overflow.  Thus @code{(1+ 134217727)} is @minus{}134217728 on most
@c machines.
です。
（計算機によっては、より広い範囲になる。）
Emacs Lispの算術演算関数は、桁溢れ（オーバフロー）を
検査しないことを覚えておいてください。
したがって、ほとんどの計算機では、
@code{(1+ 134217727)}は@minus{}134217728となります。

@c   The read syntax for integers is a sequence of (base ten) digits with an
@c optional sign at the beginning and an optional period at the end.  The
@c printed representation produced by the Lisp interpreter never has a
@c leading @samp{+} or a final @samp{.}.
整数の入力構文は、（10を基数とした）数字の並びであり、
先頭に符号があってもよく、また、最後にピリオドがあってもかまいません。
Lispインタープリタが生成する表示表現では、
先頭の@samp{+}や最後の@samp{.}はありません。

@example
@group
@c -1               ; @r{The integer -1.}
@c 1                ; @r{The integer 1.}
@c 1.               ; @r{Also The integer 1.}
@c +1               ; @r{Also the integer 1.}
@c 268435457        ; @r{Also the integer 1 on a 28-bit implementation.}
-1               ; @r{整数 -1}
1                ; @r{整数 1}
1.               ; @r{これも整数 1}
+1               ; @r{これも整数 1}
268435457        ; @r{28ビット長整数では、これも整数 1}
@end group
@end example

@c   @xref{Numbers}, for more information.
より詳しくは、@xref{Numbers}。

@node Floating Point Type
@c @subsection Floating Point Type
@subsection 浮動小数点数

@c   Emacs supports floating point numbers (though there is a compilation
@c option to disable them).  The precise range of floating point numbers is
@c machine-specific.
Emacsは浮動小数点数を扱えます
（ただし、コンパイル時のオプションで使用不可にできる）。
浮動小数点数の範囲は、計算機に依存します。

@c   The printed representation for floating point numbers requires either
@c a decimal point (with at least one digit following), an exponent, or
@c both.  For example, @samp{1500.0}, @samp{15e2}, @samp{15.0e2},
@c @samp{1.5e3}, and @samp{.15e4} are five ways of writing a floating point
@c number whose value is 1500.  They are all equivalent.
浮動小数点数の表示表現には、
小数点（に続けて1桁以上の小数部分）または指数、
あるいは、その両方が必要です。
たとえば、@samp{1500.0}、@samp{15e2}、@samp{15.0e2}、
@samp{1.5e3}、@samp{.15e4}は、同じ1500という値の
浮動小数点数を書く5つの方法です。
どれも、まったく等価です。

@c   @xref{Numbers}, for more information.
詳しくは、@xref{Numbers}。

@node Character Type
@c @subsection Character Type
@subsection 文字型
@c @cindex @sc{ASCII} character codes
@cindex @sc{ASCII}文字コード

@c   A @dfn{character} in Emacs Lisp is nothing more than an integer.  In
@c other words, characters are represented by their character codes.  For
@c example, the character @kbd{A} is represented as the @w{integer 65}.
Emacs Lispにおける@dfn{文字}（character）は、
整数以外の何物でもありません。
いいかえれば、文字はその文字コードで表現されます。
たとえば、文字@kbd{A}は@w{整数 65}と表現されます。

@c   Individual characters are not often used in programs.  It is far more
@c common to work with @emph{strings}, which are sequences composed of
@c characters.  @xref{String Type}.
プログラムで個々の文字を独立に使うことはあまりありません。
文字を並べた@emph{文字列}（strings）として扱うことが断然多いのです。
@xref{String Type}。

@c   Characters in strings, buffers, and files are currently limited to the
@c range of 0 to 524287---nineteen bits.  But not all values in that range
@c are valid character codes.  Codes 0 through 127 are ASCII codes; the
@c rest are non-ASCII (@pxref{Non-ASCII Characters}).  Characters that represent
@c keyboard input have a much wider range, to encode modifier keys such as
@c Control, Meta and Shift.
文字列内、バッファ内、ファイル内の文字は、
現時点では、0から524287までの範囲、19ビット長に制限されます。
しかし、この範囲の値すべてが正しい文字コードではありません。
0から127までのコードはASCIIコードです。
それ以外は、非ASCIIです（@pxref{Non-ASCII Characters}）。
キーボード入力を表す文字は、コントロール、メタ、シフトなどの
修飾キーを符号化するために、範囲がより広くなります。

@c @cindex read syntax for characters
@c @cindex printed representation for characters
@c @cindex syntax for characters
@cindex 文字の入力構文
@cindex 入力構文、文字
@cindex 文字の表示表現
@cindex 表示表現、文字
@cindex 文字の構文
@c   Since characters are really integers, the printed representation of a
@c character is a decimal number.  This is also a possible read syntax for
@c a character, but writing characters that way in Lisp programs is a very
@c bad idea.  You should @emph{always} use the special read syntax formats
@c that Emacs Lisp provides for characters.  These syntax formats start
@c with a question mark.
文字は、実際には整数ですから、文字の表示表現は10進数です。
また、文字の入力構文として10進数も可能ですが、
Lispプログラムでこのように文字を書くのは最悪です。
Emacs Lispに用意してある文字向けの特別な入力構文を
@emph{つねに}使うべきです。
これらの構文は疑問符で始まります。

@c   The usual read syntax for alphanumeric characters is a question mark
@c followed by the character; thus, @samp{?A} for the character
@c @kbd{A}, @samp{?B} for the character @kbd{B}, and @samp{?a} for the
@c character @kbd{a}.  
英数字向けの普通の入力構文は、疑問符に続けて1つの英数字を書きます。
したがって、文字@kbd{A}は@samp{?A}、文字@kbd{B}は@samp{?B}、
文字@kbd{a}は@samp{?a}と書きます。

@c   For example:
たとえば、つぎのとおりです。

@example
?Q @result{} 81     ?q @result{} 113
@end example

@c   You can use the same syntax for punctuation characters, but it is
@c often a good idea to add a @samp{\} so that the Emacs commands for
@c editing Lisp code don't get confused.  For example, @samp{?\ } is the
@c way to write the space character.  If the character is @samp{\}, you
@c @emph{must} use a second @samp{\} to quote it: @samp{?\\}.
同じ入力構文を句読点文字にも使えますが、
@samp{\}を追加して、Lispコードを編集するEmacsコマンドが混乱しないように
することがよいでしょう。
たとえば、空白文字は@samp{?\ }と書きます。
文字@samp{\}は、クォートするために2つめの@samp{\}を使う@emph{必要があり}
@samp{?\\}です。

@c @cindex whitespace
@c @cindex bell character
@cindex 白文字
@cindex ベル文字
@cindex @samp{\a}
@c @cindex backspace
@cindex バックスペース
@cindex @samp{\b}
@c @cindex tab
@cindex タブ
@cindex @samp{\t}
@c @cindex vertical tab
@cindex 垂直タブ
@cindex @samp{\v}
@c @cindex formfeed
@cindex ページ送り
@cindex @samp{\f}
@c @cindex newline
@cindex 改行
@cindex @samp{\n}
@c @cindex return
@cindex 復帰
@cindex @samp{\r}
@c @cindex escape
@cindex エスケープ
@cindex @samp{\e}
@c   You can express the characters Control-g, backspace, tab, newline,
@c vertical tab, formfeed, return, and escape as @samp{?\a}, @samp{?\b},
@c @samp{?\t}, @samp{?\n}, @samp{?\v}, @samp{?\f}, @samp{?\r}, @samp{?\e},
@c respectively.  Thus,
コントロールg、バックスペース、タブ、改行、
垂直タブ、ページ送り、復帰、エスケープは、
それぞれ、@samp{?\a}、@samp{?\b}、@samp{?\t}、@samp{?\n}、@samp{?\v}、
@samp{?\f}、@samp{?\r}、@samp{?\e}と書きます。
つまり、つぎのとおりです。

@example
?\a @result{} 7                 ; @r{@kbd{C-g}}
@c ?\b @result{} 8                 ; @r{backspace, @key{BS}, @kbd{C-h}}
@c ?\t @result{} 9                 ; @r{tab, @key{TAB}, @kbd{C-i}}
@c ?\n @result{} 10                ; @r{newline, @kbd{C-j}}
@c ?\v @result{} 11                ; @r{vertical tab, @kbd{C-k}}
@c ?\f @result{} 12                ; @r{formfeed character, @kbd{C-l}}
@c ?\r @result{} 13                ; @r{carriage return, @key{RET}, @kbd{C-m}}
@c ?\e @result{} 27                ; @r{escape character, @key{ESC}, @kbd{C-[}}
@c ?\\ @result{} 92                ; @r{backslash character, @kbd{\}}
?\b @result{} 8                 ; @r{バックスペース、 @key{BS}、@kbd{C-h}}
?\t @result{} 9                 ; @r{タブ、 @key{TAB}、@kbd{C-i}}
?\n @result{} 10                ; @r{改行、@kbd{C-j}}
?\v @result{} 11                ; @r{垂直タブ、@kbd{C-k}}
?\f @result{} 12                ; @r{ページ送り文字、@kbd{C-l}}
?\r @result{} 13                ; @r{復帰、@key{RET}, @kbd{C-m}}
?\e @result{} 27                ; @r{エスケープ文字、@key{ESC}、@kbd{C-[}}
?\\ @result{} 92                ; @r{バックスラッシュ文字、@kbd{\}}
@end example

@c @cindex escape sequence
@cindex エスケープシーケンス
@c   These sequences which start with backslash are also known as
@c @dfn{escape sequences}, because backslash plays the role of an escape
@c character; this usage has nothing to do with the character @key{ESC}.
バックスラッシュで始まる系列は
@dfn{エスケープシーケンス}（escape sequences）とも呼びます。
バックスラッシュが、エスケープ文字の役割を果たすからです。
この使い方は、文字@key{ESC}とは関係ありません。

@c @cindex control characters
@cindex コントロール文字
@c   Control characters may be represented using yet another read syntax.
@c This consists of a question mark followed by a backslash, caret, and the
@c corresponding non-control character, in either upper or lower case.  For
@c example, both @samp{?\^I} and @samp{?\^i} are valid read syntax for the
@c character @kbd{C-i}, the character whose value is 9.
コントロール文字は別の入力構文でも表現できます。
疑問符に続けてバックスラッシュ、カレット（@samp{^}）、そして、
対応するコントロールでない文字を大文字か小文字で書きます。
たとえば、@samp{?\^I}も@samp{?\^i}も、
値が9である文字@kbd{C-i}の正しい入力構文です。

@c   Instead of the @samp{^}, you can use @samp{C-}; thus, @samp{?\C-i} is
@c equivalent to @samp{?\^I} and to @samp{?\^i}:
カレットのかわりに、@samp{C-}を使ってもかまいません。
ですから、@samp{?\C-i}は、@samp{?\^I}や@samp{?\^i}と等価です。

@example
?\^I @result{} 9     ?\C-I @result{} 9
@end example

@c   In strings and buffers, the only control characters allowed are those
@c that exist in @sc{ASCII}; but for keyboard input purposes, you can turn
@c any character into a control character with @samp{C-}.  The character
@c codes for these non-@sc{ASCII} control characters include the
文字列やバッファ内では@sc{ASCII}のコントロール文字だけが許されますが、
キーボード入力においては@samp{C-}で任意の文字をコントロール文字にできます。
これらの非@sc{ASCII}コントロール文字の文字コードは、
対応する非コントロール文字の文字コードと
@tex
$2^{26}$
@end tex
@ifinfo
2**26
@end ifinfo
@c bit as well as the code for the corresponding non-control
@c character.  Ordinary terminals have no way of generating non-@sc{ASCII}
@c control characters, but you can generate them straightforwardly using X
@c and other window systems.
のビットを含みます。
普通の端末では、非@sc{ASCII}コントロール文字を生成する手立てはありませんが、
Xウィンドウシステムや他のウィンドウシステムでは、
簡単に生成できます。

@c   For historical reasons, Emacs treats the @key{DEL} character as
@c the control equivalent of @kbd{?}:
歴史的な理由で、
Emacsは@key{DEL}文字を@kbd{?}に対応したコントロール文字として扱います。

@example
?\^? @result{} 127     ?\C-? @result{} 127
@end example

@noindent
@c As a result, it is currently not possible to represent the character
@c @kbd{Control-?}, which is a meaningful input character under X, using
@c @samp{\C-}.  It is not easy to change this, as various Lisp files refer
@c to @key{DEL} in this way.
その結果、今のところ、
Xウィンドウシステムのもとでは意味のある文字@kbd{Control-?}を
@samp{\C-}では表現できません。

@c   For representing control characters to be found in files or strings,
@c we recommend the @samp{^} syntax; for control characters in keyboard
@c input, we prefer the @samp{C-} syntax.  Which one you use does not
@c affect the meaning of the program, but may guide the understanding of
@c people who read it.
ファイルや文字列に現れるコントロール文字を表現するには、
@samp{^}構文を勧めます。
キーボード入力のコントロール文字には、@samp{C-}構文が好ましいです。
どちらを使ってもプログラムの意味には影響しませんが、
それを読む人には理解の手助けになるかもしれません。

@c @cindex meta characters
@cindex メタ文字
@c   A @dfn{meta character} is a character typed with the @key{META}
@c modifier key.  The integer that represents such a character has the
@dfn{メタ文字}（meta character）は、
@key{META}修飾キーを使って打った文字です。
そのような文字を表す整数は、（ほとんどの計算機では負の数になる）
@tex
$2^{27}$
@end tex
@ifinfo
2**27
@end ifinfo
@c bit set (which on most machines makes it a negative number).  We
@c use high bits for this and other modifiers to make possible a wide range
@c of basic character codes.
のビットがセットされています。
上位のビットをメタや他の修飾子に用いることで、
基本となる文字コードの範囲をできるだけ大きくします。

@c   In a string, the
文字列では、メタ文字を表すASCII文字には
@tex
$2^{7}$
@end tex
@ifinfo
2**7
@end ifinfo
@c bit attached to an ASCII character indicates a meta character; thus, the
@c meta characters that can fit in a string have codes in the range from
@c 128 to 255, and are the meta versions of the ordinary @sc{ASCII}
@c characters.  (In Emacs versions 18 and older, this convention was used
@c for characters outside of strings as well.)
のビットを付加します。
つまり、文字列に収められるメタ文字のコードは128から255の範囲であり、
任意の@sc{ASCII}文字のメタ変種を使えます。
（Emacs 18やそれ以前では、この方式を文字列の外にある文字にも使っていた。）

@c   The read syntax for meta characters uses @samp{\M-}.  For example,
@c @samp{?\M-A} stands for @kbd{M-A}.  You can use @samp{\M-} together with
@c octal character codes (see below), with @samp{\C-}, or with any other
@c syntax for a character.  Thus, you can write @kbd{M-A} as @samp{?\M-A},
@c or as @samp{?\M-\101}.  Likewise, you can write @kbd{C-M-b} as
@c @samp{?\M-\C-b}, @samp{?\C-\M-b}, or @samp{?\M-\002}.
メタ文字の入力構文には@samp{\M-}を使います。
たとえば、@samp{?\M-A}は@kbd{M-A}です。
@samp{\M-}と一緒に8進文字コードも使えますし（下記参照）、
@samp{\C-}や文字向けの他の構文も使えます。
したがって、@kbd{M-A}は@samp{?\M-A}と書いたり@samp{?\M-\101}と書けます。
同様に、@kbd{C-M-b}は@samp{?\M-\C-b}、
@samp{?\C-\M-b}、@samp{?\M-\002}と書けます。

@c   The case of a graphic character is indicated by its character code;
@c for example, @sc{ASCII} distinguishes between the characters @samp{a}
@c and @samp{A}.  But @sc{ASCII} has no way to represent whether a control
@c character is upper case or lower case.  Emacs uses the
図形文字の大文字小文字は、その文字コードで示されます。
たとえば、@sc{ASCII}では@samp{a}と@samp{A}の文字を区別します。
しかし、@sc{ASCII}ではコントロール文字の大文字小文字を表現できません。
Emacsでは、コントロール文字を打つときに使ったシフトキーを表すために
@tex
$2^{25}$
@end tex
@ifinfo
2**25
@end ifinfo
@c bit to indicate that the shift key was used in typing a control
@c character.  This distinction is possible only when you use X terminals
@c or other special terminals; ordinary terminals do not report the
@c distinction to the computer in any way.
のビットを付加します。
このような区別はX端末や他の特別な端末を使っている場合に限り可能です。
普通の端末ではこのような区別を計算機に送れません。

@c @cindex hyper characters
@c @cindex super characters
@c @cindex alt characters
@cindex ハイパー文字
@cindex スーパー文字
@cindex アルト文字
@c   The X Window System defines three other modifier bits that can be set
@c in a character: @dfn{hyper}, @dfn{super} and @dfn{alt}.  The syntaxes
@c for these bits are @samp{\H-}, @samp{\s-} and @samp{\A-}.  (Case is
@c significant in these prefixes.)  Thus, @samp{?\H-\M-\A-x} represents
@c @kbd{Alt-Hyper-Meta-x}.
Xウィンドウシステムでは、
文字に設定可能な修飾ビットが他に3つあります。
@dfn{ハイパー}（hyper）、@dfn{スーパー}（super）、@dfn{アルト}（alt）です。
これらの修飾ビットの構文は、
@samp{\H-}、@samp{\s-}、@samp{\A-}です。
（これらのプレフィックスでは、大文字小文字を区別する。）
したがって、@samp{?\H-\M-\A-x}は@kbd{Alt-Hyper-Meta-x}を表します。
@tex
%c Numerically, the
%c bit values are $2^{22}$ for alt, $2^{23}$ for super and $2^{24}$ for hyper.
数値的には、
アルトは$2^{22}$、スーパーは$2^{23}$、ハイパーは$2^{24}$のビット値です。
@end tex
@ifinfo
@c Numerically, the
@c bit values are 2**22 for alt, 2**23 for super and 2**24 for hyper.
数値的には、
アルトは2**22、スーパーは2**23、ハイパーは2**24のビット値です。
@end ifinfo

@c @cindex @samp{?} in character constant
@c @cindex question mark in character constant
@c @cindex @samp{\} in character constant
@c @cindex backslash in character constant
@c @cindex octal character code
@cindex @samp{?}、文字定数
@cindex 文字定数、@samp{?}
@cindex 疑問符、文字定数
@cindex 文字定数、疑問符
@cindex @samp{\}、文字定数
@cindex 文字定数、@samp{\}
@cindex バックスラッシュ、文字定数
@cindex 文字定数、バックスラッシュ
@cindex 8進数字文字定数
@cindex 文字定数、8進数字
@c   Finally, the most general read syntax for a character represents the
@c character code in either octal or hex.  To use octal, write a question
@c mark followed by a backslash and the octal character code (up to three
@c octal digits); thus, @samp{?\101} for the character @kbd{A},
@c @samp{?\001} for the character @kbd{C-a}, and @code{?\002} for the
@c character @kbd{C-b}.  Although this syntax can represent any @sc{ASCII}
@c character, it is preferred only when the precise octal value is more
@c important than the @sc{ASCII} representation.
文字向けのもっとも汎用の入力構文では、
文字コードを8進数や16進数で表現します。
8進数を使うには、順に、
疑問符、バックスラッシュ、（3桁までの）8進数字文字コードを書きます。
たとえば、@samp{?\101}は文字@kbd{A}を表し、
@samp{?\001}は文字@kbd{C-a}を表し、@code{?\002}は文字@kbd{C-b}を表します。
この構文で任意の@sc{ASCII}文字を表現できますが、
@sc{ASCII}での表現よりも8進数値で表現することが重要な場合に限るべきです。

@example
@group
?\012 @result{} 10         ?\n @result{} 10         ?\C-j @result{} 10
?\101 @result{} 65         ?A @result{} 65
@end group
@end example

@c   To use hex, write a question mark followed by a backslash, @samp{x},
@c and the hexadecimal character code.  You can use any number of hex
@c digits, so you can represent any character code in this way.
@c Thus, @samp{?\x41} for the character @kbd{A}, @samp{?\x1} for the
@c character @kbd{C-a}, and @code{?\x8e0} for the character
16進数を使うには、順に、疑問符、バックスラッシュ、
@samp{x}、16進数字文字コードを書きます。
16進数の桁数はいくつでもよいので、任意の文字コードを表現できます。
したがって、@samp{?\x41}は文字@kbd{A}を表し、
@samp{?\x1}は文字@kbd{C-a}を表し、
@code{?\x8e0}は
@iftex
@c @samp{@`a}.
文字@samp{@`a}表します。
@end iftex
@ifinfo
@c @samp{a} with grave accent.
グレーブアクセント付きの文字@samp{a}を表します。
@end ifinfo

@c   A backslash is allowed, and harmless, preceding any character without
@c a special escape meaning; thus, @samp{?\+} is equivalent to @samp{?+}.
@c There is no reason to add a backslash before most characters.  However,
@c you should add a backslash before any of the characters
@c @samp{()\|;'`"#.,} to avoid confusing the Emacs commands for editing
@c Lisp code.  Also add a backslash before whitespace characters such as
@c space, tab, newline and formfeed.  However, it is cleaner to use one of
@c the easily readable escape sequences, such as @samp{\t}, instead of an
@c actual whitespace character such as a tab.
特別なエスケープの意味を持たないどんな文字のまえにもバックスラッシュを
付けることができ、しかも、無害です。
したがって、@samp{?\+}は@samp{?+}に等価です。
ほとんどの文字のまえにバックスラッシュを付ける理由はありません。
しかしながら、Lispコードを編集するEmacsコマンドが混乱しないように、
@samp{()\|;'`"#.,}のいずれかの文字のまえにはバックスラッシュを付けるべきです。
空白、タブ、改行、ページ送りのような白文字のまえにも
バックスラッシュを付けるべきです。
しかしながら、タブなどの実際の白文字のかわりに、
@samp{\t}などの読みやすいエスケープシーケンスを使ったほうが明確です。

@node Symbol Type
@c @subsection Symbol Type
@subsection シンボル型

@c   A @dfn{symbol} in GNU Emacs Lisp is an object with a name.  The symbol
@c name serves as the printed representation of the symbol.  In ordinary
@c use, the name is unique---no two symbols have the same name.
GNU Emacs Lispにおける@dfn{シンボル}（symbol）は、
名前を持ったオブジェクトです。
シンボル名は、シンボルの表示表現としての役割があります。
普通の使い方では、名前は一意です。
つまり、2つのシンボルが同じ名前を持つことはありません。

@c   A symbol can serve as a variable, as a function name, or to hold a
@c property list.  Or it may serve only to be distinct from all other Lisp
@c objects, so that its presence in a data structure may be recognized
@c reliably.  In a given context, usually only one of these uses is
@c intended.  But you can use one symbol in all of these ways,
@c independently.
シンボルは、変数としての役割、関数名としての役割、
あるいは、属性リストを保持する役割を果たします。
また、他のすべてのLispオブジェクトと区別するためだけの役割を
果たすこともあり、データ構造の内部にそのようなシンボルが存在することを
正確に認識できます。
ある場面においては、普通、これらのうちの1つの使い方をします。
しかし、ある1つのシンボルに対してすべての使い方をしてもかまいません。

@c @cindex @samp{\} in symbols
@c @cindex backslash in symbols
@cindex @samp{\}、シンボル内
@cindex バックスラッシュ、シンボル内
@c   A symbol name can contain any characters whatever.  Most symbol names
@c are written with letters, digits, and the punctuation characters
@c @samp{-+=*/}.  Such names require no special punctuation; the characters
@c of the name suffice as long as the name does not look like a number.
@c (If it does, write a @samp{\} at the beginning of the name to force
@c interpretation as a symbol.)  The characters @samp{_~!@@$%^&:<>@{@}} are
@c less often used but also require no special punctuation.  Any other
@c characters may be included in a symbol's name by escaping them with a
@c backslash.  In contrast to its use in strings, however, a backslash in
@c the name of a symbol simply quotes the single character that follows the
@c backslash.  For example, in a string, @samp{\t} represents a tab
@c character; in the name of a symbol, however, @samp{\t} merely quotes the
@c letter @samp{t}.  To have a symbol with a tab character in its name, you
@c must actually use a tab (preceded with a backslash).  But it's rare to
@c do such a thing.
シンボル名には、どんな文字でも含められます。
ほとんどのシンボル名は、英文字、数字、@samp{-+=*/}の句読点文字で書かれます。
そのような名前では、特別な書き方は必要ありません。
名前が数に見えなければ、名前を構成する文字はなんでもよいのです。
（名前が数に見えるときには、
名前の先頭に@samp{\}を書いてシンボルであると強制する。）
@samp{_~!@@$%^&:<>@{@}}の文字はあまり使われませんが、
これらにも特別な書き方は必要ありません。
これら以外の文字は、バックスラッシュでエスケープすれば、
シンボル名に含められます。
文字列におけるバックスラッシュの用法とは対照的に、
シンボル名におけるバックスラッシュは、直後の1文字をクォートするだけです。
たとえば、文字列では@samp{\t}はタブ文字を表しますが、
シンボル名では英文字@samp{t}をクォートするだけです。
名前にタブ文字を含むシンボルを書くには、
実際に（バックスラッシュの直後に）タブを使う必要があります。
しかし、そのようなことをするのは皆無でしょう。

@c @cindex CL note---case of letters
@cindex CLに関した注意−−大文字小文字の区別
@quotation
@c @b{Common Lisp note:} In Common Lisp, lower case letters are always
@c ``folded'' to upper case, unless they are explicitly escaped.  In Emacs
@c Lisp, upper case and lower case letters are distinct.
@b{Common Lispに関した注意：}@code{ }
Common Lispでは、小文字を明示的にエスケープしない限り、
小文字をつねに大文字に『変換』する。
Emacs Lispでは、大文字と小文字を区別する。
@end quotation

@c   Here are several examples of symbol names.  Note that the @samp{+} in
@c the fifth example is escaped to prevent it from being read as a number.
@c This is not necessary in the sixth example because the rest of the name
@c makes it invalid as a number.
シンボル名の例をいくつかあげましょう。
5番目の例の@samp{+}は、数として読まれるのを防ぐために
エスケープしてあることに注意してください。
6番目の例では、これは必要ありません。
なぜなら、名前の残りの部分が数としては不正だからです。

@example
@group
@c foo                 ; @r{A symbol named @samp{foo}.}
@c FOO                 ; @r{A symbol named @samp{FOO}, different from @samp{foo}.}
@c char-to-string      ; @r{A symbol named @samp{char-to-string}.}
foo                 ; @r{@samp{foo}という名前のシンボル}
FOO                 ; @r{@samp{FOO}という名前のシンボル、@samp{foo}とは別}
char-to-string      ; @r{@samp{char-to-string}という名前のシンボル}
@end group
@group
@c 1+                  ; @r{A symbol named @samp{1+}}
@c                     ;   @r{(not @samp{+1}, which is an integer).}
1+                  ; @r{@samp{1+}という名前のシンボル}
                    ;   @r{（整数の@samp{+1}ではない）}
@end group
@group
@c \+1                 ; @r{A symbol named @samp{+1}}
@c                     ;   @r{(not a very readable name).}
\+1                 ; @r{@samp{+1}という名前のシンボル}
                    ;   @r{（読みにくい名前）}
@end group
@group
@c \(*\ 1\ 2\)         ; @r{A symbol named @samp{(* 1 2)} (a worse name).}
\(*\ 1\ 2\)         ; @r{@samp{(* 1 2)}という名前のシンボル（悪い名前）}
@c @c the @'s in this next line use up three characters, hence the
@c @c apparent misalignment of the comment.
@c +-*/_~!@@$%^&=:<>@{@}  ; @r{A symbol named @samp{+-*/_~!@@$%^&=:<>@{@}}.}
@c                     ;   @r{These characters need not be escaped.}
+-*/_~!@@$%^&=:<>@{@}  ; @r{@samp{+-*/_~!@@$%^&=:<>@{@}}という名前のシンボル}
                    ;   @r{これらの文字をエスケープする必要はない}
@end group
@end example

@node Sequence Type
@c @subsection Sequence Types
@subsection シーケンス型

@c   A @dfn{sequence} is a Lisp object that represents an ordered set of
@c elements.  There are two kinds of sequence in Emacs Lisp, lists and
@c arrays.  Thus, an object of type list or of type array is also
@c considered a sequence.
@dfn{シーケンス}（sequence）とは、
要素の順序集合を表現するLispオブジェクトです。
Emacs Lispには2種類のシーケンス、つまり、リストと配列があります。
したがって、リスト型や配列型のオブジェクトは、
シーケンス型でもあると考えられます。

@c   Arrays are further subdivided into strings, vectors, char-tables and
@c bool-vectors.  Vectors can hold elements of any type, but string
@c elements must be characters, and bool-vector elements must be @code{t}
@c or @code{nil}.  The characters in a string can have text properties like
@c characters in a buffer (@pxref{Text Properties}); vectors and
@c bool-vectors do not support text properties even when their elements
@c happen to be characters.  Char-tables are like vectors except that they
@c are indexed by any valid character code.
配列はさらに、文字列、ベクトル、文字テーブル、ブールベクトルに細分されます。
ベクトルは任意の型の要素を保持できますが、
文字列の要素は文字である必要があり、
ブールベクトルの要素は@code{t}か@code{nil}のいずれかである必要があります。
バッファ内の文字のように、
文字列内の文字はテキスト属性を持てます（@pxref{Text Properties}）。
ベクトルとブールベクトル
@footnote{【訳注】ベクトルのみの誤り？}
では、それらの要素が文字であったとしても、
テキスト属性を扱えません。
文字テーブルは、ベクトルに似ていますが、正しい文字コードで添字付けします。

@c   Lists, strings and the other array types are different, but they have
@c important similarities.  For example, all have a length @var{l}, and all
@c have elements which can be indexed from zero to @var{l} minus one.
@c Several functions, called sequence functions, accept any kind of
@c sequence.  For example, the function @code{elt} can be used to extract
@c an element of a sequence, given its index.  @xref{Sequences Arrays
@c Vectors}.
リスト、文字列、および、その他の配列型は別のものですが、
それらには重要な類似性があります。
たとえば、それらすべてに長さ@var{l}があり、
それらのすべての要素は0から@var{l}@minus{}1で添字付けできます。
シーケンス関数と呼ばれるいくつかの関数は、
任意のシーケンス型を扱います。
たとえば、シーケンスから指定した添字の要素を取り出すには、
関数@code{elt}を使います。
@xref{Sequences Arrays Vectors}。

@c   It is generally impossible to read the same sequence twice, since
@c sequences are always created anew upon reading.  If you read the read
@c syntax for a sequence twice, you get two sequences with equal contents.
@c There is one exception: the empty list @code{()} always stands for the
@c same object, @code{nil}.
一般には、同一のシーケンスを二度読み取ることは不可能です。
というのは、読むたびにつねに新たにシーケンスを作成するからです。
シーケンスの入力構文を二度読むと、
同じ内容の2つのシーケンスを得ることになります。
1つ例外があります。
空リスト@code{()}は、つねに同じオブジェクト@code{nil}を表します。

@node Cons Cell Type
@c @subsection Cons Cell and List Types
@subsection コンスセルとリスト型
@c @cindex address field of register
@c @cindex decrement field of register
@c @cindex pointers
@cindex レジスタの番地フィールド
@cindex レジスタの減数フィールド
@cindex ポインタ

@c   A @dfn{cons cell} is an object that consists of two pointers or slots,
@c called the @sc{car} slot and the @sc{cdr} slot.  Each slot can
@c @dfn{point to} or hold to any Lisp object.  We also say that the ``the
@c @sc{car} of this cons cell is'' whatever object its @sc{car} slot
@c currently points to, and likewise for the @sc{cdr}.
@dfn{コンスセル}（cons cell）とは、
@sc{car}スロットおよび@sc{cdr}スロットと呼ばれる
2つのポインタから成るオブジェクトです。
各スロットは、任意のLispオブジェクトを@dfn{指す}ことができます。
また、現在@sc{car}スロットが指しているオブジェクトがなんであれ、
『コンスセルの@sc{car}は』といったいい方をします。
@sc{cdr}についても同様です。

@c   A @dfn{list} is a series of cons cells, linked together so that the
@c @sc{cdr} slot of each cons cell holds either the next cons cell or the
@c empty list.  @xref{Lists}, for functions that work on lists.  Because
@c most cons cells are used as part of lists, the phrase @dfn{list
@c structure} has come to refer to any structure made out of cons cells.
@dfn{リスト}（list）はコンスセルが連なったものであり、
各コンスセルの@sc{cdr}スロットは、
後続のコンスセルを指すか空リストを指します。
リストに作用する関数については、@xref{Lists}。
ほとんどのコンスセルは、リストの一部分として使われるので、
@dfn{リスト構造}（list structure）という用語は、
コンスセルから成る任意の構造のことを意味します。

@c   The names @sc{car} and @sc{cdr} derive from the history of Lisp.  The
@c original Lisp implementation ran on an @w{IBM 704} computer which
@c divided words into two parts, called the ``address'' part and the
@c ``decrement''; @sc{car} was an instruction to extract the contents of
@c the address part of a register, and @sc{cdr} an instruction to extract
@c the contents of the decrement.  By contrast, ``cons cells'' are named
@c for the function @code{cons} that creates them, which in turn is named
@c for its purpose, the construction of cells.
@sc{car}や@sc{cdr}という名称は、Lispの歴史に由来します。
最初のLispは@w{IBM 704}で動作していました。
この計算機では、ワードを2つの部分、『番地』（address）部分、
『減数』（decrement）部分と呼ばれるものに分けていました。
@sc{car}はレジスタの番地部分の内容（Contents of Address Register）を
取り出す命令であり、
@sc{cdr}はレジスタの減数部分の内容（Contents of Decrement Register）を
取り出す命令でした。
一方、『コンスセル』という名称は、
これらを作成する関数@code{cons}からきています。
この関数名は、その目的、セルを作る（construction of cells）からきています。

@c @cindex atom
@cindex アトム
@c   Because cons cells are so central to Lisp, we also have a word for
@c ``an object which is not a cons cell''.  These objects are called
@c @dfn{atoms}.
コンスセルはLispの核心なので、
『コンスセルではないオブジェクト』に対する名称もあります。
これらのオブジェクトを@dfn{アトム}（atoms）と呼びます。

@c @cindex parenthesis
@cindex 括弧
@c   The read syntax and printed representation for lists are identical, and
@c consist of a left parenthesis, an arbitrary number of elements, and a
@c right parenthesis.
リストの入力構文と表示表現は同一です。
開き括弧で始まり、任意個の要素、閉じ括弧で終えます。

@c    Upon reading, each object inside the parentheses becomes an element
@c of the list.  That is, a cons cell is made for each element.  The
@c @sc{car} slot of the cons cell points to the element, and its @sc{cdr}
@c slot points to the next cons cell of the list, which holds the next
@c element in the list.  The @sc{cdr} slot of the last cons cell is set to
@c point to @code{nil}.
読み取り時には、括弧の内側の各オブジェクトが、
リストの各要素になります。
つまり、これらの要素からなるコンスセルを作ります。
コンスセルの@sc{car}スロットで要素を指します。
同じコンスセルの@sc{cdr}スロットで、
リスト上のつぎの要素を保持している、
リストのつぎのコンスセルを指します。
最後のコンスセルの@sc{cdr}スロットは@code{nil}を指します。

@c @cindex box diagrams, for lists
@c @cindex diagrams, boxed, for lists
@cindex 箱表示、リスト
@cindex リストの箱表示
@cindex 図表示、リスト
@cindex リストの図表示
@c   A list can be illustrated by a diagram in which the cons cells are
@c shown as pairs of boxes, like dominoes.  (The Lisp reader cannot read
@c such an illustration; unlike the textual notation, which can be
@c understood by both humans and computers, the box illustrations can be
@c understood only by humans.)  This picture represents the three-element
@c list @code{(rose violet buttercup)}:
リストは、コンスセルを1対の箱で表して図示できます。
（Lispリーダがこのような図表示を読むことはない。
人間や計算機が理解できるテキスト表記と違い、
箱を用いた図表示は人間だけが理解できる。）
つぎの図は、3つの要素から成るリスト@code{(rose violet buttercup)}を表します。

@example
@group
    --- ---      --- ---      --- ---
   |   |   |--> |   |   |--> |   |   |--> nil
    --- ---      --- ---      --- ---
     |            |            |
     |            |            |
      --> rose     --> violet   --> buttercup
@end group
@end example

@c   In this diagram, each box represents a slot that can point to any Lisp
@c object.  Each pair of boxes represents a cons cell.  Each arrow is a
@c pointer to a Lisp object, either an atom or another cons cell.
この図で、各箱は、任意のLispオブジェクトを指すことができるスロットを表します。
箱の対でコンスセルを表します。
各矢印は、アトムや他のコンスセルであるLispオブジェクトを指すポインタです。

@c   In this example, the first box, which holds the @sc{car} of the first
@c cons cell, points to or ``contains'' @code{rose} (a symbol).  The second
@c box, holding the @sc{cdr} of the first cons cell, points to the next
@c pair of boxes, the second cons cell.  The @sc{car} of the second cons
@c cell is @code{violet}, and its @sc{cdr} is the third cons cell.  The
@c @sc{cdr} of the third (and last) cons cell is @code{nil}.
この例では、最初のコンスセルの@sc{car}を表す最初の箱は、
@code{rose}（シンボル）を指しています。
あるいは、@code{rose}（シンボル）を『含んでいる』ともいいます。
最初のコンスセルの@sc{cdr}を表す2番目の箱は、
つぎの1対の箱、2番目のコンスセルを指しています。
2番目のコンスセルの@sc{car}は@code{violet}であり、
このコンスセルの@sc{cdr}は3番目のコンスセルです。
3番目の（最後の）コンスセルの@sc{cdr}は、@code{nil}です。

@c   Here is another diagram of the same list, @code{(rose violet
@c buttercup)}, sketched in a different manner:
同じリスト@code{(rose violet buttercup)}を
別の方法で図表示するとつぎのようになります。

@smallexample
@group
 ---------------       ----------------       -------------------
| car   | cdr   |     | car    | cdr   |     | car       | cdr   |
| rose  |   o-------->| violet |   o-------->| buttercup |  nil  |
|       |       |     |        |       |     |           |       |
 ---------------       ----------------       -------------------
@end group
@end smallexample

@c @cindex @samp{(@dots{})} in lists
@c @cindex @code{nil} in lists
@c @cindex empty list
@cindex @samp{(@dots{})}、リスト
@cindex リスト内の@samp{(@dots{})}
@cindex @code{nil}、リスト
@cindex リスト内の@code{nil}
@cindex 空リスト
@c   A list with no elements in it is the @dfn{empty list}; it is identical
@c to the symbol @code{nil}.  In other words, @code{nil} is both a symbol
@c and a list.
内部に要素を持たないリストは、@dfn{空リスト}（empty list）です。
これはシンボル@code{nil}と同一です。
いいかえれば、@code{nil}はシンボルでもありリストでもあります。

@c   Here are examples of lists written in Lisp syntax:
Lispの構文で書き表したリストの例を示します。

@example
@c (A 2 "A")            ; @r{A list of three elements.}
@c ()                   ; @r{A list of no elements (the empty list).}
@c nil                  ; @r{A list of no elements (the empty list).}
@c ("A ()")             ; @r{A list of one element: the string @code{"A ()"}.}
@c (A ())               ; @r{A list of two elements: @code{A} and the empty list.}
@c (A nil)              ; @r{Equivalent to the previous.}
@c ((A B C))            ; @r{A list of one element}
@c                      ;   @r{(which is a list of three elements).}
(A 2 "A")            ; @r{3要素のリスト}
()                   ; @r{要素を持たないリスト（空リスト）}
nil                  ; @r{要素を持たないリスト（空リスト）}
("A ()")             ; @r{文字列@code{"A ()"}だけの1要素のリスト}
(A ())               ; @r{@code{A}と空リストから成る2要素のリスト}
(A nil)              ; @r{上と同じ}
((A B C))            ; @r{1要素のリスト}
                     ;   @r{（その要素は3要素のリスト）}
@end example

@c   Here is the list @code{(A ())}, or equivalently @code{(A nil)},
@c depicted with boxes and arrows:
リスト@code{(A ())}や、これと同じ@code{(A nil)}を
箱と矢印で書くとつぎのようになります。

@example
@group
    --- ---      --- ---
   |   |   |--> |   |   |--> nil
    --- ---      --- ---
     |            |
     |            |
      --> A        --> nil
@end group
@end example

@menu
* Dotted Pair Notation::        An alternative syntax for lists.
* Association List Type::       A specially constructed list.
@end menu

@node Dotted Pair Notation
@comment  node-name,  next,  previous,  up
@c @subsubsection Dotted Pair Notation
@subsubsection ドット対記法
@c @cindex dotted pair notation
@c @cindex @samp{.} in lists
@cindex ドット対記法
@cindex @samp{.}、リスト
@cindex リスト内の@samp{.}

@c   @dfn{Dotted pair notation} is an alternative syntax for cons cells
@c that represents the @sc{car} and @sc{cdr} explicitly.  In this syntax,
@c @code{(@var{a} .@: @var{b})} stands for a cons cell whose @sc{car} is
@c the object @var{a}, and whose @sc{cdr} is the object @var{b}.  Dotted
@c pair notation is therefore more general than list syntax.  In the dotted
@c pair notation, the list @samp{(1 2 3)} is written as @samp{(1 .  (2 . (3
@c . nil)))}.  For @code{nil}-terminated lists, you can use either
@c notation, but list notation is usually clearer and more convenient.
@c When printing a list, the dotted pair notation is only used if the
@c @sc{cdr} of a cons cell is not a list.
@dfn{ドット対記法}（dotted pair notation）とは、
@sc{car}と@sc{cdr}を明示したコンスセルを表すもう1つの構文です。
この構文では、@code{(@var{a} .@: @var{b})}で、
@sc{car}がオブジェクト@var{a}であり
@sc{cdr}がオブジェクト@var{b}であるコンスセルを表します。
したがって、ドット対記法は、リストの構文よりさらに汎用性があります。
ドット対記法では、リスト@samp{(1 2 3)}は、
@samp{(1 .  (2 . (3 . nil)))}と書けます。
@code{nil}で終るリストならば、どちらの記法でも書き表せますが、
リスト記法のほうがわかりやすくて便利です。
リストを表示するときには、コンスセルの@sc{cdr}がリスト以外の場合に限って
ドット対記法を使います。

@c   Here's an example using boxes to illustrate dotted pair notation.
@c This example shows the pair @code{(rose . violet)}:
ドット対記法を箱で表現してみます。
つぎの例は@code{(rose . violet)}を表したものです。

@example
@group
    --- ---
   |   |   |--> violet
    --- ---
     |
     |
      --> rose
@end group
@end example

@c   You can combine dotted pair notation with list notation to represent
@c conveniently a chain of cons cells with a non-@code{nil} final @sc{cdr}.
@c You write a dot after the last element of the list, followed by the
@c @sc{cdr} of the final cons cell.  For example, @code{(rose violet
@c . buttercup)} is equivalent to @code{(rose . (violet . buttercup))}.
@c The object looks like this:
最後の@sc{cdr}が@code{nil}以外であるようなコンスセルの連鎖を表現するために、
リスト記法にドット対記法を組み合わせることもできます。
リストの最後の要素のあとにドットを書き、
続けて、最後のコンスセルの@sc{cdr}を書きます。
たとえば、@code{(rose violet . buttercup)}は、
@code{(rose . (violet . buttercup))}に等価です。
このオブジェクトはつぎのようになります。

@example
@group
    --- ---      --- ---
   |   |   |--> |   |   |--> buttercup
    --- ---      --- ---
     |            |
     |            |
      --> rose     --> violet
@end group
@end example

@c   The syntax @code{(rose .@: violet .@: buttercup)} is invalid because
@c there is nothing that it could mean.  If anything, it would say to put
@c @code{buttercup} in the @sc{cdr} of a cons cell whose @sc{cdr} is already
@c used for @code{violet}.
@code{(rose .@: violet .@: buttercup)}という構文は不正です。
これが意味することはなにもありません。
たとえあったとしても、@sc{cdr}を@code{violet}用にすでに使っているコンスセルの
@sc{cdr}に@code{buttercup}を置けということになります。

@c   The list @code{(rose violet)} is equivalent to @code{(rose . (violet))},
@c and looks like this:
リスト@code{(rose violet)}は、@code{(rose . (violet))}に等価であり、
つぎのように図示できます。

@example
@group
    --- ---      --- ---
   |   |   |--> |   |   |--> nil
    --- ---      --- ---
     |            |
     |            |
      --> rose     --> violet
@end group
@end example

@c   Similarly, the three-element list @code{(rose violet buttercup)}
@c is equivalent to @code{(rose . (violet . (buttercup)))}.
同様に、3要素のリスト@code{(rose violet buttercup)}は、
@code{(rose . (violet . (buttercup)))}に等価です。
@ifinfo
@c It looks like this:
つぎのように図示できます。

@example
@group
    --- ---      --- ---      --- ---
   |   |   |--> |   |   |--> |   |   |--> nil
    --- ---      --- ---      --- ---
     |            |            |
     |            |            |
      --> rose     --> violet   --> buttercup
@end group
@end example
@end ifinfo

@node Association List Type
@comment  node-name,  next,  previous,  up
@c @subsubsection Association List Type
@subsubsection 連想リスト型

@c   An @dfn{association list} or @dfn{alist} is a specially-constructed
@c list whose elements are cons cells.  In each element, the @sc{car} is
@c considered a @dfn{key}, and the @sc{cdr} is considered an
@c @dfn{associated value}.  (In some cases, the associated value is stored
@c in the @sc{car} of the @sc{cdr}.)  Association lists are often used as
@c stacks, since it is easy to add or remove associations at the front of
@c the list.
@dfn{連想リスト}（association list）、すなわち、@dfn{alist}は、
各要素がコンスセルであるように特別に構成したリストのことです。
各要素では、@sc{car}を@dfn{キー}（key）と考え、
@sc{cdr}を@dfn{連想値}（associated value）と考えます。
（場合によっては、連想値を、@sc{cdr}の@sc{car}に保持することもある。）
連想リストはスタックとして使われることがままあります。
というのは、リストの先頭に対応関係を追加／削除するのが簡単だからです。

@c   For example,
たとえば、

@example
(setq alist-of-colors
      '((rose . red) (lily . white)  (buttercup . yellow)))
@end example

@noindent
@c sets the variable @code{alist-of-colors} to an alist of three elements.  In the
@c first element, @code{rose} is the key and @code{red} is the value.
は、変数@code{alist-of-colors}に、3要素の連想リストを設定します。
最初の要素では、@code{rose}がキーであり、@code{red}が値です。

@c   @xref{Association Lists}, for a further explanation of alists and for
@c functions that work on alists.
連想リストとそれらを操作する関数について詳しい説明は、
@xref{Association Lists}。

@node Array Type
@c @subsection Array Type
@subsection 配列型

@c   An @dfn{array} is composed of an arbitrary number of slots for
@c pointing to other Lisp objects, arranged in a contiguous block of
@c memory.  Accessing any element of an array takes approximately the same
@c amount of time.  In contrast, accessing an element of a list requires
@c time proportional to the position of the element in the list.  (Elements
@c at the end of a list take longer to access than elements at the
@c beginning of a list.)
@dfn{配列}（array）は、任意のLispオブジェクトを指すための
任意個のスロットから成り、メモリの連続した場所に取ります。
配列のどの要素を参照しても、ほぼ同じ時間かかります。
一方、リストの要素を参照するときには、
リスト内の要素の位置に比例した時間が必要です。
（リストの末尾の要素を参照するには、
リストの先頭の要素を参照するより時間がかかる。）

@c   Emacs defines four types of array: strings, vectors, bool-vectors, and
@c char-tables.
Emacsには、4つの配列型、つまり、
文字列、ベクトル、ブールベクトル、文字テーブルがあります。

@c   A string is an array of characters and a vector is an array of
@c arbitrary objects.  A bool-vector can hold only @code{t} or @code{nil}.
@c These kinds of array may have any length up to the largest integer.
@c Char-tables are sparse arrays indexed by any valid character code; they
@c can hold arbitrary objects.
文字列は文字の配列であり、
ベクトルは任意のオブジェクトの配列です。
ブールベクトルは、@code{t}や@code{nil}だけを保持できます。
これらの種類の配列は、最大の整数値までなら、任意の長さにできます。
文字テーブルは、正しい文字コードで添字付けする疎な配列であり、
任意のオブジェクトを保持できます。

@c   The first element of an array has index zero, the second element has
@c index 1, and so on.  This is called @dfn{zero-origin} indexing.  For
@c example, an array of four elements has indices 0, 1, 2, @w{and 3}.  The
@c largest possible index value is one less than the length of the array.
@c Once an array is created, its length is fixed.
配列の最初の要素は0で添字付けする、
2番目の要素は1で添字付けする、というようになります。
これを@dfn{ゼロ原点}（zero-origin）の添字付けと呼びます。
たとえば、4つの要素からなる配列の添字は、0、1、2、@w{そして、3}です。
最大の添字は、配列の長さより1だけ小さくなります。
いったん配列を作成すると、その長さは固定されます。

@c   All Emacs Lisp arrays are one-dimensional.  (Most other programming
@c languages support multidimensional arrays, but they are not essential;
@c you can get the same effect with an array of arrays.)  Each type of
@c array has its own read syntax; see the following sections for details.
Emacs Lispのすべての配列は1次元です。
（多くの他のプログラム言語では多次元配列を扱えるが、
それは本質的ではない。
配列の配列を作れば同じ効果を得られる。）
配列のそれぞれの型に応じて、専用の入力構文があります。
詳しくは、以下を参照してください。

@c   The array type is contained in the sequence type and
@c contains the string type, the vector type, the bool-vector type, and the
@c char-table type.
配列型はシーケンス型に含まれ、
配列型は、文字型、ベクトル型、ブールベクトル型、文字テーブル型を含みます。

@node String Type
@c @subsection String Type
@subsection 文字列型

@c   A @dfn{string} is an array of characters.  Strings are used for many
@c purposes in Emacs, as can be expected in a text editor; for example, as
@c the names of Lisp symbols, as messages for the user, and to represent
@c text extracted from buffers.  Strings in Lisp are constants: evaluation
@c of a string returns the same string.
@dfn{文字列}（string）とは文字の配列です。
テキストエディタということから予想されるように、
Emacsではさまざまな目的に文字列を使います。
たとえば、Lispシンボルの名前として、
ユーザーへのメッセージとして、
バッファから取り出したテキストを表現するためなどです。
Lispの文字列は定数です。
つまり、文字列を評価すると同じ文字列になります。

@c   @xref{Strings and Characters}, for functions that operate on strings.
文字列を操作する関数については、@xref{Strings and Characters}。

@menu
* Syntax for Strings::
* Non-ASCII in Strings::
* Nonprinting Characters::
* Text Props and Strings::
@end menu

@node Syntax for Strings
@c @subsubsection Syntax for Strings
@subsubsection 文字列の構文

@c @cindex @samp{"} in strings
@c @cindex double-quote in strings
@c @cindex @samp{\} in strings
@c @cindex backslash in strings
@cindex @samp{"}、文字列
@cindex 文字列の@samp{"}
@cindex ダブルクォート、文字列
@cindex 文字列のダブルクォート
@cindex 二重引用符、文字列
@cindex 文字列の二重引用符
@cindex @samp{\}、文字列
@cindex 文字列の@samp{\}
@cindex バックスラッシュ、文字列
@cindex 文字列のバックスラッシュ
@c   The read syntax for strings is a double-quote, an arbitrary number of
@c characters, and another double-quote, @code{"like this"}.  To include a
@c double-quote in a string, precede it with a backslash; thus, @code{"\""}
@c is a string containing just a single double-quote character.  Likewise,
@c you can include a backslash by preceding it with another backslash, like
@c this: @code{"this \\ is a single embedded backslash"}.
文字列の入力構文は、@code{"like this"}のように、
ダブルクォートで始めて、任意個の文字を書き、ダブルクォートで終えます。
文字列の中にダブルクォートを含めるには、
バックスラッシュを直前に置きます。
つまり、@code{"\""}は、ダブルクォート1個だけから成る文字列です。
同様に、バックスラッシュを含めるには、
@code{"this \\ is a single embedded backslash"}のように、
バックスラッシュを直前に置きます。

@c @cindex newline in strings
@cindex 改行、文字列
@cindex 文字列の改行
@c   The newline character is not special in the read syntax for strings;
@c if you write a new line between the double-quotes, it becomes a
@c character in the string.  But an escaped newline---one that is preceded
@c by @samp{\}---does not become part of the string; i.e., the Lisp reader
@c ignores an escaped newline while reading a string.  An escaped space
@c @w{@samp{\ }} is likewise ignored.
文字列の入力構文において、改行文字は特別ではありません。
ダブルクォートのあいだに改行を書けば、
改行は文字列の文字になります。
一方、エスケープした改行、つまり、@samp{\}を直前に書くと、
文字列の一部にはなりません。
すなわち、Lispリーダは、文字列を読む際にエスケープした改行を無視します。
エスケープした空白@w{@samp{\ }}も、同様に無視します。

@example
"It is useful to include newlines
in documentation strings,
but the newline is \
ignored if escaped."
     @result{} "It is useful to include newlines 
in documentation strings, 
but the newline is ignored if escaped."
@end example

@node Non-ASCII in Strings
@c @subsubsection Non-ASCII Characters in Strings
@subsubsection 文字列内の非ASCII文字

@c   You can include a non-@sc{ASCII} international character in a string
@c constant by writing it literally.  There are two text representations
@c for non-@sc{ASCII} characters in Emacs strings (and in buffers): unibyte
@c and multibyte.  If the string constant is read from a multibyte source,
@c such as a multibyte buffer or string, or a file that would be visited as
@c multibyte, then the character is read as a multibyte character, and that
@c makes the string multibyte.  If the string constant is read from a
@c unibyte source, then the character is read as unibyte and that makes the
@c string unibyte.
非@sc{ASCII}である国際化文字を文字列に含めるには、
その文字をそのまま書きます。
Emacsの文字列（および、バッファ）では、
非@sc{ASCII}の表現方法が2つあります。
ユニバイトとマルチバイトです。
マルチバイトバッファやマルチバイト文字列、あるいは、
マルチバイトとして訪問しているファイルなどの
マルチバイトのソースから文字列定数を読み取るときには、
文字をマルチバイト文字として読み取り、
マルチバイト文字列にします。
ユニバイトのソースから文字列定数を読み取るときには、
文字をユニバイト文字として読み取り、
文字列はユニバイトになります。

@c @c ??? Change this?
@c   You can also represent a multibyte non-@sc{ASCII} character with its
@c character code, using a hex escape, @samp{\x@var{nnnnnnn}}, with as many
@c digits as necessary.  (Multibyte non-@sc{ASCII} character codes are all
@c greater than 256.)  Any character which is not a valid hex digit
@c terminates this construct.  If the character that would follow is a hex
@c digit, write @w{@samp{\ }} (backslash and space)
@c to terminate the hex escape---for example,
@c @w{@samp{\x8e0\ }} represents one character, @samp{a} with grave accent.
@c @w{@samp{\ }} in a string constant is just like backslash-newline; it does
@c not contribute any character to the string, but it does terminate the
@c preceding hex escape.
マルチバイトの非@sc{ASCII}文字は、
必要な桁数の16進エスケープ@samp{\x@var{nnnnnnn}}を用いて
書くこともできます。
（マルチバイトの非@sc{ASCII}文字のコードは、256より大きい。）
16進数字として正しくない文字で16進エスケープを終端します。
16進数字の文字があとに続く場合には、@w{@samp{\ }}（バックスラッシュと空白）と
書いて16進エスケープを終端します。
たとえば、@w{@samp{\x8e0\ }}は、グレーブアクセント付きの@samp{a}を表します。
文字列定数内の@w{@samp{\ }}は、バックスラッシュ＋改行と同じです。
文字列内の文字には含まれませんが、先行する16進エスケープを終えます。

@c   Using a multibyte hex escape forces the string to multibyte.  You can
@c represent a unibyte non-@sc{ASCII} character with its character code,
@c which must be in the range from 128 (0200 octal) to 255 (0377 octal).
@c This forces a unibyte string.
マルチバイトの16進エスケープを使うと、
文字列はマルチバイトになります。
ユニバイトの非@sc{ASCII}を文字コードで表現することもできますが、
文字コードは128（8進0200）から255（8進0377）の範囲である必要があります。
こうすると、文字列はユニバイトになります。
  
@c   @xref{Text Representations}, for more information about the two
@c text representations.
2種類のテキストの表現方法について詳しくは、@xref{Text Representations}。

@node Nonprinting Characters
@c @subsubsection Nonprinting Characters in Strings
@subsubsection 文字列内の非印字文字

@c   You can use the same backslash escape-sequences in a string constant
@c as in character literals (but do not use the question mark that begins a
@c character constant).  For example, you can write a string containing the
@c nonprinting characters tab and @kbd{C-a}, with commas and spaces between
@c them, like this: @code{"\t, \C-a"}.  @xref{Character Type}, for a
@c description of the read syntax for characters.
文字定数と同じバックスラッシュのエスケープシーケンスを文字列定数でも
使えます（ただし、文字定数を開始する疑問符は書かない）。
たとえば、コンマと空白で区切った非印字文字のタブと@kbd{C-a}を
含む文字列を書くには、@code{"\t, \C-a"}のようにします。
文字の入力構文については、@xref{Character Type}。

@c   However, not all of the characters you can write with backslash
@c escape-sequences are valid in strings.  The only control characters that
@c a string can hold are the @sc{ASCII} control characters.  Strings do not
@c distinguish case in @sc{ASCII} control characters.
しかしながら、バックスラッシュのエスケープシーケンスすべてが、
文字列において正しいとは限りません。
文字列に含めることが可能なコントロール文字は、
@sc{ASCII}コントロール文字に限ります。
文字列では、@sc{ASCII}コントロール文字の大文字小文字を区別しません。

@c   Properly speaking, strings cannot hold meta characters; but when a
@c string is to be used as a key sequence, there is a special convention
@c that provides a way to represent meta versions of @sc{ASCII} characters in a
@c string.  If you use the @samp{\M-} syntax to indicate a meta character
@c in a string constant, this sets the
正確にいえば、文字列はメタ文字を保持できません。
しかし、文字列をキー列として使う場合には、
文字列内の@sc{ASCII}文字のメタ変種を表現するための
特別な慣習があります。
文字列定数内でメタ文字を表すために@samp{\M-}の構文を使うと、
文字列内のその文字に
@tex
$2^{7}$
@end tex
@ifinfo
2**7
@end ifinfo
@c bit of the character in the string.  If the string is used in
@c @code{define-key} or @code{lookup-key}, this numeric code is translated
@c into the equivalent meta character.  @xref{Character Type}.
のビットを設定します。
@code{define-key}や@code{lookup-key}に文字列を使うと、
このコードは、等価なメタ文字に変換されます。
@xref{Character Type}。

@c   Strings cannot hold characters that have the hyper, super, or alt
@c modifiers.
文字列では、ハイパー、スーパー、アルトの修飾子を保持できません。

@node Text Props and Strings
@c @subsubsection Text Properties in Strings
@subsubsection 文字列内のテキスト属性

@c   A string can hold properties for the characters it contains, in
@c addition to the characters themselves.  This enables programs that copy
@c text between strings and buffers to copy the text's properties with no
@c special effort.  @xref{Text Properties}, for an explanation of what text
@c properties mean.  Strings with text properties use a special read and
@c print syntax:
文字列は、文字そのものに加えて、文字の属性も保持できます。
このため、特別なことをしなくても、
文字列とバッファのあいだでテキストをコピーするプログラムは、
テキスト属性をコピーできます。
テキスト属性の意味については、@xref{Text Properties}。
テキスト属性付きの文字列には、特別な入力構文があります。

@example
#("@var{characters}" @var{property-data}...)
@end example

@noindent
@c where @var{property-data} consists of zero or more elements, in groups
@c of three as follows:
ここで、@var{property-data}は0個以上のつぎのような3つ組みです。

@example
@var{beg} @var{end} @var{plist}
@end example

@noindent
@c The elements @var{beg} and @var{end} are integers, and together specify
@c a range of indices in the string; @var{plist} is the property list for
@c that range.  For example,
3つ組みの要素、@var{beg}と@var{end}は整数であり、
文字列内の添字の範囲を表します。
@var{plist}はその範囲の属性リストです。
たとえば、

@example
#("foo bar" 0 3 (face bold) 3 4 nil 4 7 (face italic))
@end example

@noindent
@c represents a string whose textual contents are @samp{foo bar}, in which
@c the first three characters have a @code{face} property with value
@c @code{bold}, and the last three have a @code{face} property with value
@c @code{italic}.  (The fourth character has no text properties, so its
@c property list is @code{nil}.  It is not actually necessary to mention
@c ranges with @code{nil} as the property list, since any characters not
@c mentioned in any range will default to having no properties.)
は、最初の3文字が@code{face}属性として@code{bold}を持ち、
最後の3文字が@code{face}属性として@code{italic}を持つ、
@samp{foo bar}という文字列を表します。
（4番目の文字にはテキスト属性はなく、その属性リストは@code{nil}。
デフォルトでは、範囲に含まれない文字には属性はないので、
属性リストが@code{nil}であるような範囲を言及する必要はない。）

@node Vector Type
@c @subsection Vector Type
@subsection ベクトル型

@c   A @dfn{vector} is a one-dimensional array of elements of any type.  It
@c takes a constant amount of time to access any element of a vector.  (In
@c a list, the access time of an element is proportional to the distance of
@c the element from the beginning of the list.)
@dfn{ベクトル}（vector）は、任意の型の要素から成る1次元配列です。
ベクトルの任意の要素を参照しても、それに必要な時間は一定です。
（リストでは、ある要素を参照するために必要な時間は、
リストの先頭からの距離に比例する。）

@c   The printed representation of a vector consists of a left square
@c bracket, the elements, and a right square bracket.  This is also the
@c read syntax.  Like numbers and strings, vectors are considered constants
@c for evaluation.
ベクトルの表示表現は、開き角括弧、要素、閉じ角括弧です。
これは、入力構文でもあります。
数や文字列と同様に、ベクトルは評価時には定数です。

@example
@c [1 "two" (three)]      ; @r{A vector of three elements.}
[1 "two" (three)]      ; @r{3要素のベクトル}
     @result{} [1 "two" (three)]
@end example

@c   @xref{Vectors}, for functions that work with vectors.
ベクトルに作用する関数については、@xref{Vectors}。

@node Char-Table Type
@c @subsection Char-Table Type
@subsection 文字テーブル型

@c   A @dfn{char-table} is a one-dimensional array of elements of any type,
@c indexed by character codes.  Char-tables have certain extra features to
@c make them more useful for many jobs that involve assigning information
@c to character codes---for example, a char-table can have a parent to
@c inherit from, a default value, and a small number of extra slots to use for
@c special purposes.  A char-table can also specify a single value for
@c a whole character set.
@dfn{文字テーブル}（char-table）は、
任意の型の要素から成る1次元配列であり、
文字コードで添字付けします。
文字テーブルには、文字コードに情報を与えるための多くの操作を簡単にする
付加的な機能があります。
たとえば、文字テーブルは、情報を継承するための親、
デフォルト値、特定目的向けの少数の追加スロットを持てます。
文字テーブルでは、文字集合全体に対して1つの値を指定することもできます。

@c   The printed representation of a char-table is like a vector
@c except that there is an extra @samp{#^} at the beginning.
文字テーブルの表示表現はベクトルに似ていますが、
先頭に@samp{#^}が余分に付きます。

@c   @xref{Char-Tables}, for special functions to operate on char-tables.
@c Uses of char-tables include:
文字テーブルを操作する特別の関数については、@xref{Char-Tables}。
文字テーブルはつぎのように使います。

@itemize @bullet
@item
@c Case tables (@pxref{Case Tables}).
大文字小文字テーブル（@pxref{Case Tables}）。

@item
@c Character category tables (@pxref{Categories}).
文字カテゴリテーブル（@pxref{Categories}）。

@item
@c Display Tables (@pxref{Display Tables}).
表示テーブル（@pxref{Display Tables}）。

@item
@c Syntax tables (@pxref{Syntax Tables}).
構文テーブル（@pxref{Syntax Tables}）。
@end itemize

@node Bool-Vector Type
@c @subsection Bool-Vector Type
@subsection ブールベクトル型

@c   A @dfn{bool-vector} is a one-dimensional array of elements that
@c must be @code{t} or @code{nil}.
@dfn{ブールベクトル}（bool-vector）は、
@code{t}か@code{nil}だけの要素から成る1次元配列です。

@c   The printed representation of a Bool-vector is like a string, except
@c that it begins with @samp{#&} followed by the length.  The string
@c constant that follows actually specifies the contents of the bool-vector
@c as a bitmap---each ``character'' in the string contains 8 bits, which
@c specify the next 8 elements of the bool-vector (1 stands for @code{t},
@c and 0 for @code{nil}).  The least significant bits of the character 
@c correspond to the lowest indices in the bool-vector.  If the length is not a
@c multiple of 8, the printed representation shows extra elements, but
@c these extras really make no difference.
ブールベクトルの表示表現は文字列に似ていますが、
@samp{#&}と長さで始まります。
これに続く文字列定数が、ブールベクトルの実際の内容を
ビットマップで表します。
つまり、文字列の『各文字』は8ビット長のデータであり、
ブールベクトルのつぎの8個の要素を表します
（1は@code{t}を表し、0は@code{nil}を表す）。
文字の最下位ビットが、ブールベクトルの小さい添字に対応します。
長さが8の倍数でない場合には、
表示表現には余計な要素が含まれますが、余計な部分に意味はありません。

@example
(make-bool-vector 3 t)
     @result{} #&3"\007"
(make-bool-vector 3 nil)
     @result{} #&3"\0"
@c ;; @r{These are equal since only the first 3 bits are used.}
;; @r{最初の3ビットだけを使っているので、以下はすべて同じ}
(equal #&3"\377" #&3"\007")
     @result{} t
@end example

@node Function Type
@c @subsection Function Type
@subsection 関数型

@c   Just as functions in other programming languages are executable,
@c @dfn{Lisp function} objects are pieces of executable code.  However,
@c functions in Lisp are primarily Lisp objects, and only secondarily the
@c text which represents them.  These Lisp objects are lambda expressions:
@c lists whose first element is the symbol @code{lambda} (@pxref{Lambda
@c Expressions}).
他のプログラム言語の関数が実行可能であるように、
@dfn{Lisp関数}（Lisp function）は実行可能なコードです。
しかしながら、Lispにおいては、関数は基本Lispオブジェクトであり、
そのテキスト表現は副次的なものです。
これらのLispオブジェクトはラムダ式です。
つまり、先頭要素がシンボル@code{lambda}であるリストです
（@pxref{Lambda Expressions}）。

@c   In most programming languages, it is impossible to have a function
@c without a name.  In Lisp, a function has no intrinsic name.  A lambda
@c expression is also called an @dfn{anonymous function} (@pxref{Anonymous
@c Functions}).  A named function in Lisp is actually a symbol with a valid
@c function in its function cell (@pxref{Defining Functions}).
ほとんどのプログラム言語では、名前のない関数を書くことは不可能です。
Lispでは、本質的には、関数に名前はありません。
ラムダ式のことを@dfn{無名関数}（anonymous function）とも呼びます
（@pxref{Anonymous Functions}）。
Lispにおける名前付き関数は、実際には、
関数セルに正しい関数を収めたシンボルです
（@pxref{Defining Functions}）。

@c   Most of the time, functions are called when their names are written in
@c Lisp expressions in Lisp programs.  However, you can construct or obtain
@c a function object at run time and then call it with the primitive
@c functions @code{funcall} and @code{apply}.  @xref{Calling Functions}.
多くの場合、LispプログラムのLisp式中に関数名を書くと関数が呼ばれます。
しかし、実行時に関数オブジェクトを構成したり取得して、
基本関数@code{funcall}や@code{apply}で、それを呼び出すことができます。
@xref{Calling Functions}。

@node Macro Type
@c @subsection Macro Type
@subsection マクロ型

@c   A @dfn{Lisp macro} is a user-defined construct that extends the Lisp
@c language.  It is represented as an object much like a function, but with
@c different argument-passing semantics.  A Lisp macro has the form of a
@c list whose first element is the symbol @code{macro} and whose @sc{cdr}
@c is a Lisp function object, including the @code{lambda} symbol.
@dfn{Lispマクロ}（Lisp macro）は、
Lisp言語を拡張するユーザー定義の構造です。
関数に似たオブジェクトで表現しますが、引数渡しの意味は異なります。
Lispマクロは、リストの最初の要素がシンボル@code{macro}であり、
リストの@sc{cdr}が@code{lambda}シンボルを
含むLisp関数オブジェクトであるフォームです。

@c   Lisp macro objects are usually defined with the built-in
@c @code{defmacro} function, but any list that begins with @code{macro} is
@c a macro as far as Emacs is concerned.  @xref{Macros}, for an explanation
@c of how to write a macro.
Lispマクロオブジェクトは、通常、組み込み関数@code{defmacro}で
定義しますが、
Emacsにとっては、@code{macro}で始まるリストはマクロです。
マクロの書き方の説明は、@xref{Macros}。

@c   @strong{Warning}: Lisp macros and keyboard macros (@pxref{Keyboard
@c Macros}) are entirely different things.  When we use the word ``macro''
@c without qualification, we mean a Lisp macro, not a keyboard macro.
@strong{警告}：@code{ }Lispマクロとキーボードマクロ
（@pxref{Keyboard Macros}）は、まったく別のものです。
単に『マクロ』といった場合には、Lispマクロを意味するのであって、
キーボードマクロのことではありません。

@node Primitive Function Type
@c @subsection Primitive Function Type
@subsection 基本関数型
@c @cindex special forms
@cindex スペシャルフォーム

@c   A @dfn{primitive function} is a function callable from Lisp but
@c written in the C programming language.  Primitive functions are also
@c called @dfn{subrs} or @dfn{built-in functions}.  (The word ``subr'' is
@c derived from ``subroutine''.)  Most primitive functions evaluate all
@c their arguments when they are called.  A primitive function that does
@c not evaluate all its arguments is called a @dfn{special form}
@c (@pxref{Special Forms}).@refill
@dfn{基本関数型}（primitive function）は、
Lispから呼び出し可能な関数ですが、C言語で書いてあります。
基本関数のことを@dfn{subr}とか
@dfn{組み込み関数}（built-in functions）とも呼びます。
（『subr』は『subroutine』からきている。）
ほとんどの基本関数は、呼び出すときにすべての引数を評価します。
引数すべてを評価しない基本関数を@dfn{スペシャルフォーム}（special form）と
呼びます（@pxref{Special Forms}）。

@c   It does not matter to the caller of a function whether the function is
@c primitive.  However, this does matter if you try to redefine a primitive
@c with a function written in Lisp.  The reason is that the primitive
@c function may be called directly from C code.  Calls to the redefined
@c function from Lisp will use the new definition, but calls from C code
@c may still use the built-in definition.  Therefore, @strong{we discourage
@c redefinition of primitive functions}.
関数を呼び出す側からすれば、関数が基本関数かどうかは関係ありません。
しかし、Lispで書いた関数で基本関数を再定義しようとすると、
問題があります。
というのは、基本関数はCのコードから直接呼ばれるからです。
再定義した関数をLispから呼び出す場合には新しい定義を使いますが、
Cのコードは組み込みの定義を使い続けるでしょう。
したがって、@strong{基本関数を再定義しないでください}。

@c   The term @dfn{function} refers to all Emacs functions, whether written
@c in Lisp or C.  @xref{Function Type}, for information about the
@c functions written in Lisp.
@dfn{関数}（function）という用語で、
LispやCで書かれたEmacsのすべての関数を指します。
Lispで書いた関数に関しては、@xref{Function Type}。

@c   Primitive functions have no read syntax and print in hash notation
@c with the name of the subroutine.
基本関数には入力構文はなく、
サブルーティン名を含むハッシュ記法で表示します。

@example
@group
@c (symbol-function 'car)          ; @r{Access the function cell}
@c                                 ;   @r{of the symbol.}
(symbol-function 'car)          ; @r{シンボルの関数セルを参照する}
     @result{} #<subr car>
@c (subrp (symbol-function 'car))  ; @r{Is this a primitive function?}
@c      @result{} t                       ; @r{Yes.}
(subrp (symbol-function 'car))  ; @r{基本関数か？}
     @result{} t                       ; @r{そのとおり}
@end group
@end example

@node Byte-Code Type
@c @subsection Byte-Code Function Type
@subsection バイトコード関数型

@c The byte compiler produces @dfn{byte-code function objects}.
@c Internally, a byte-code function object is much like a vector; however,
@c the evaluator handles this data type specially when it appears as a
@c function to be called.  @xref{Byte Compilation}, for information about
@c the byte compiler.
バイトコンパイラは、@dfn{バイトコード関数オブジェクト}
（byte-code function objects）を作り出します。
内部的には、バイトコード関数オブジェクトはベクトルによく似ています。
しかしながら、評価過程においては、関数呼び出しのように見えるときには、
このデータ型を特別に扱います。
バイトコンパイラについては、@xref{Byte Compilation}。

@c The printed representation and read syntax for a byte-code function
@c object is like that for a vector, with an additional @samp{#} before the
@c opening @samp{[}.
バイトコード関数オブジェクトの表示表現と入力構文は、
ベクトルに似ていますが、開き角括弧@samp{[}のまえに@samp{#}が付きます。

@node Autoload Type
@c @subsection Autoload Type
@subsection 自動ロード型

@c   An @dfn{autoload object} is a list whose first element is the symbol
@c @code{autoload}.  It is stored as the function definition of a symbol as
@c a placeholder for the real definition; it says that the real definition
@c is found in a file of Lisp code that should be loaded when necessary.
@c The autoload object contains the name of the file, plus some other
@c information about the real definition.
@dfn{自動ロードオブジェクト}（autoload object）は、
先頭要素がシンボル@code{autoload}であるリストです。
実際の定義のかわりにシンボルの関数定義として使われ、
必要なときにロードすべき実際の定義を収めたLispコードファイルを示します。
自動ロードオブジェクトには、ファイル名に加えて、
実際の関数定義に関する他の情報も入っています。

@c   After the file has been loaded, the symbol should have a new function
@c definition that is not an autoload object.  The new definition is then
@c called as if it had been there to begin with.  From the user's point of
@c view, the function call works as expected, using the function definition
@c in the loaded file.
ファイルをロードし終えると、
シンボルには、自動ロードオブジェクトではない新たな関数定義が入ります。
この新たな定義を始めからあったかのように呼び出します。
ユーザーの視点からは、ロードしたファイル内の関数定義を使って、
予想どおりに関数呼び出しが行われます。

@c   An autoload object is usually created with the function
@c @code{autoload}, which stores the object in the function cell of a
@c symbol.  @xref{Autoload}, for more details.
自動ロードオブジェクトは、普通、関数@code{autoload}で作ります。
この関数は、シンボルの関数セルにオブジェクトを格納します。
より詳しくは、@xref{Autoload}。

@node Editing Types
@c @section Editing Types
@section 編集向けの型
@c @cindex editing types
@cindex 編集向けの型
@cindex 型、編集向け

@c   The types in the previous section are used for general programming
@c purposes, and most of them are common to most Lisp dialects.  Emacs Lisp
@c provides several additional data types for purposes connected with
@c editing.
前節の型は一般のプログラム向けに使うもので、
そのほとんどは、ほんどのLisp方言に共通しています。
Emacs Lispには、編集に関連した目的向けにいくつかのデータ型があります。

@menu
* Buffer Type::         The basic object of editing.
* Marker Type::         A position in a buffer.
* Window Type::         Buffers are displayed in windows.
* Frame Type::		Windows subdivide frames.
* Window Configuration Type::   Recording the way a frame is subdivided.
* Frame Configuration Type::    Recording the status of all frames.
* Process Type::        A process running on the underlying OS.
* Stream Type::         Receive or send characters.
* Keymap Type::         What function a keystroke invokes.
* Overlay Type::        How an overlay is represented.
@end menu

@node Buffer Type
@c @subsection Buffer Type
@subsection バッファ型

@c   A @dfn{buffer} is an object that holds text that can be edited
@c (@pxref{Buffers}).  Most buffers hold the contents of a disk file
@c (@pxref{Files}) so they can be edited, but some are used for other
@c purposes.  Most buffers are also meant to be seen by the user, and
@c therefore displayed, at some time, in a window (@pxref{Windows}).  But a
@c buffer need not be displayed in any window.
@dfn{バッファ}（buffer）は、編集可能なテキストを保持するオブジェクトです
（@pxref{Buffers}）。
ほとんどのバッファは、ディスクファイル（@pxref{Files}）の内容を保持して
編集できるようにしますが、他の目的に使われるものもあります。
ほとんどのバッファは、ユーザーが見るためのものであり、
ある期間、ウィンドウ（@pxref{Windows}）に表示されます。
しかし、バッファがいずれかのウィンドウに必ずしも表示される必要はありません。

@c   The contents of a buffer are much like a string, but buffers are not
@c used like strings in Emacs Lisp, and the available operations are
@c different.  For example, you can insert text efficiently into an
@c existing buffer, whereas ``inserting'' text into a string requires
@c concatenating substrings, and the result is an entirely new string
@c object.
バッファの内容は文字列によく似ていますが、
Emacs Lispにおいては、バッファは文字列のようには使われず、
適用可能な操作も異なります。
たとえば、既存のバッファにテキストを効率よく挿入できますが、
文字列にテキストを『挿入』するには、
部分文字列を連結する必要があり、まったく新しい文字列オブジェクトになります。

@c   Each buffer has a designated position called @dfn{point}
@c (@pxref{Positions}).  At any time, one buffer is the @dfn{current
@c buffer}.  Most editing commands act on the contents of the current
@c buffer in the neighborhood of point.  Many of the standard Emacs
@c functions manipulate or test the characters in the current buffer; a
@c whole chapter in this manual is devoted to describing these functions
@c (@pxref{Text}).
各バッファには、@dfn{ポイント}（point）と呼ばれる特別な箇所があります
（@pxref{Positions}）。
どんなときにも、1つのバッファが@dfn{カレントバッファ}（current buffer）です。
ほとんどの編集コマンドは、カレントバッファのポイント付近の内容に作用します。
多くのEmacsの標準関数は、カレントバッファ内にある文字を操作したり検査します。
本書には、これらの関数の説明にあてた章が1つあります（@pxref{Text}）。

@c   Several other data structures are associated with each buffer:
各バッファに関連付けられたデータ構造には、つぎのものがあります。

@itemize @bullet
@item
@c a local syntax table (@pxref{Syntax Tables});
ローカル構文テーブル（@pxref{Syntax Tables}）

@item
@c a local keymap (@pxref{Keymaps}); and,
ローカルキーマップ（@pxref{Keymaps}）。
および

@item
@c a list of buffer-local variable bindings (@pxref{Buffer-Local Variables}).
バッファにローカルな変数束縛リスト（@pxref{Buffer-Local Variables}）。

@item
@c overlays (@pxref{Overlays}).
オーバレイ（@pxref{Overlays}）。

@item
@c text properties for the text in the buffer (@pxref{Text Properties}).
バッファ内のテキストのテキスト属性（@pxref{Text Properties}）。
@end itemize

@noindent
@c The local keymap and variable list contain entries that individually
@c override global bindings or values.  These are used to customize the
@c behavior of programs in different buffers, without actually changing the
@c programs.
ローカルキーマップと変数リストには、
それぞれ、グローバルな束縛や値に優先するものが入っています。
これらは、プログラムを変更せずに、各バッファごとに、
プログラムのふるまいをカスタマイズするために使われます。

@c   A buffer may be @dfn{indirect}, which means it shares the text
@c of another buffer, but presents it differently.  @xref{Indirect Buffers}.
バッファは@dfn{間接}（indirect）でもよく、その場合、
別のバッファとテキストを共有しつつ異なった表示を行えます。
@xref{Indirect Buffers}。

@c   Buffers have no read syntax.  They print in hash notation, showing the
@c buffer name.
バッファには入力構文はありません。
バッファ名を含んだハッシュ記法で表示します。

@example
@group
(current-buffer)
     @result{} #<buffer objects.texi>
@end group
@end example

@node Marker Type
@c @subsection Marker Type
@subsection マーカ型

@c   A @dfn{marker} denotes a position in a specific buffer.  Markers
@c therefore have two components: one for the buffer, and one for the
@c position.  Changes in the buffer's text automatically relocate the
@c position value as necessary to ensure that the marker always points
@c between the same two characters in the buffer.
@dfn{マーカ}（marker）は、特定のバッファ内の位置を表します。
したがって、マーカには2つの構成要素、つまり、
バッファを示すものと位置を示すものがあります。
バッファ内のテキストを変更すると、
マーカがバッファ内の同じ2つの文字のあいだをつねに指すことを保証するように、
位置の値を更新します。

@c   Markers have no read syntax.  They print in hash notation, giving the
@c current character position and the name of the buffer.
マーカには入力構文はありません。
バッファ内の文字位置とバッファ名を含んだハッシュ記法で表示します。

@example
@group
(point-marker)
     @result{} #<marker at 10779 in objects.texi>
@end group
@end example

@c @xref{Markers}, for information on how to test, create, copy, and move
@c markers.
マーカの検査、作成、コピー、移動の方法については、@xref{Markers}。

@node Window Type
@c @subsection Window Type
@subsection ウィンドウ型

@c   A @dfn{window} describes the portion of the terminal screen that Emacs
@c uses to display a buffer.  Every window has one associated buffer, whose
@c contents appear in the window.  By contrast, a given buffer may appear
@c in one window, no window, or several windows.
@dfn{ウィンドウ}（window）は、
Emacsがバッファを表示するために使用する端末画面の部分のことです。
各ウィンドウには、対応付けられたバッファが1つあり、
そのバッファの内容をウィンドウに表示しています。
一方、あるバッファが、1つのウィンドウや複数のウィンドウに表示されることもあり、
どのウィンドウにも表示されないこともあります。

@c   Though many windows may exist simultaneously, at any time one window
@c is designated the @dfn{selected window}.  This is the window where the
@c cursor is (usually) displayed when Emacs is ready for a command.  The
@c selected window usually displays the current buffer, but this is not
@c necessarily the case.
同時に複数のウィンドウが存在できますが、
どんなときにも1つのウィンドウだけが@dfn{選択されたウィンドウ}
（selected window）です。
これは、Emacsがコマンドを受け付け可能なときにカーソルを（通常）表示する
ウィンドウです。
選択されたウィンドウは、通常、カレントバッファを表示しますが、
これは必須ではありません。

@c   Windows are grouped on the screen into frames; each window belongs to
@c one and only one frame.  @xref{Frame Type}.
画面上のウィンドウはフレームにまとめられています。
各ウィンドウは、たった1つのフレームに属します。
@xref{Frame Type}。

@c   Windows have no read syntax.  They print in hash notation, giving the
@c window number and the name of the buffer being displayed.  The window
@c numbers exist to identify windows uniquely, since the buffer displayed
@c in any given window can change frequently.
ウィンドウには入力構文はありません。
ウィンドウ番号と表示中のバッファ名を含んだハッシュ記法で表示します。
ウィンドウ番号は、ウィンドウを一意に識別するためにあります。
これは、ウィンドウが表示しているバッファは頻繁に変わるからです。

@example
@group
(selected-window)
     @result{} #<window 1 on objects.texi>
@end group
@end example

@c   @xref{Windows}, for a description of the functions that work on windows.
ウィンドウを操作する関数の説明は、@xref{Windows}。

@node Frame Type
@c @subsection Frame Type
@subsection フレーム型

@c   A @dfn{frame} is a rectangle on the screen that contains one or more
@c Emacs windows.  A frame initially contains a single main window (plus
@c perhaps a minibuffer window) which you can subdivide vertically or
@c horizontally into smaller windows.
@dfn{フレーム}（frame）は、画面上の矩形領域であって、
1つ以上のEmacsウィンドウを含みます。
フレームには最初は1つのウィンドウ
（とミニバッファウィンドウ）が含まれますが、
これを左右や上下に小さなウィンドウに分割できます。

@c   Frames have no read syntax.  They print in hash notation, giving the
@c frame's title, plus its address in core (useful to identify the frame
@c uniquely).
フレームには入力構文はありません。
フレームのタイトルとメモリ内のアドレス
（フレームを一意に識別するのに有用）を含んだハッシュ記法で表示します。

@example
@group
(selected-frame)
     @result{} #<frame emacs@@psilocin.gnu.org 0xdac80>
@end group
@end example

@c   @xref{Frames}, for a description of the functions that work on frames.
フレームを操作する関数の説明は、@xref{Frames}。

@node Window Configuration Type
@c @subsection Window Configuration Type
@subsection ウィンドウ構成型
@c @cindex screen layout
@cindex 画面配置

@c   A @dfn{window configuration} stores information about the positions,
@c sizes, and contents of the windows in a frame, so you can recreate the
@c same arrangement of windows later.
@dfn{ウィンドウ構成}（window configuration）は、
フレーム内のウィンドウの位置／サイズ／内容に関する情報を記録し、
同じ配置のウィンドウをあとで再度作成できるようにします。

@c   Window configurations do not have a read syntax; their print syntax
@c looks like @samp{#<window-configuration>}.  @xref{Window
@c Configurations}, for a description of several functions related to
@c window configurations.
ウィンドウ構成には入力構文はありません。
表示表現は、@samp{#<window-configuration>}のようになります。
ウィンドウ構成に関連した関数の説明は、@xref{Window Configurations}。

@node Frame Configuration Type
@c @subsection Frame Configuration Type
@subsection フレーム構成型
@c @cindex screen layout
@cindex 画面配置

@c   A @dfn{frame configuration} stores information about the positions,
@c sizes, and contents of the windows in all frames.  It is actually
@c a list whose @sc{car} is @code{frame-configuration} and whose
@c @sc{cdr} is an alist.  Each alist element describes one frame,
@c which appears as the @sc{car} of that element.
@dfn{フレーム構成}（frame configuration）は、
すべてのフレームのウィンドウの位置／サイズ／内容に関する情報の記録です。
これは、実際には、リストの@sc{car}が@code{frame-configuration}であり、
リストの@sc{cdr}が連想リストであるリストです。
連想リストの各要素で、その@sc{car}に現れるフレーム1個を記述します。

@c   @xref{Frame Configurations}, for a description of several functions
@c related to frame configurations.
フレーム構成に関連した関数の説明は、@xref{Frame Configurations}。

@node Process Type
@c @subsection Process Type
@subsection プロセス型

@c   The word @dfn{process} usually means a running program.  Emacs itself
@c runs in a process of this sort.  However, in Emacs Lisp, a process is a
@c Lisp object that designates a subprocess created by the Emacs process.
@c Programs such as shells, GDB, ftp, and compilers, running in
@c subprocesses of Emacs, extend the capabilities of Emacs.
単語@dfn{プロセス}（process）は、通常、実行中のプログラムを意味します。
Emacs自身、この種のプロセスとして実行されています。
しかし、Emacs Lispでは、プロセスとは、
Emacsプロセスが作成したサブプロセスを表すLispオブジェクトのことです。
Emacsのサブプロセスで実行される、シェル、GDB、ftp、コンパイラなどの
プログラムは、Emacsの能力を拡張します。

@c   An Emacs subprocess takes textual input from Emacs and returns textual
@c output to Emacs for further manipulation.  Emacs can also send signals
@c to the subprocess.
Emacsサブプロセスは、Emacsからテキスト入力を受け取り、
さらに処理できるようにEmacsにテキスト出力を返します。
Emacsはサブプロセスにシグナルを送ることもできます。

@c   Process objects have no read syntax.  They print in hash notation,
@c giving the name of the process:
プロセスオブジェクトに入力構文はありません。
プロセス名を含んだハッシュ記法で表示します。

@example
@group
(process-list)
     @result{} (#<process shell>)
@end group
@end example

@c @xref{Processes}, for information about functions that create, delete,
@c return information about, send input or signals to, and receive output
@c from processes.
プロセスを作成したり削除したり、プロセスに関する情報を返したり、
プロセスへ入力やシグナルを送ったり、プロセスから出力を受け取る
関数に関する情報は、@xref{Processes}。

@node Stream Type
@c @subsection Stream Type
@subsection ストリーム型

@c   A @dfn{stream} is an object that can be used as a source or sink for
@c characters---either to supply characters for input or to accept them as
@c output.  Many different types can be used this way: markers, buffers,
@c strings, and functions.  Most often, input streams (character sources)
@c obtain characters from the keyboard, a buffer, or a file, and output
@c streams (character sinks) send characters to a buffer, such as a
@c @file{*Help*} buffer, or to the echo area.
@dfn{ストリーム}（stream）は、文字を出し入れする対象、
つまり、入力用に文字を供給したり、出力として文字を受け取ったりといった
ことに使えるオブジェクトです。
多くの異なる型をこのように使えます。
マーカ、バッファ、文字列、関数です。
ほとんどの場合、入力ストリーム（文字の供給源）は、
キーボード、バッファ、ファイルから文字を取得します。
出力ストリーム（文字の消費先）は、@file{*Help*}バッファなどのバッファや
エコー領域に文字を送ります。

@c   The object @code{nil}, in addition to its other meanings, may be used
@c as a stream.  It stands for the value of the variable
@c @code{standard-input} or @code{standard-output}.  Also, the object
@c @code{t} as a stream specifies input using the minibuffer
@c (@pxref{Minibuffers}) or output in the echo area (@pxref{The Echo
@c Area}).
オブジェクト@code{nil}は、他の意味に加えて、
ストリームとしても使えます。
変数@code{standard-input}や@code{standard-output}の値になります。
また、オブジェクト@code{t}も、
ミニバッファ（@pxref{Minibuffers}）を使う入力ストリームや
エコー領域への出力（@pxref{The Echo Area}）を意味します。

@c   Streams have no special printed representation or read syntax, and
@c print as whatever primitive type they are.
ストリームには表示形式も入力構文もなく、その基本型で表示します。

@c   @xref{Read and Print}, for a description of functions
@c related to streams, including parsing and printing functions.
構文解析関数や表示関数を含むストリームに関連した関数の説明は、
@xref{Read and Print}。

@node Keymap Type
@c @subsection Keymap Type
@subsection キーマップ型

@c   A @dfn{keymap} maps keys typed by the user to commands.  This mapping
@c controls how the user's command input is executed.  A keymap is actually
@c a list whose @sc{car} is the symbol @code{keymap}.
@dfn{キーマップ}（keymap）は、ユーザーが打ったキーをコマンドに対応付けます。
この対応付けは、ユーザーのコマンド入力をどのように実行するかを制御します。
キーマップは、実際には、リストであり、
その@sc{car}はシンボル@code{keymap}です。

@c   @xref{Keymaps}, for information about creating keymaps, handling prefix
@c keys, local as well as global keymaps, and changing key bindings.
キーマップの作成、プレフィックスキーの扱い方、
グローバルやローカルなキーマップ、キーバインディングの変更に関する情報は、
@xref{Keymaps}。

@node Overlay Type
@c @subsection Overlay Type
@subsection オーバレイ型

@c   An @dfn{overlay} specifies properties that apply to a part of a
@c buffer.  Each overlay applies to a specified range of the buffer, and
@c contains a property list (a list whose elements are alternating property
@c names and values).  Overlay properties are used to present parts of the
@c buffer temporarily in a different display style.  Overlays have no read
@c syntax, and print in hash notation, giving the buffer name and range of
@c positions.
@dfn{オーバレイ}（overlay）は、バッファのある部分に作用する属性を指定します。
各オーバレイは、バッファの指定した範囲に作用し、
属性リスト（属性名と値の要素を交互に繰り返すリスト）を含んでいます。
オーバレイ属性は、
バッファの一部を一時的に異なった方式で表示するために使われます。
オーバレイ属性に入力構文はなく、
バッファ名と位置範囲を含んだハッシュ記法で表示します。

@c   @xref{Overlays}, for how to create and use overlays.
オーバレイの作成と使用法については、@xref{Overlays}。

@node Type Predicates
@c @section Type Predicates
@section 型述語
@c @cindex predicates
@c @cindex type checking
@cindex 述語
@cindex 型検査
@kindex wrong-type-argument

@c   The Emacs Lisp interpreter itself does not perform type checking on
@c the actual arguments passed to functions when they are called.  It could
@c not do so, since function arguments in Lisp do not have declared data
@c types, as they do in other programming languages.  It is therefore up to
@c the individual function to test whether each actual argument belongs to
@c a type that the function can use.
Emacs Lispインタープリタ自身は、関数を呼び出すときに渡す実引数の
型検査を行いません。
そうできないのは、他のプログラム言語が行うようには、
Lispの関数の引数にはデータ型の宣言がないからです。
したがって、各実引数がその関数で扱える型に属するかどうかを検査するのは、
各関数の責任です。

@c   All built-in functions do check the types of their actual arguments
@c when appropriate, and signal a @code{wrong-type-argument} error if an
@c argument is of the wrong type.  For example, here is what happens if you
@c pass an argument to @code{+} that it cannot handle:
すべての組み込み関数は、必要なときには実引数の型検査を行い、
引数が誤った型であれば、エラー@code{wrong-type-argument}を通知します。
たとえば、@code{+}に扱えない引数を渡すと、つぎのようになります。

@example
@group
(+ 2 'a)
     @error{} Wrong type argument: number-or-marker-p, a
@end group
@end example

@c @cindex type predicates
@c @cindex testing types
@cindex 型述語
@cindex 型の検査
@c   If you want your program to handle different types differently, you
@c must do explicit type checking.  The most common way to check the type
@c of an object is to call a @dfn{type predicate} function.  Emacs has a
@c type predicate for each type, as well as some predicates for
@c combinations of types.
読者のプログラムで、異なる型を異なるように扱いたい場合には、
明示的に型検査を行う必要があります。
オブジェクトの型を検査するもっとも一般的な方法は、
@dfn{型述語}（type predicate）関数を呼び出すことです。
Emacsには、各型ごとに型述語があり、
型を組み合わせたものに対する述語もあります。

@c   A type predicate function takes one argument; it returns @code{t} if
@c the argument belongs to the appropriate type, and @code{nil} otherwise.
@c Following a general Lisp convention for predicate functions, most type
@c predicates' names end with @samp{p}.
型述語関数は1つの引数を取ります。
引数が適切な型に属していれば@code{t}を返し、
さもなければ@code{nil}を返します。
述語関数に関するLisp一般の慣習に従って、
ほとんどの型述語の名前は@samp{p}で終ります。

@c   Here is an example which uses the predicates @code{listp} to check for
@c a list and @code{symbolp} to check for a symbol.
以下は、リストの検査に述語@code{listp}を使い、
シンボルの検査に述語@code{symbolp}を使う例です。

@example
(defun add-on (x)
  (cond ((symbolp x)
@c          ;; If X is a symbol, put it on LIST.
         ;; Xがシンボルならば、それをLISTに加える
         (setq list (cons x list)))
        ((listp x)
@c          ;; If X is a list, add its elements to LIST.
         ;; Xがリストならば、その要素をLISTに追加する
         (setq list (append x list)))
        (t
@c          ;; We handle only symbols and lists.
         ;; シンボルとリストだけを扱う
         (error "Invalid argument %s in add-on" x))))
@end example

@c   Here is a table of predefined type predicates, in alphabetical order,
@c with references to further information.
定義済みの型述語を、アルファベット順に、参照先を併記してあげておきます。

@table @code
@item atom
@c @xref{List-related Predicates, atom}.
@pxref{List-related Predicates, atom}。

@item arrayp
@c @xref{Array Functions, arrayp}.
@pxref{Array Functions, arrayp}。

@item bool-vector-p
@c @xref{Bool-Vectors, bool-vector-p}.
@pxref{Bool-Vectors, bool-vector-p}。

@item bufferp
@c @xref{Buffer Basics, bufferp}.
@pxref{Buffer Basics, bufferp}。

@item byte-code-function-p
@c @xref{Byte-Code Type, byte-code-function-p}.
@pxref{Byte-Code Type, byte-code-function-p}。

@item case-table-p
@c @xref{Case Tables, case-table-p}.
@pxref{Case Tables, case-table-p}。

@item char-or-string-p
@c @xref{Predicates for Strings, char-or-string-p}.
@pxref{Predicates for Strings, char-or-string-p}。

@item char-table-p
@c @xref{Char-Tables, char-table-p}.
@pxref{Char-Tables, char-table-p}。

@item commandp
@c @xref{Interactive Call, commandp}.
@pxref{Interactive Call, commandp}。

@item consp
@c @xref{List-related Predicates, consp}.
@pxref{List-related Predicates, consp}。

@item display-table-p
@c @xref{Display Tables, display-table-p}.
@pxref{Display Tables, display-table-p}。

@item floatp
@c @xref{Predicates on Numbers, floatp}.
@pxref{Predicates on Numbers, floatp}。

@item frame-configuration-p
@c @xref{Frame Configurations, frame-configuration-p}.
@pxref{Frame Configurations, frame-configuration-p}。

@item frame-live-p
@c @xref{Deleting Frames, frame-live-p}.
@pxref{Deleting Frames, frame-live-p}。

@item framep
@c @xref{Frames, framep}.
@pxref{Frames, framep}。

@item functionp
@c @xref{Functions, functionp}.
@pxref{Functions, functionp}。

@item integer-or-marker-p
@c @xref{Predicates on Markers, integer-or-marker-p}.
@pxref{Predicates on Markers, integer-or-marker-p}。

@item integerp
@c @xref{Predicates on Numbers, integerp}.
@pxref{Predicates on Numbers, integerp}。

@item keymapp
@c @xref{Creating Keymaps, keymapp}.
@pxref{Creating Keymaps, keymapp}。

@item listp
@c @xref{List-related Predicates, listp}.
@pxref{List-related Predicates, listp}。

@item markerp
@c @xref{Predicates on Markers, markerp}.
@pxref{Predicates on Markers, markerp}。

@item wholenump
@c @xref{Predicates on Numbers, wholenump}.
@pxref{Predicates on Numbers, wholenump}。

@item nlistp
@c @xref{List-related Predicates, nlistp}.
@pxref{List-related Predicates, nlistp}。

@item numberp
@c @xref{Predicates on Numbers, numberp}.
@pxref{Predicates on Numbers, numberp}。

@item number-or-marker-p
@c @xref{Predicates on Markers, number-or-marker-p}.
@pxref{Predicates on Markers, number-or-marker-p}。

@item overlayp
@c @xref{Overlays, overlayp}.
@pxref{Overlays, overlayp}。

@item processp
@c @xref{Processes, processp}.
@pxref{Processes, processp}。

@item sequencep
@c @xref{Sequence Functions, sequencep}.
@pxref{Sequence Functions, sequencep}。

@item stringp
@c @xref{Predicates for Strings, stringp}.
@pxref{Predicates for Strings, stringp}。

@item subrp
@c @xref{Function Cells, subrp}.
@pxref{Function Cells, subrp}。

@item symbolp
@c @xref{Symbols, symbolp}.
@pxref{Symbols, symbolp}。

@item syntax-table-p
@c @xref{Syntax Tables, syntax-table-p}.
@pxref{Syntax Tables, syntax-table-p}。

@item user-variable-p
@c @xref{Defining Variables, user-variable-p}.
@pxref{Defining Variables, user-variable-p}。

@item vectorp
@c @xref{Vectors, vectorp}.
@pxref{Vectors, vectorp}。

@item window-configuration-p
@c @xref{Window Configurations, window-configuration-p}.
@pxref{Window Configurations, window-configuration-p}。

@item window-live-p
@c @xref{Deleting Windows, window-live-p}.
@pxref{Deleting Windows, window-live-p}。

@item windowp
@c @xref{Basic Windows, windowp}.
@pxref{Basic Windows, windowp}。
@end table

@c   The most general way to check the type of an object is to call the
@c function @code{type-of}.  Recall that each object belongs to one and
@c only one primitive type; @code{type-of} tells you which one (@pxref{Lisp
@c Data Types}).  But @code{type-of} knows nothing about non-primitive
@c types.  In most cases, it is more convenient to use type predicates than
@c @code{type-of}.
オブジェクトの型を調べるもっとも一般的な方法は、
関数@code{type-of}を呼び出すことです。
各オブジェクトはたった1つの基本型に属することを思い出してください。
@code{type-of}はどの1つかを教えてくれます（@pxref{Lisp Data Types}）。
しかし、@code{type-of}は、基本型以外についてはなにも知りません。
多くの場合、@code{type-of}より型述語を使うほうが便利でしょう。

@defun type-of object
@c This function returns a symbol naming the primitive type of
@c @var{object}.  The value is one of the symbols @code{symbol},
@c @code{integer}, @code{float}, @code{string}, @code{cons}, @code{vector},
@c @code{char-table}, @code{bool-vector}, @code{subr},
@c @code{compiled-function}, @code{marker}, @code{overlay}, @code{window},
@c @code{buffer}, @code{frame}, @code{process}, or
@c @code{window-configuration}.
この関数は、@var{object}の基本型を示すシンボルを返す。
その値は、
@code{symbol}、
@code{integer}、@code{float}、@code{string}、@code{cons}、@code{vector}、
@code{char-table}、@code{bool-vector}、@code{subr}、
@code{compiled-function}、@code{marker}、@code{overlay}、@code{window}、
@code{buffer}、@code{frame}、@code{process}、@code{window-configuration}の
シンボルのうちの1つ。

@example
(type-of 1)
     @result{} integer
(type-of 'nil)
     @result{} symbol
@c (type-of '())    ; @r{@code{()} is @code{nil}.}
(type-of '())    ; @r{@code{()}は@code{nil}}
     @result{} symbol
(type-of '(x))
     @result{} cons
@end example
@end defun

@node Equality Predicates
@c @section Equality Predicates
@section 同値述語
@c @cindex equality
@cindex 同値

@c   Here we describe two functions that test for equality between any two
@c objects.  Other functions test equality between objects of specific
@c types, e.g., strings.  For these predicates, see the appropriate chapter
@c describing the data type.
2つのオブジェクトの同値関係を調べる2つの関数を説明します。
文字列などの特定のオブジェクトが同値であるかを調べる関数群もあります。
これらの述語については、データ型を述べている適切な章を参照してください。

@defun eq object1 object2
@c This function returns @code{t} if @var{object1} and @var{object2} are
@c the same object, @code{nil} otherwise.  The ``same object'' means that a
@c change in one will be reflected by the same change in the other.
この関数は、@var{object1}と@var{object2}が
同一オブジェクトであれば@code{t}を返し、さもなければ@code{nil}を返す。
『同一オブジェクト』とは、
一方を変更すると、他方にも同じ変更が反映されることを意味する。

@c @code{eq} returns @code{t} if @var{object1} and @var{object2} are
@c integers with the same value.  Also, since symbol names are normally
@c unique, if the arguments are symbols with the same name, they are
@c @code{eq}.  For other types (e.g., lists, vectors, strings), two
@c arguments with the same contents or elements are not necessarily
@c @code{eq} to each other: they are @code{eq} only if they are the same
@c object.
@code{eq}は、@var{object1}と@var{object2}が同じ値の整数であると
@code{t}を返す。
また、シンボル名は、普通、一意であるので、
引数が同じ名前のシンボルであれば、それらは@code{eq}である。
（リスト、ベクトル、文字列などの）それ以外の型の場合、
2つの引数が同じ内容や要素であっても、
互いに@code{eq}であるとは限らない。
それらが同一オブジェクトである場合に限り@code{eq}である。

@example
@group
(eq 'foo 'foo)
     @result{} t
@end group

@group
(eq 456 456)
     @result{} t
@end group

@group
(eq "asdf" "asdf")
     @result{} nil
@end group

@group
(eq '(1 (2 (3))) '(1 (2 (3))))
     @result{} nil
@end group

@group
(setq foo '(1 (2 (3))))
     @result{} (1 (2 (3)))
(eq foo foo)
     @result{} t
(eq foo '(1 (2 (3))))
     @result{} nil
@end group

@group
(eq [(1 2) 3] [(1 2) 3])
     @result{} nil
@end group

@group
(eq (point-marker) (point-marker))
     @result{} nil
@end group
@end example

@c The @code{make-symbol} function returns an uninterned symbol, distinct
@c from the symbol that is used if you write the name in a Lisp expression.
@c Distinct symbols with the same name are not @code{eq}.  @xref{Creating
@c Symbols}.
関数@code{make-symbol}は、インターンしたシンボルを返す。
このシンボルは、Lisp式に書いた同じ名前のシンボルと区別される。
名前が同じでも区別されるシンボルは@code{eq}ではない。
@pxref{Creating Symbols}。

@example
@group
(eq (make-symbol "foo") 'foo)
     @result{} nil
@end group
@end example
@end defun

@defun equal object1 object2
@c This function returns @code{t} if @var{object1} and @var{object2} have
@c equal components, @code{nil} otherwise.  Whereas @code{eq} tests if its
@c arguments are the same object, @code{equal} looks inside nonidentical
@c arguments to see if their elements are the same.  So, if two objects are
@c @code{eq}, they are @code{equal}, but the converse is not always true.
この関数は、 @var{object1}と@var{object2}が等しい要素を持てば@code{t}を返し、
さもなければ@code{nil}を返す。
@code{eq}は引数が同一オブジェクトかどうかを調べるが、
@code{equal}は、同一ではない引数の内部を調べ、
それらの要素が同じかどうかを調べる。
したがって、2つのオブジェクトが@code{eq}ならば、
それらは@code{equal}であるが、その逆はつねに真とは限らない。

@example
@group
(equal 'foo 'foo)
     @result{} t
@end group

@group
(equal 456 456)
     @result{} t
@end group

@group
(equal "asdf" "asdf")
     @result{} t
@end group
@group
(eq "asdf" "asdf")
     @result{} nil
@end group

@group
(equal '(1 (2 (3))) '(1 (2 (3))))
     @result{} t
@end group
@group
(eq '(1 (2 (3))) '(1 (2 (3))))
     @result{} nil
@end group

@group
(equal [(1 2) 3] [(1 2) 3])
     @result{} t
@end group
@group
(eq [(1 2) 3] [(1 2) 3])
     @result{} nil
@end group

@group
(equal (point-marker) (point-marker))
     @result{} t
@end group

@group
(eq (point-marker) (point-marker))
     @result{} nil
@end group
@end example

@c Comparison of strings is case-sensitive, but does not take account of
@c text properties---it compares only the characters in the strings.
@c A unibyte string never equals a multibyte string unless the
@c contents are entirely @sc{ASCII} (@pxref{Text Representations}).
文字列の比較では大文字小文字を区別するが、テキスト属性は考慮しない。
つまり、文字列内の文字だけを比較する。
文字列の内容がすべて@sc{ASCII}でなければ、
ユニバイト文字列とマルチバイト文字列が等しいことはない
（@pxref{Text Representations}）。

@example
@group
(equal "asdf" "ASDF")
     @result{} nil
@end group
@end example

@c Two distinct buffers are never @code{equal}, even if their contents
@c are the same.
たとえ内容が同じであっても、
異なる2つのバッファが@code{equal}であることはない。
@end defun

@c   The test for equality is implemented recursively, and circular lists may
@c therefore cause infinite recursion (leading to an error).
@code{equal}の検査は再帰で実装されているので、
リストに循環があると無限再帰を引き起こし（エラーになり）ます。
